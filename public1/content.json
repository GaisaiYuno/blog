{"meta":{"title":"StevenMengのBlog","subtitle":"-------我太蒻了","description":"OI竞赛","author":"Steven_Meng","url":"https://gaisaiyuno.github.io","root":"/"},"pages":[{"title":"","date":"2019-07-28T10:21:22.615Z","updated":"2019-07-14T06:51:23.975Z","comments":true,"path":"google8ff10352272a251b.html","permalink":"https://gaisaiyuno.github.io/google8ff10352272a251b.html","excerpt":"","text":"google-site-verification: google8ff10352272a251b.html"},{"title":"About me","date":"2019-03-13T10:25:18.000Z","updated":"2019-09-29T04:41:09.024Z","comments":true,"path":"about/index.html","permalink":"https://gaisaiyuno.github.io/about/index.html","excerpt":"","text":"来自szzx高一的一只菜鸡，被巨佬吊打。 特别喜欢废萌，百合和可爱的女孩纸。 喜欢日系的歌曲（初中那会喜欢欧美风） 现在主要搞C++，偶尔会写python，javascript，php，html之类的。 喜欢随机化，数据结构，大暴力，乱搞。 不喜欢单调队列，高精度，卡常题。 买一个萌qwq​"},{"title":"我的朋友们","date":"2019-09-30T06:16:39.972Z","updated":"2019-09-30T06:16:39.972Z","comments":true,"path":"friends/index.html","permalink":"https://gaisaiyuno.github.io/friends/index.html","excerpt":"","text":"欢迎各位交换友链！必须有名称、blog链接和头像链接！ 名称： Steven_MengのBlog头像： https://gitee.com/steven_meng/kon/raw/master/head.png网址： https://gaisaiyuno.github.io标签： 蒟蒻，二次元"},{"title":"Friends","date":"2019-03-13T10:25:18.000Z","updated":"2019-09-03T04:52:19.135Z","comments":true,"path":"friends/index——1.html","permalink":"https://gaisaiyuno.github.io/friends/index——1.html","excerpt":"","text":"我们的团队 为了OI（搞基）之锤-深圳中学 - 团队 友情链接（都是巨佬）： ypy：白桦树 oier_forever birchtree 老婆：古河渚とLJZ zyd：Peter_Z The_OIer ~~老婆：藤林椋 _config.yml ~~ yxc：eric161324 老婆：WYX ljz：Nero_Claudius 老婆：YPY ygy：サイタマ YGY’s Blog zhh：Dota_Air lhx：Orion545 dedicatus545"},{"title":"","date":"2019-10-08T15:07:16.063Z","updated":"2019-10-08T15:07:01.854Z","comments":true,"path":"hexo-backup/README.html","permalink":"https://gaisaiyuno.github.io/hexo-backup/README.html","excerpt":"","text":"hexo backup hexo backup for Steven_Meng"},{"title":"留言板","date":"2019-10-09T04:53:03.922Z","updated":"2019-10-09T04:53:03.922Z","comments":true,"path":"message/index.html","permalink":"https://gaisaiyuno.github.io/message/index.html","excerpt":"","text":"可以在这里留言哦！ 欢迎问问题，灌水，吐槽。"},{"title":"实验室","date":"2019-10-10T10:43:19.660Z","updated":"2019-10-10T10:43:19.660Z","comments":true,"path":"lab/index.html","permalink":"https://gaisaiyuno.github.io/lab/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-03-13T07:32:03.000Z","updated":"2019-04-09T02:59:22.256Z","comments":true,"path":"tags/index.html","permalink":"https://gaisaiyuno.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网站公示","slug":"网站公示","date":"2026-08-17T13:35:15.000Z","updated":"2019-10-09T04:56:50.497Z","comments":true,"path":"archives/5bce2e78.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5bce2e78.html","excerpt":"","text":"以后有什么更新会写在里面： 2019/8/2：添加音乐播放器。 2019/8/4：添加评论系统。 2019/8/5：修复了图标。 2019/8/8：新增BZOJ离线题库，点击这里访问，可以参考这篇博客自己搭建。 2019/8/8：修复离线图库的图标，原来是字体崩了。 2019/8/10：稳定外链get，基本是320kbps，感谢www.missevan.com。 2019/8/10：添加2048。 2019/8/11：修复标题。 2019/8/20：修复歌单滚动条。 2019/8/30：添加新的404界面。 2019/8/31：重大更新： 1.主题换成Material X 2.Aplayer改成侧边栏 3.优化搜索功能 4.新的背景图片 2019/9/2：增加自定义域名http://stevenmhy.tk/ 2019/9/13：添加在线Markdown编辑器，虽然bug很多 2019/9/21：添加实验室功能。 2019/9/24：添加点赞功能。感谢https://widgetpack.com/ 2019/9/28：增添最新评论功能，由大佬辣椒の酱友情提供。（由于本人不会配色，所以显得很挫） 2019/10/9：添加留言板功能。 todo list: 添加pjax支持 去掉aplayer两个按钮 9月访问量统计（刚刚接入Cloudflare）：","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]},{"title":"BZOJ 3451 Tyvj1953 Normal","slug":"BZOJ-3451-Tyvj1953-Normal","date":"2019-10-09T14:41:43.000Z","updated":"2019-10-09T15:08:46.511Z","comments":true,"path":"archives/4c0b76ff.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4c0b76ff.html","excerpt":"","text":"此题恶臭，心态被搞了。 考虑$Solve$算法，每个点有且仅有一次被当做树的根，于是可以将整个算法的期望时间复杂度变成每个点的树的期望大小之和。 想到这里，你还得有一个更加恶臭的想法，考虑如何表示每个点的树的期望大小，记$p[i][j]$为$j$在$i$子树里面的概率。 那么$i$子树的期望大小即是$\\sum _{j!=i} p[i][j]$。 如何计算$p[i][j]$，考虑$i$到$j$的路径上共$dis(i,j)+1$个点，只有$i$是第一个被选择的点时，$i$和$j$才不会被分开，于是$p[i][j]=\\frac{1}{dis(i,j)+1}$。 如何计算$\\sum _{i=1}^n \\sum _{j=1} ^n \\frac{1}{dis(i,j)+1}$。 我们转换一下，假设等于$k$的$dis(i,j)$有$cnt[k]$个，答案即是$\\sum cnt[k] \\times \\frac{1}{k+1}$ 这个$cnt[k]$可以$FFT$+点分治去做。 考虑求出过当前树的根节点的路径数，设生成函数$F(x)=\\sum _{i=0}^\\infty dep(i) x^i$。其中$dep(i)$代表深度为$i$的节点个数。 $F(x)^2=\\sum _{i=0}^\\infty (\\sum _{j=0}^i dep(j) dep(i-j)) x^i$，即是$\\sum _{i=0}^\\infty route(i) x^i$，其中$route(i)$代表路径个数。 这样算可能会有重复，于是按照点分治的套路需要容斥一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;const double PI=acos(-1.0);struct Complex&#123; double x,y;&#125;;inline Complex operator + (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline Complex operator - (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Complex operator * (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;&#125;Complex A[MAXN];int r[MAXN];inline void FFT(Complex *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; Complex Wn=Complex&#123;cos(2*PI/R),type*sin(2*PI/R)&#125;; for (register int j=0;j&lt;n;j+=R)&#123; Complex w=Complex&#123;1,0&#125;; for (register int k=0;k&lt;i;++k,w=w*Wn)&#123; Complex x=A[j+k],y=w*A[i+j+k]; A[j+k]=x+y,A[i+j+k]=x-y; &#125; &#125; &#125; if (type==-1)&#123; for (register int i=0;i&lt;n;++i) A[i].x/=(double)n; &#125;&#125;int d[MAXN],ret[MAXN],ans[MAXN],sz;inline void Mul(int f)&#123; int m=1,L=0; while (m&lt;=2*sz) m&lt;&lt;=1,L++; for (register int i=0;i&lt;=m;++i)&#123; r[i]=r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1)); &#125; FFT(A,m,1); for (register int i=0;i&lt;m;++i) A[i]=A[i]*A[i]; FFT(A,m,-1); for (register int i=0;i&lt;=sz*2;++i) ans[i]+=f*(int)(A[i].x+0.5);//深度可能变成两倍（恶臭） for (register int i=0;i&lt;=m;++i) A[i].x=0,A[i].y=0;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int dp[MAXN],max_dp[MAXN],vis[MAXN],tot,root;inline void InitDP(int u,int father)&#123; dp[u]=1,max_dp[u]=0; for (register int i=0;i&lt;(int)G[u].size();++i)&#123; int v=G[u][i]; if (v!=father&amp;&amp;!vis[v])&#123; InitDP(v,u); dp[u]+=dp[v]; max_dp[u]=max(max_dp[u],dp[v]); &#125; &#125; max_dp[u]=max(max_dp[u],tot-dp[u]); if (max_dp[root]&gt;max_dp[u]) root=u;&#125;int n;inline int GetRoot(int u,int s)&#123; tot=s,root=0; InitDP(u,0); return root;&#125;inline void InitDep(int u,int father,int dep)&#123; sz=max(sz,dep); A[dep].x++; for (register int i=0;i&lt;(int)G[u].size();++i)&#123; int v=G[u][i]; if (v!=father&amp;&amp;!vis[v])&#123; InitDep(v,u,dep+1); &#125; &#125;&#125;inline void Calc(int u,int f)&#123; sz=0; InitDep(u,0,f==-1?1:0); Mul(f);&#125;inline void dfs(int u)&#123; vis[u]=true; Calc(u,1); for (register int i=0;i&lt;(int)G[u].size();++i)&#123; int v=G[u][i]; if (!vis[v])&#123; Calc(v,-1); dfs(GetRoot(v,dp[v])); &#125; &#125;&#125;int main()&#123; n=read(); max_dp[0]=n; for (register int i=1;i&lt;n;++i)&#123; int u=read()+1,v=read()+1; AddEdge(u,v); AddEdge(v,u); &#125; dfs(GetRoot(1,n)); double ret=0; for (register int i=0;i&lt;n;++i)&#123; ret+=(double)ans[i]/(i+1); &#125; printf(\"%.4lf\\n\",ret);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"},{"name":"点分治","slug":"点分治","permalink":"https://gaisaiyuno.github.io/tags/点分治/"}]},{"title":"CF438E The Child and Binary Tree","slug":"CF438E-The-Child-and-Binary-Tree","date":"2019-10-09T14:12:43.000Z","updated":"2019-10-09T15:05:41.226Z","comments":true,"path":"archives/98d6ffc1.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/98d6ffc1.html","excerpt":"","text":"传送门 很好的一道生成函数+NTT题，做完之后可以加深对生成函数的理解。 建议先弄懂卡特兰数是怎么用生成函数推的，参考这篇博客（只用看推到$C(x)=\\frac{1\\pm\\sqrt{1-4x}}{2}$的部分） 考虑我们是怎么推导出$n$节点二叉树的种类数为卡特兰数的，考虑根节点两边连出的子树，他们的方案数为$c_{n-i-1} \\times c_{i}$。于是答案即是$\\sum_{j=0}^{i-1} c_{n-j-1} \\times c_j$ 这道题的递推式也非常像上面的： F_n=1+\\sum _{i=1}^n [i \\in c] \\sum _{j=0}^{k-i} F_jF_{i-j-k}（$1$代表左右子树是空的） $[]$中的值为真时，代表的数为$1$，否则为$0$。 如法炮制，我们构造生成函数$G(x)=\\sum _{i=0}^\\infty [i \\in c] x^i$。 设生成函数$F(x) =\\sum _{i=0}^\\infty cnt(i) x^i$，其中$cnt(i)$代表答案，即权值为$i$的神犇二叉树的总数。 于是递推式也是惊人的相似：$F=1+G \\times F \\times F$。$G$枚举了根节点的权值。 我们可以求出$F=\\frac{1 \\pm \\sqrt{1-4G}}{2G}$，其中需要舍弃$\\frac{1+\\sqrt{1-4G}}{2G}$，因为其不收敛。 得到$F=\\frac{1-\\sqrt{1-4G}}{2G}$，我们还要进一步分子有理化，得出$F=\\frac{2}{1+\\sqrt{1-4G}}$。 我们需要多项式开根和多项式求逆，不会的请转到这里 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MOD 998244353#define invG 332748118#define GG 3using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;int r[MAXN],C[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?GG:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;inline int get_inv(int x)&#123; return ksm(x,MOD-2);&#125;int m,L;inline void Init(int len)&#123; m=1,L=0; while (m&lt;2*len) m&lt;&lt;=1,L++; for (register int i=0;i&lt;m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void Inv(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=get_inv(A[0]); return ; &#125; Inv(A,B,(len+1)&gt;&gt;1); Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(C,m,1),NTT(B,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=(2ll-1ll*B[i]*C[i]%MOD+MOD)*B[i]%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD; for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int D[MAXN],inv2;inline void Sqrt(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=A[0]; return ; &#125; Sqrt(A,B,(len+1)&gt;&gt;1); for (register int i=0;i&lt;(len&lt;&lt;1);++i) D[i]=0; Inv(B,D,len); Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(B,m,1),NTT(C,m,1),NTT(D,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=1ll*inv2*(1ll*C[i]*D[i]%MOD+B[i])%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD; for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int G[MAXN],F[MAXN];int S1[MAXN],Ans1[MAXN];int S2[MAXN],Ans2[MAXN];int main()&#123; int n=read(),len=read(); inv2=ksm(2,MOD-2);//要初始化，要不然死的很惨（这个错误至少花了我1h） G[0]=1; for (register int i=1;i&lt;=n;++i)&#123; G[read()]++; &#125; S1[0]=1; for (register int i=1;i&lt;=len;++i)&#123; S1[i]=(-4ll*G[i]%MOD+MOD)%MOD; &#125; Sqrt(S1,Ans1,len+1); Ans1[0]=(Ans1[0]+1)%MOD; Inv(Ans1,Ans2,len+1); for (register int i=1;i&lt;=len;++i)&#123; printf(\"%d\\n\",2ll*Ans2[i]%MOD); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"NTT","slug":"NTT","permalink":"https://gaisaiyuno.github.io/tags/NTT/"}]},{"title":"NTT和运用","slug":"NTT和多项式经典运算","date":"2019-10-05T13:41:18.000Z","updated":"2019-10-06T14:49:02.862Z","comments":true,"path":"archives/dd621cde.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/dd621cde.html","excerpt":"","text":"NTT有时候，题目要求对一个大质数（特别是998244353之类的数）取模，就不能用FFT，而是用NTT。 NTT采用原根替代单位根，如果不了解原根，请参考这篇博客。 常见NTT质数表： $a\\times 2^b+1$ a b g 3 1 1 2 5 1 2 2 17 1 4 3 97 3 5 5 193 3 6 5 257 1 8 3 7681 15 9 17 12289 3 12 11 40961 5 13 3 65537 1 16 3 786433 3 18 10 5767169 11 19 3 7340033 7 20 3 23068673 11 21 3 104857601 25 22 3 采用NTT编写A*B problem。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MAXN 240005#define MOD 998244353#define invG 332748118 //G的逆元#define G 3using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;static int r[MAXN],a[MAXN],b[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?G:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;char s1[MAXN],s2[MAXN];int ans[MAXN];int main()&#123; int n=read(); scanf(\"%s%s\",s1+1,s2+1); for (register int i=1;i&lt;=n;++i) a[i-1]=s1[n-i+1]-'0'; for (register int i=1;i&lt;=n;++i) b[i-1]=s2[n-i+1]-'0'; int m=1,L=0; while (m&lt;=2*n) m&lt;&lt;=1,L++; for (register int i=0;i&lt;=m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125; NTT(a,m,1),NTT(b,m,1); for (register int i=0;i&lt;=m;++i) a[i]=(1ll*a[i]*b[i])%MOD; NTT(a,m,-1); int inv=ksm(m,MOD-2); for (register int i=0;i&lt;=m;++i)&#123; ans[i]+=(1ll*a[i]*inv)%MOD;//要乘上m的逆元 ans[i+1]+=ans[i]/10,ans[i]%=10; &#125; while (ans[m]==0) m--; for (register int i=m;i&gt;=0;--i) putchar(ans[i]+'0');&#125; 常见多项式运算这里才是重点部分。 多项式求逆传送门 给你一个多项式$A$，要你求出一个多项式$B$，满足$AB=1\\pmod {x^n}$ 系数对$998244353$取模。 首先，理解$\\pmod {x^n}$是为了去掉后面的部分。 下文中的除法全部代表向下取整。 我们假设求出了一个$B’$，满足$AB’=1\\pmod{x^{\\frac{n}{2}}}$，我们要求$B$，满足$AB=1 \\pmod{x^n}$。其实就是一个小范围的解推出大范围的解。 那么我们有后面的部分$B-B’=0 \\pmod{x^{\\frac{n}{2}}}$ 根据套路，我们要把后面的模数搞成$x^n$，于是两边平方。 $(B-B’)^2=0\\pmod{x^n}$ 拆开$B^2 -2BB’+B’^2=0 \\pmod{x^n}$ 两边同时乘$A$，发现可以消掉很多。 $AB^2-2ABB’+AB’^2=0\\pmod{x^n}$ 显然$AB=1$，可以消掉，变成： $B-2B’+AB’^2=0 \\pmod{x^n}$ 得出$B=2B’-AB’^2=B’(2-AB’) \\pmod{x^n}$ 于是可以根据这个公式从一个小的解推出大的。 别忘了边界条件$A[0]=B[0]^{-1}$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MOD 998244353#define invG 332748118#define G 3using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;int r[MAXN],C[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?G:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;inline int get_inv(int x)&#123; return ksm(x,MOD-2);&#125;int m,L;inline void Init(int len)&#123; m=1,L=0; while (m&lt;2*len) m&lt;&lt;=1,L++; for (register int i=0;i&lt;m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void Inv(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=get_inv(A[0]); return ; &#125; Inv(A,B,(len+1)&gt;&gt;1);//注意是向上取整 Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i];//只用前面一部分 for (register int i=len;i&lt;m;++i) C[i]=0; NTT(C,m,1),NTT(B,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=(2ll-1ll*B[i]*C[i]%MOD+MOD)*B[i]%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD;//推完之后B'-&gt;B for (register int i=len;i&lt;m;++i) B[i]=0;//多出来的部分要舍去&#125;int F[MAXN],Ans[MAXN];int main()&#123; int n=read(); for (register int i=0;i&lt;n;++i) F[i]=read(); Inv(F,Ans,n); for (register int i=0;i&lt;n;++i) printf(\"%d \",Ans[i]);&#125; 分治FFT传送门 此题我们使用生成函数做法。 构造生成函数$f(x)=\\sum_{i=0}^\\infty f[i] \\times x^i,g(x)=\\sum_{i=0}^\\infty g[i] \\times x^i$。 注意到$f(x)*g(x)=f(x)$。 欸这个有问题吧，这个应该无解才对啊！ 再看一眼题目，注意到$f(x) \\times g(x)$没有取到$x^0$ 怎么办呢？补上一个$1$即可。（也可以这么理解，卷积起来之后整体后移了一位，所以要补上） 得到式子$f(x)*g(x)+1=f(x)$ 解得$f(x)(1-g(x))=1$。 因为只用求前$n$项，转化为$f(x)(1-g(x))=1 \\pmod{x^n}$ 于是$f(x)=(1-g(x))^{-1} \\pmod{x^n}$。 对于生成函数做法，还有一个解释，暴力做法是每次分别求出$f[i]$，而生成函数做法是一起解出$f$。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MOD 998244353#define invG 332748118#define G 3using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;int r[MAXN],C[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?G:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;inline int get_inv(int x)&#123; return ksm(x,MOD-2);&#125;int m,L;inline void Init(int len)&#123; m=1,L=0; while (m&lt;2*len) m&lt;&lt;=1,L++; for (register int i=0;i&lt;m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void Inv(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=get_inv(A[0]); return ; &#125; Inv(A,B,(len+1)&gt;&gt;1); Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(C,m,1),NTT(B,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=(2ll-1ll*B[i]*C[i]%MOD+MOD)*B[i]%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD; for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int F[MAXN],Ans[MAXN];int main()&#123; int n=read(); F[0]=1; for (register int i=1;i&lt;n;++i) F[i]=(-read()+MOD)%MOD; Inv(F,Ans,n); for (register int i=0;i&lt;n;++i) printf(\"%d \",Ans[i]);&#125; 多项式开根传送门 给你一个$n-1$次多项式$A(x)$，求$B(x)$，使得$B(x)^2=A(x) \\pmod{x^n}$ 还是多项式求逆的套路。 考虑现在已经求出$B’(x)$，使得$B’(x) ^2 = A(x) \\pmod{x^{\\frac{n}{2}}}$。 求出一个$B(x)$使得$B(x)^2=A(x)\\pmod{x^{n}}$。 两边相减 $B(x)^2-B’(x)^2=0\\pmod{x^{\\frac{n}{2}}}$。 $(B(x)+B’(x))(B(x)-B’(x))=0 \\pmod{x^{\\frac{n}{2}}}$ 显然$B(x)+B’(x)!=0$。 有$B(x)-B’(x)=0\\pmod{x^\\frac{n}{2}}$。 还是老套路，两边平方。 $B(x)^2-2B(x)B’(x)+B’(x)^2=0\\pmod{x^n}$ 注意到$B(x)^2=A(x)$。 代入得： $A(x)-2B(x)B’(x)+B’(x)^2=0\\pmod{x^n}$。 所以$B(x)=\\frac{A(x)+B’(x)^2}{2B’(x)}=inv(2) *(A(x)B’^{-1}(x)+B’(x))$ 再次套用多项式求逆的模板即可。 边界$B[0]=\\sqrt {A[0]}=1$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MOD 998244353#define invG 332748118#define G 3using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;int r[MAXN],C[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?G:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125;&#125;inline int get_inv(int x)&#123; return ksm(x,MOD-2);&#125;int m,L;inline void Init(int len)&#123; m=1,L=0; while (m&lt;2*len) m&lt;&lt;=1,L++; for (register int i=0;i&lt;m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void Inv(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=get_inv(A[0]); return ; &#125; Inv(A,B,(len+1)&gt;&gt;1); Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(C,m,1),NTT(B,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=(2ll-1ll*B[i]*C[i]%MOD+MOD)*B[i]%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD; for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int D[MAXN],inv2;inline void Sqrt(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=A[0]; return ;//保证a_0=1 &#125; Sqrt(A,B,(len+1)&gt;&gt;1); for (register int i=0;i&lt;(len&lt;&lt;1);++i) D[i]=0; Inv(B,D,len);//得出B^-1(x) Init(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(B,m,1),NTT(C,m,1),NTT(D,m,1);//B:目标 C:A(x) D:B^-1(x) //注意要做三次NTT for (register int i=0;i&lt;m;++i)&#123; B[i]=1ll*inv2*(1ll*C[i]*D[i]%MOD+B[i])%MOD; &#125; NTT(B,m,-1); int inv=get_inv(m); for (register int i=0;i&lt;len;++i) B[i]=(1ll*B[i]*inv)%MOD; for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int F[MAXN],Ans[MAXN];int main()&#123; inv2=ksm(2,MOD-2); int n=read(); for (register int i=0;i&lt;n;++i) F[i]=read(); Sqrt(F,Ans,n); for (register int i=0;i&lt;n;++i) printf(\"%d \",Ans[i]);&#125; 例题例题1P4841 城市规划 此题即是数据加强版POJ1737，题解在此 这里不再讨论$dp$方程式，而是着重讨论优化方法。 我们有$F(i)=2^{C_i^2} - \\sum_{j=1}^{i-1} F(j) \\times 2^{C_{i-j}^2} \\times C_{i-1}^{j-1}$。 爆拆一波$C$，有$C_{i-1}^{j-1}=\\frac{(i-1)!}{(i-j)!(j-1)!}$。 两边同时除$(i-1)!$，得$\\frac{F(i)}{(i-1)!}=\\frac{2^{C_i^2}}{(i-1)!}-\\sum_{j=1}^{i-1} \\frac{F(j)}{(j-1)!} \\times \\frac {2^{C_{i-j}^2}}{(i-j)!} $（剩下的$(i-j)!$和$(j-1)!$刚好每人分一个） 设$A(x)=\\frac{F(i)}{(i-1)!},B(x)=\\frac{2^{C_{i}^2}}{(i-1)!},C(x)=\\frac{2^{C_{i}^2}}{i!}$ 推导这里发现有个致命的错误，$\\sum _{j=1}^{i-1}$无法解决，必须重新构造式子。 把后面一坨扔到前面去，左边部分变成$F(i)+\\sum_{j=1}^{i-1} F(j) \\times 2^{C_{i-j}^2} \\times C_{i-1}^{j-1}$。 注意到$j=i$时，$2^{C_{i-j}^2}=2^0=1$，$C_{i-1}^{j-1}=1$。 于是可以把他们两个合并起来，变成$\\sum_{j=1}^iF(j)\\times 2^{C_{i-j}^2} \\times C_{i-1}^{j-1}$。 等价于$A(x)B(x)=C(x)$。 于是得到$A(x)=C(x) B(x)^{-1}$。 可以使用多项式求逆解决。 别忘了$A(x)=\\frac {F(i)}{(i-1)!}$，所以答案要乘$(i-1)!$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define MAXN 2000005#define MOD 1004535809#define invG 334845270#define G 3#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(1ll*ans*b)%MOD; b=(1ll*b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;inline int get_inv(int x)&#123; return ksm(x,MOD-2);&#125;int r[MAXN],C[MAXN];inline void NTT(int *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=i&lt;&lt;1; int Gn=ksm(type==1?G:invG,(MOD-1)/R); for (register int j=0;j&lt;n;j+=R)&#123; int g=1; for (register int k=0;k&lt;i;++k,g=(1ll*g*Gn)%MOD)&#123; int x=A[j+k],y=(1ll*g*A[i+j+k])%MOD; A[j+k]=(x+y)%MOD,A[i+j+k]=(x-y+MOD)%MOD; &#125; &#125; &#125; if (type==1) return ; int inv=get_inv(n); for (register int i=0;i&lt;n;++i)&#123; A[i]=1ll*A[i]*inv%MOD; &#125;&#125;int m,L;inline void InitNTT(int len)&#123; m=1,L=0; while (m&lt;2*len) m&lt;&lt;=1,L++; for (register int i=0;i&lt;m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void Inv(int *A,int *B,int len)&#123; if (len==1)&#123; B[0]=get_inv(A[0]); return ; &#125; Inv(A,B,(len+1)&gt;&gt;1); InitNTT(len); for (register int i=0;i&lt;len;++i) C[i]=A[i]; for (register int i=len;i&lt;m;++i) C[i]=0; NTT(C,m,1),NTT(B,m,1); for (register int i=0;i&lt;m;++i)&#123; B[i]=((2ll-1ll*B[i]*C[i]%MOD+MOD)*B[i]%MOD+MOD)%MOD; &#125; NTT(B,m,-1); for (register int i=len;i&lt;m;++i) B[i]=0;&#125;int F[MAXN];int A[MAXN],B[MAXN],Ans[MAXN];int fac[MAXN],inv_fac[MAXN],n;int inv2=ksm(2,MOD-2);//F=A*B^-1inline int Calc(int x)&#123; return 1ll*x*(x-1)/2;//不能取模，要取也只能是MOD-1&#125;inline void Init()&#123; fac[0]=1; for (register int i=1;i&lt;=n;++i) fac[i]=1ll*fac[i-1]*i%MOD; for (register int i=0;i&lt;=n;++i) inv_fac[i]=ksm(fac[i],MOD-2);&#125;#undef intint main()&#123;#define int long long n=read(); Init(); for (register int i=1;i&lt;=n;++i)&#123; A[i]=1ll*ksm(2,Calc(i))*inv_fac[i-1]%MOD; &#125; for (register int i=0;i&lt;=n;++i)&#123; B[i]=1ll*ksm(2,Calc(i))*inv_fac[i]%MOD; &#125; InitNTT(n); Inv(B,Ans,m); InitNTT(n); NTT(A,m,1);NTT(Ans,m,1); for (register int i=0;i&lt;m;++i) A[i]=1ll*A[i]*Ans[i]%MOD; NTT(A,m,-1); printf(\"%lld\\n\",1ll*A[n]*fac[n-1]%MOD);&#125;","categories":[],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://gaisaiyuno.github.io/tags/NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://gaisaiyuno.github.io/tags/多项式/"}]},{"title":"生成函数详解","slug":"生成函数详解","date":"2019-10-03T09:19:26.000Z","updated":"2019-10-06T14:48:39.494Z","comments":true,"path":"archives/3da1ee6d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3da1ee6d.html","excerpt":"","text":"这是一篇即将咕咕很久的学习笔记。 定义$f(x)=a_0+a_1x+a_2x^2+a_3x^3…$，$f(x)$就是序列$a_0,a_1,a_2…a_n$的生成函数 01背包问题给你$w_1,w_2,w_3,…w_n$，每个数只有取和不取的两种状态，求凑成$W$的种类数。 构造$f(x)=\\prod_{i=1}^n (x^0+x^{w_i})$，于是答案就是$x^W$的系数。 完全背包问题给你$w_1,w_2,w_3,…,w_n$，每个数可以取任意多种，求凑成$W$的种类数。 构造$f(x)=\\prod_{i=1}^n (\\sum _{j=0} ^\\infty x^{w_i\\times j})$，答案就是$x^W$的系数。 $\\sum _{j=0} ^\\infty x^{w_i \\times j}$是无穷的，如何算出？ 令$p=x^w_i$，那么有$\\sum _{j=0} ^\\infty x^{w_i \\times j}=\\sum _{j=0} ^\\infty p^j$。 注意到$\\sum _{j=0}^\\infty p^j=\\frac{1-p^\\infty}{1-p}$，当$x \\in (-1,1)$时，$p\\in (-1,1)$，所以$p^\\infty \\to 0$，于是原式就是$\\frac{1}{1-p}$，即$\\frac{1}{1-x_i^w}$。 两种生成函数前面介绍了第一种生成函数：$\\sum _{j=0} ^{\\infty} x^j =\\frac{1}{1-x}(x \\in (-1,1))$ 现在介绍第二种中的一个特殊情况：$\\sum _{j=0}^{\\infty} (j+1) \\times x^j=?$ 我们把两个$\\sum _{j=0} ^{\\infty} x^j$相乘，凑成$j$的有$(0,j),(1,j-1)…(j,0)$这么多种，共$j+1$种选法。 于是$\\sum _{j=0}^\\infty (j+1) \\times x^j=\\frac{1}{(x-1)^2}$ 推广一下： $\\frac{1}{(x-1)^k}$是什么？ 问题转化为凑出$k$个数，使他们的和为$j$的方案数。 插板法即可，答案为$C_{j+k-1}^{k-1}$ 于是$\\frac{1}{(x-1)^k}=\\sum_{j=0}^\\infty C_{j+k-1}^{k-1} x^j$ 注意到$C_{j+k-1}^{k-1}=C_{j+k-1}^j$，这个形式在下面的广义二项式定理里面会用到。 于是我们总结出以下规律： $\\frac{1}{1-x^k}=\\sum _{j=0}^\\infty x^{jk}$ $\\frac{1}{(1-x)^k}=\\sum_{j=0}^\\infty C_{j+k-1}^{k-1} x^j$ 还有一个有限项数的求和公式： $\\frac{1-x^{k+1}}{1-x}=\\sum _{j=0}^k x^k$ 广义二项式定理注意到$\\frac{1}{(1-x)^k}=(1-x)^{-k}$。 我们不禁有个大胆的想法，如果$k$可以取任何实数，那么我们就可以表示出$\\sqrt{1-x},\\sqrt[3]{1-x}$等等的生成函数。 $(1+x)^\\alpha = \\sum_{j=0}^\\infty C_{j}^{\\alpha} x^j$。 定义： $C_{\\alpha}^{k}=\\begin{cases} \\frac{\\alpha(\\alpha-1)(\\alpha-2) \\dots (\\alpha-k+1)}{k!},k&gt;1 \\ 1,k=0 \\ 0,k&lt;0 \\end{cases}(k \\in \\mathbb{Z},\\alpha \\in \\mathbb{R}) \\tag{1.1.1}$ 来自巨佬ypy的博客。 生成函数的应用例题1BZOJ 3028 承德汉堡：$f(x)=1+x^2+x^4+x^6…=\\frac{1}{1-x^2}$ 可乐：$f(x)=1+x$ 鸡腿：$f(x)=1+x+x^2=\\frac{1-x^3}{1-x}$ 蜜桃多：$f(x)=\\sum_{j=0}^\\infty x^j - (1+x^2+x^4+…)=\\frac{1}{1-x}-\\frac{1}{1-x^2}=\\frac{x}{1-x^2}$ 鸡块：$f(x)=\\frac{1}{1-x^4}$ 包子：$f(x)=1+x+x^2+x^3=\\frac{1-x^4}{1-x}$ 土豆片炒肉：$f(x)=1+x$ 面包：$f(x)=\\frac{1}{1-x^3}$ 乘起来然后大力化简一波，化成了$\\frac{x}{(1-x)^4}$ 套进第二个式子： $\\frac{x}{(1-x)^4}=\\sum_{j=0}^\\infty C_{j+3}^{3}x_{j+1}=\\sum_{j=1}^\\infty C_{j+2}^{3}x_{j}$ 于是我们所求的就是$C_{j+2}^3$。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MOD 10007using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=((x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'))%MOD; ch=getchar(); &#125; return x*f;&#125;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(ans*b)%MOD; b=(b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; int n=read(); printf(\"%d\\n\",(n+2)*(n+1)%MOD*(n)%MOD*ksm(6,MOD-2)%MOD);&#125; 例题2P2000 拯救世界 本质和上面一题是一样的： kkksc03： 金：$\\frac{1}{1-x^6}$ 木：$\\frac{1-x^{10}}{1-x}$ 水：$\\frac{1-x^6}{1-x}$ 火：$\\frac{1}{1-x^4}$ 土：$\\frac{1-x^8}{1-x}$ lzn： 金：$\\frac{1}{1-x^2}$ 木：$1+x$ 水：$\\frac{1}{1-x^8}$ 火：$\\frac{1}{1-x^{10}}$ 土：$\\frac{1-x^4}{1-x}$大力乘起来，算出$\\frac{1}{1-x^5}$ 答案即是$C_{n+5-1}^{5-1}=C_{n+4}^4$。 只写了python版本： 12n=(int)(input())print((n+1)*(n+2)*(n+3)*(n+4)//24) 例题3试用生成函数推导斐波那契数列通项公式。 斐波那契数列：$fib_1=1,fib_2=1,fib_i=fib_{i-1}+fib_{i-2} (i\\ge 3)$ 构造$f(x)=\\sum _{j=1}^\\infty fib_j x^j$ 所以$f(x) \\times x=\\sum_{j=2}^\\infty fib_{j-1}x^j$ $f(x)-f(x)\\times x=fib_1x+\\sum_{j=2}^{\\infty}fib_{j-2}x^j=x+x^2\\times f(x)$ 所以$f(x)=\\frac{x}{1-x-x^2}$ 令$\\phi =\\frac{1+\\sqrt{5}}{2},\\phi’=\\frac{1-\\sqrt{5}}{2}$。 分解：$\\frac{x}{1-x-x^2}=\\frac{x}{(1-\\phi’x)(1-\\phi x)}=\\frac{1}{\\sqrt{5}}(\\frac{1}{1-\\phi x} - \\frac{1}{1-\\phi’ x})$ 根据公式$\\frac{1}{1-x}=\\sum _{j=0}^\\infty x^{j}$，前面一项化为$(\\phi)^n$后面一项化成$(\\phi’)^n$。 于是我们得到$fib_n=\\frac{1}{\\sqrt{5}}(\\phi ^n-\\phi’^n)$。 即$fib_n=-\\frac{1}{\\sqrt 5}(\\frac{1-\\sqrt 5}{2})^2+\\frac{1}{\\sqrt 5}(\\frac{1+\\sqrt 5}{2})^2$。 例题4试用生成函数推导卡特兰数通项公式。 卡特兰数： $c’_0=1$ $c’_1=1$ $c’_n=\\sum_{i=1}^{n-1}c’_ic’_{n-i-1}$ 为了方便，记$c_i=c’_{i-1}$，有$c’_i=c_{i+1}$。 所以有$c_n=c’_{n-1}=\\sum_{i=1}^{n-2}c’_ic’_{n-i-2}=\\sum_{i=1}^{n-2}c_{i+1}c_{n-i-1}=\\sum_{i=2}^{n-1}c_ic_{n-i} $ 记$C(x)=\\sum _{i=0}^\\infty c_ix^i$ 有$C(x)-C(x)^2=C_1 \\times x^1=x$。 于是$C(x)^2-C(x)+x=0$ 得到$C(x)=\\frac{1\\pm\\sqrt{1-4x}}{2}$ 舍去$\\frac{1+\\sqrt{1-4x}}{2}$ 所以$C(x)=\\frac{1}{2x}[1-(1-4x)^{0.5}]$ 先化简$(1-4x)^{0.5}$ 由$(1+x)^\\alpha = \\sum_{j=0}^\\infty C_{j}^{\\alpha} x^j$ 有$(1-4x)^{0.5}=\\sum_{j=0}^\\infty C_{0.5}^{j}(-4x)^j$。 注意到这里$C_{0.5}^0(-4x)^0=1$，把它放到前面去。 拆一波$C_{0.5}^{j}=\\frac{\\prod_{k=0}^{j-1} (0.5-k)}{j!}$ 放回去：$\\sum_{j=1}^\\infty \\frac{\\prod_{k=0}^{j-1}(0.5-k)}{j!} \\times (-4x)^j$ 右边除掉一个$(-2)^j$，左边乘$(-2)^j$ 变成：$\\sum_{j=1}^\\infty \\frac{\\prod_{k=0}^{j-1}(2k-1)}{j!} \\times (2x)^j$ 注意到$\\sum_{k=0}^{j-1}=-1\\times (1 \\times 3 \\times 5 \\times … \\times (2j-3))$，这里我们把那个$-1$放到前面抵消掉减号，下面不再说明。 这时可以发现$(1 \\times 3 \\times 5 \\times … \\times (2j-3))= \\frac{(2j-2)!}{2^{j-1}(j-1)!}$ 于是我们可以得到$(1-4x)^{0.5}=1-\\sum_{j=1}^\\infty 2^j x^j \\times \\frac{(2j-2)!}{2^{j-1}(j-1)!} \\times \\frac{1}{j!}$ 等于$1-\\sum_{j=1}^\\infty x^j \\times 2\\frac{(2j-2)!}{(j-1)!j!}$ 带回原式$C(x)=\\frac{1}{2x}[1-(1-\\sum_{j=0}^\\infty x^j \\times 2\\frac{(2j-2)!}{(j-1)!j!})]$ 等于$\\sum_{j=1}^\\infty x^{j-1} \\times \\frac{(2j-2)!}{(j-1)!j!}$。 注意到$x$的次数不能是$j-1$，于是把$k=j-1$带入，变成$\\sum _{k=0}^\\infty x^k \\times \\frac{(2k)!}{k!(k+1)!}$ 于是得到公式$c_n=\\frac{(2n)!}{n!(n+1)!}$","categories":[],"tags":[{"name":"生成函数","slug":"生成函数","permalink":"https://gaisaiyuno.github.io/tags/生成函数/"}]},{"title":"蓝精灵的请求","slug":"蓝精灵的请求","date":"2019-10-03T08:54:34.000Z","updated":"2019-10-03T09:10:25.318Z","comments":true,"path":"archives/d28a3a50.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d28a3a50.html","excerpt":"","text":"注意到题目实际上是把整个图分成了两个团（团是一个点的集合，其中任意两点之间都有边相连）。 根据我们以前的经验，团什么的都可以随机化搞出来，如P4212 外太空旅行 注意到我们随机化不能写成这个样子： 1234567891011121314bool Check返回能不能构成团for (register int k=1;k&lt;=10000;++k)&#123; random_shuffle(a+1,a+1+n); //......... for (register int i=1;i&lt;=n;++i)&#123; //.......... if (Check(a[1]...a[i]))&#123; if (Check(a[i+1]...a[n])) ans=min(ans,...); &#125; else&#123; break;//后面不能构成团 &#125; &#125;&#125; 而是写成： 12345678910111213bool Check返回能不能构成团for (register int k=1;k&lt;=10000;++k)&#123; random_shuffle(a+1,a+1+n); s=&#123;&#125;; //......... for (register int i=1;i&lt;=n;++i)&#123; //.......... if (Check(s+a[i]))&#123; s.insert(a[i]); if (Check(a[1]...a[n]除s之外的元素)) ans=min(ans,...); &#125; &#125;&#125; 总的代码，发现只要随机化33次就可以AC。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define MAXN 705using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int G[MAXN][MAXN];int a[MAXN],stk[MAXN],top,vis[MAXN];inline int Check(int x)&#123; for (register int i=1;i&lt;=top;++i)&#123; if (G[stk[i]][x]==false)&#123; return false; &#125; &#125; return true;&#125;int stk1[MAXN],top1,n,m;inline int CheckElse()&#123; top1=0; for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i]) stk1[++top1]=i; &#125; for (register int i=1;i&lt;=top1;++i)&#123; for (register int j=i+1;j&lt;=top1;++j)&#123; if (G[stk1[i]][stk1[j]]==false) return false; &#125; &#125; return true;&#125;inline int CalcEdge(int x)&#123; return x*(x-1)/2;&#125;inline int Best()&#123; return CalcEdge(n/2)+CalcEdge(n-n/2);&#125;int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); G[u][v]=G[v][u]=true; &#125; for (register int i=1;i&lt;=n;++i)&#123; a[i]=i; &#125; int ans=0x7fffffff; int best=Best(); for (register int t=1;t&lt;=33;++t)&#123; random_shuffle(a+1,a+1+n); top=0; memset(vis,0,sizeof(vis)); for (register int j=1;j&lt;=n;++j)&#123; if (Check(a[j])) stk[++top]=a[j],vis[a[j]]=true; int temp=CalcEdge(top)+CalcEdge(n-top); if (temp&lt;ans)&#123; if (CheckElse()) ans=temp; &#125; &#125; if (ans==best) break; &#125; printf(\"%d\\n\",ans==0x7fffffff?-1:ans);&#125; 数据生成器，$m$设成244550左右就可以使程序WA： 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;pair&lt;int,int&gt; &gt;Edge;int main()&#123; int n=700,m=244550; freopen(\"data.in\",\"w\",stdout); for (register int i=1;i&lt;=n;++i)&#123; for (register int j=i+1;j&lt;=n;++j)&#123; Edge.push_back(make_pair(i,j)); &#125; &#125; random_shuffle(Edge.begin(),Edge.end()); printf(\"%d %d\\n\",n,m); for (register int i=0;i&lt;m;++i)&#123; printf(\"%d %d\\n\",Edge[i].first,Edge[i].second); &#125;&#125;","categories":[],"tags":[{"name":"随机化","slug":"随机化","permalink":"https://gaisaiyuno.github.io/tags/随机化/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"}]},{"title":"可持久化trie学习笔记","slug":"可持久化trie学习笔记","date":"2019-10-03T06:11:40.000Z","updated":"2019-10-03T08:22:31.648Z","comments":true,"path":"archives/af85b329.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/af85b329.html","excerpt":"","text":"可持久化trie是一种和最大异或和关系非常紧密的算法。 例题1给你一个数列$\\{a_i\\}$，每次询问给你$l,r,x$，要你计算$\\max\\{ a[i]\\oplus x\\}(i \\in [l,r]) $ 如何考虑？ 从高位往低位贪心！ 举个例子： $a[i]:100,110,101,010$ $x=010$ 首先，发现$a[i]$的第最高位必须是$1$，即使$a[i] \\oplus x$最大的$a[i]$只可能是$100,110$中的一个。 再看第二位，如果第二位是$1$的话，$1\\oplus1=0$，不是最大的，$a[i]$就确定为$100$。 于是我们可以设计出如下算法： 12345678910111213procedure get_max(l,r,x)&#123; s=&#123;a[l],a[l+1],a[l+2]...a[r]&#125;; for (k in [log2(max(a[i])),1])&#123; if (x第k位是1)&#123; if (s里面有数第k位是0) s=&gt;s中所有第k位为0的数 else s不变 &#125; else &#123; if (s里面有数第k位是1) s=&gt;s中所有第k位为1的数 else s不变 &#125; &#125;&#125; 发现此算法效率极慢，甚至比不上暴力。 如何优化？ 发现一个重要的性质，每次操作之后，$s$中所有数的二进制表示中，$[\\log_2(\\max(a[i])),k]$的位上面都是一样的。 这让我们想到了trie树。 考虑用trie维护$s$，如何马上求出${a[l],a[l+1],a[l+2]…a[r]}$呢？ 我们需要可持久化，实现时类似于主席树前缀和做差即可。 1Print(Query(31,rt[l-1],rt[r],x),'\\n'); 如何快速查询$s$中有没有二进制$k$位上面是$0/1$的数，只要查询这个子树的大小即可。 1234567891011int Query(int index,int l,int r,int x)&#123; if (index&lt;0) return 0; bool pos=(x&gt;&gt;index)&amp;1; int k=tree[ch(r,pos^1)].sz-tree[ch(l,pos^1)].sz;//子树大小 if (k&gt;0)&#123;//有pos^1子树，根据贪心，必须往那里去 return Query(index-1,ch(l,pos^1),ch(r,pos^1),x)+(1&lt;&lt;index); &#125; else &#123; return Query(index-1,ch(l,pos),ch(r,pos),x); &#125;&#125; 插入也非常简单：1234567891011void Insert(int &amp;i,int pre,int index,int x)&#123; tree[i=++tot].sz=tree[pre].sz;//新建节点 if (index&lt;0)&#123; tree[i].sz++; return ; &#125; bool pos=(x&gt;&gt;index)&amp;1; ch(i,pos^1)=ch(pre,pos^1);//继承子节点 Insert(ch(i,pos),ch(pre,pos),index-1,x);//继续插入 tree[i].sz=tree[ch(i,0)].sz+tree[ch(i,1)].sz;//更新子树大小&#125; 总的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void print(int x)&#123; if (x&gt;9) print(x/10); putchar('0'+x%10);&#125;inline void Print(int x,char ch)&#123; if (x==0) return putchar('0'),void(); if (x&lt;0) x=-x,putchar('-'); print(x); putchar(ch);&#125;int rt[MAXN];namespace Trie&#123; struct node&#123; int ch[2]; int sz; &#125;tree[MAXN&lt;&lt;5]; #define ch(i,p) tree[i].ch[p] int tot; void Insert(int &amp;i,int pre,int index,int x)&#123; tree[i=++tot].sz=tree[pre].sz; if (index&lt;0)&#123; tree[i].sz++; return ; &#125; bool pos=(x&gt;&gt;index)&amp;1; ch(i,pos^1)=ch(pre,pos^1); Insert(ch(i,pos),ch(pre,pos),index-1,x); tree[i].sz=tree[ch(i,0)].sz+tree[ch(i,1)].sz; &#125; int Query(int index,int l,int r,int x)&#123; if (index&lt;0) return 0; bool pos=(x&gt;&gt;index)&amp;1; int k=tree[ch(r,pos^1)].sz-tree[ch(l,pos^1)].sz; if (k&gt;0)&#123; return Query(index-1,ch(l,pos^1),ch(r,pos^1),x)+(1&lt;&lt;index); &#125; else &#123; return Query(index-1,ch(l,pos),ch(r,pos),x); &#125; &#125;&#125;using namespace Trie;int a[MAXN];int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for (register int i=1;i&lt;=n;++i)&#123; Insert(rt[i],rt[i-1],31,a[i]); &#125; for (register int i=1;i&lt;=m;++i)&#123; int x=read(),l=read()+1,r=read()+1; Print(Query(31,rt[l-1],rt[r],x),'\\n'); &#125;&#125; 例题2P4735 最大异或和 A x：添加操作，表示在序列末尾添加一个数$x$，序列的长度变为$N+1$。 Q l r x：询问操作，你需要找到一个位置$p$，满足$l \\le p \\le r$，使得： $a[p] \\oplus a[p+1] \\oplus … \\oplus a[N] \\oplus x$最大，输出最大是多少。 令$sum[p]=a[1] \\oplus a[2] \\oplus … \\oplus a[p]$。 考虑转换$a[p] \\oplus a[p+1] \\oplus … \\oplus a[N]$为$sum[N] \\oplus sum[p-1]$。 问题变为找到一个$sum[p-1],(l \\le p \\le r)$，使得$(sum[N] \\oplus x) \\oplus sum[p-1]$最大。 于是这个问题也可以可持久化trie解决。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void print(int x)&#123; if (x&gt;9) print(x/10); putchar('0'+x%10);&#125;inline void Print(int x,char ch)&#123; if (x==0) return putchar('0'),putchar(ch),void(); if (x&lt;0) x=-x,putchar('-'); print(x); putchar(ch);&#125;int rt[MAXN];namespace Trie&#123; struct node&#123; int ch[2]; int sz; &#125;tree[MAXN&lt;&lt;5]; #define ch(i,p) tree[i].ch[p] int tot; void Insert(int &amp;i,int pre,int index,int x)&#123; tree[i=++tot].sz=tree[pre].sz; if (index&lt;0)&#123; tree[i].sz++; return ; &#125; bool pos=(x&gt;&gt;index)&amp;1; ch(i,pos^1)=ch(pre,pos^1); Insert(ch(i,pos),ch(pre,pos),index-1,x); tree[i].sz=tree[ch(i,0)].sz+tree[ch(i,1)].sz; &#125; int Query(int index,int l,int r,int x)&#123; if (index&lt;0) return 0; bool pos=(x&gt;&gt;index)&amp;1; int k=tree[ch(r,pos^1)].sz-tree[ch(l,pos^1)].sz; if (k&gt;0) return Query(index-1,ch(l,pos^1),ch(r,pos^1),x)+(1&lt;&lt;index); else return Query(index-1,ch(l,pos),ch(r,pos),x); &#125;&#125;using namespace Trie;inline char gc()&#123; char ch=getchar(); while (ch!='A'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;int a[MAXN];int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read()^a[i-1]; &#125; for (register int i=1;i&lt;=n;++i)&#123; Insert(rt[i],rt[i-1],31,a[i]); &#125; for (register int i=1;i&lt;=m;++i)&#123; char ch=gc(); if (ch=='A')&#123; int x=read(); a[n+1]=x^a[n]; Insert(rt[n+1],rt[n],31,a[n+1]); ++n; &#125; else &#123; int l=read()-1,r=read()-1,x=read(); if (l==0&amp;&amp;l==r) Print(a[n]^x,'\\n');//特判qwq else &#123; if (!l) Print(Query(31,0,rt[r],x^a[n]),'\\n');//这里也要 else Print(Query(31,rt[l-1],rt[r],x^a[n]),'\\n'); &#125; &#125; &#125;&#125; 例题3P4098 [HEOI2013]ALO 枚举次小值$a[i]$，这题的重点是找到$minl,maxr$，使得$a[i]$是$[minl,maxr]$中的次小值。 这个可以使用set或者平衡树或主席树之类的实现，也可以用双向链表$O(n)$实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void print(int x)&#123; if (x&gt;9) print(x/10); putchar('0'+x%10);&#125;inline void Print(int x,char ch)&#123; if (x==0) return putchar('0'),putchar(ch),void(); if (x&lt;0) x=-x,putchar('-'); print(x); putchar(ch);&#125;int rt[MAXN];namespace Trie&#123; struct node&#123; int ch[2]; int sz; &#125;tree[MAXN&lt;&lt;5]; #define ch(i,p) tree[i].ch[p] int tot; void Insert(int &amp;i,int pre,int index,int x)&#123; tree[i=++tot].sz=tree[pre].sz; if (index&lt;0)&#123; tree[i].sz++; return ; &#125; bool pos=(x&gt;&gt;index)&amp;1; ch(i,pos^1)=ch(pre,pos^1); Insert(ch(i,pos),ch(pre,pos),index-1,x); tree[i].sz=tree[ch(i,0)].sz+tree[ch(i,1)].sz; &#125; int Query(int index,int l,int r,int x)&#123; if (index&lt;0) return 0; bool pos=(x&gt;&gt;index)&amp;1; int k=tree[ch(r,pos^1)].sz-tree[ch(l,pos^1)].sz; if (k&gt;0) return Query(index-1,ch(l,pos^1),ch(r,pos^1),x)+(1&lt;&lt;index); else return Query(index-1,ch(l,pos),ch(r,pos),x); &#125;&#125;using namespace Trie;inline char gc()&#123; char ch=getchar(); while (ch!='A'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;int a[MAXN],id[MAXN],pre[MAXN],nex[MAXN];inline int cmp(int i,int j)&#123; return a[i]&lt;a[j];&#125;int L[MAXN],R[MAXN];int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(),pre[i]=i-1,nex[i]=i+1; &#125; pre[0]=1,nex[n]=n; for (register int i=1;i&lt;=n;++i)&#123; Insert(rt[i],rt[i-1],31,a[i]); &#125; for (register int i=1;i&lt;=n;++i)&#123; id[i]=i; &#125; sort(id+1,id+1+n,cmp); for (register int i=1;i&lt;=n;++i)&#123; nex[pre[id[i]]]=nex[id[i]]; pre[nex[id[i]]]=pre[id[i]]; L[id[i]]=pre[pre[id[i]]]; R[id[i]]=nex[nex[id[i]]]; &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; ans=max(ans,Query(31,rt[L[i]],rt[R[i]-1],a[i])); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"},{"name":"trie","slug":"trie","permalink":"https://gaisaiyuno.github.io/tags/trie/"}]},{"title":"莫队学习笔记","slug":"莫队学习笔记","date":"2019-10-01T13:06:47.000Z","updated":"2019-10-03T05:59:16.797Z","comments":true,"path":"archives/3be44324.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3be44324.html","excerpt":"","text":"其实这是一篇咕了很久的学习笔记。 本人比较喜欢莫队这种根号算法。 以上是博主瞎扯淡，下面正文开始。 莫队基本原理何为莫队，莫队可不是一个队列，他是以集训队大佬莫涛为名的暴力算法（又称对询问分块）。 其实思路比较简单，我们现在得到了查询$[l_1,r_1]$的答案，想要通过比较少的代价获得$[l_2,r_2]$的答案，怎么办。 一个很简单的思路，就是先把$l_1$移动到$l_2$的位置，同时从当前状态减去$[l_1,l_2-1]$对应的元素，再把$r_1$移动到$r_2$的位置，从当前状态加上$[r_1+1,r_2]$对应的元素。 可能你会比较懵逼，什么叫做加上，减去？ 以区间询问不同的数的个数为例，加上这个数的同时更新$cnt[]$数组，还要更新答案，如下： 1234inline void Add(int x)&#123; ++cnt[x]; if (cnt[x]==1) ans++;//这个数是最新出现的&#125; 减去也是同理 1234inline void Del(int x)&#123; --cnt[x]; if (cnt[x]==0) ans--;//这个数被减没了&#125; 核心代码： 1234while (l&lt;Q[i].l) Del(seq[l++]);while (l&gt;Q[i].l) Add(seq[--l]);while (r&lt;Q[i].r) Add(seq[++r]);while (r&gt;Q[i].r) Del(seq[r--]); 好了，貌似这样更新答案，能少很多运算过程。 $No!$，考虑这样的询问： $l_1=1,r_1=1$ $l_2=n,r_2=n$ $l_3=1,r_3=1$ …… 显然每次询问是$O(n)$的，加上询问变成$O(nm)$的，gg。 这时，莫涛大佬不禁说：“对询问离线，然后排序！” 经过大佬的指点，很多人都可以口胡出一个貌似时间复杂度正确的解法： 对询问离线，然后按照左端点为第一关键字，右端点为第二关键字排序！ 代码如下： 1234inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; if (A.l==B.l) return A.r&lt;B.r; else return A.l&lt;B.l;&#125; 然鹅，这个是错误的。 考虑这样的询问： $l_1=1,r_1=1$ $l_2=2,r_2=n$ $l_3=3,r_3=1$ $l_4=4,r_4=n$ …… 每次询问还是$O(n)$。 这下怎么搞？ 莫涛大佬有一个非常毒瘤的$idea$。 考虑分块，大小为$\\sqrt n$， 对询问离线，然后按照左端点所在块编号为第一关键字排序，右端点为第二关键字排序。 代码如下： 1234inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; if (id[A.l]==id[B.l]) return A.r&lt;B.r; else return id[A.l]&lt;id[B.l];&#125; 这样为什么是对的呢？ 假设我们整体来看，会发现只要左端点每次移动的距离不会超过$2 \\times \\sqrt n$（可能是在同一个块里面移动，也有可能是从一个块跳到相邻的块），然后右端点整个询问全部加起来也不会移动超过$n\\sqrt n$次（因为左端点在同一个块的时候，右端点移动的距离不会超过$n$，而且只有$\\sqrt n$个块），均摊$\\sqrt n$。 于是发现询问的平均时间复杂度为$O(\\sqrt n)$。 妙不妙？ 优化方法同时，我还要介绍莫队的优化方法（奇偶性排序）。 考虑我们左端点从一个块跳到右边相邻的块的过程，在左端点在前一个块的时候，我们的右端点已经到达了一个编号较大的位置，但是左端点一跳到相邻的块，右端点就要跳到一个编号较小的位置，这样虽然不影响时间复杂度，但是总觉得有些浪费，于是我们想，相邻的块和前一个块右端点按照不同的方式排序（比如前一个块从小到大，后一个块从大到小），常数就可以减少。 代码如下： 1234567inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; if (id[A.l]==id[B.l])&#123; if (id[A.l]&amp;1) return A.r&lt;B.r; else return A.r&gt;B.r; &#125; else return id[A.l]&lt;id[B.l];&#125; 按照这种方法排序，听说常数能够减少很多。 下面进入快乐的刷题时间： 普通莫队先从简单的普通莫队练起。 （HH的项链卡莫队，所以没有放进例题） 例题1P3901 数列找不同 只要区间出现次数超过$2$的数就可以搞定了（代码中是$cnt2$）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Query&#123; int l,r,id;&#125;q[MAXN];int pos[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));//奇偶性排序的压行写法&#125;int a[MAXN],cnt[MAXN],cnt2;inline void Add(int x)&#123; ++cnt[x]; if (cnt[x]==2) cnt2++;&#125;inline void Del(int x)&#123; --cnt[x]; if (cnt[x]==1) cnt2--;&#125;int Ans[MAXN];int main()&#123; int n=read(),m=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i]=Query&#123;read(),read(),i&#125;; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;Q[i].l) Del(seq[l++]); while (l&gt;Q[i].l) Add(seq[--l]); while (r&lt;Q[i].r) Add(seq[++r]); while (r&gt;Q[i].r) Del(seq[r--]); Ans[q[i].id]=(cnt2==0); &#125; for (register int i=1;i&lt;=m;++i)&#123; puts(Ans[i]?\"Yes\":\"No\"); &#125;&#125; 例题2P1494 [国家集训队]小Z的袜子 设$[L,R]$所有袜子构成的集合是$S$，设$f(x)=x \\times (x-1)/2$，显然$ans=\\sum _{x \\in S} (f(cnt(x))) / f(L-R+1) $。 注意到可以消掉那个$2$，并且拆开$x \\times (x-1)$，变成$(\\sum_{x \\in S}(cnt(x)^2)-\\sum_{x \\in S} cnt(x)) / (R-L+1) \\times (R-L)$ 注意到$\\sum _{x \\in S} cnt(x) = R-L+1$。 于是我们要求的就是$\\sum_{x \\in S}(cnt(x)^2)$。 可以大力算出来。 （好久以前的代码，码风请原谅） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAXN 50005#define int long longusing namespace std;int num[MAXN];struct fen&#123; int a,b; inline void yue()&#123; int g=__gcd(a,b); a/=g,b/=g; &#125;&#125;ans[MAXN];int pos[MAXN];struct query&#123; int l,r,id; inline int len()&#123; return r-l+1; &#125;&#125;querys[MAXN];bool operator &lt; (const query &amp;a,const query &amp;b)&#123; if (pos[a.l]==pos[b.l])&#123; return a.r&lt;b.r; &#125; else&#123; return a.l&lt;b.l; &#125;&#125;int cnt[MAXN];inline void Change(int &amp;curans,const int &amp;id,const int &amp;val)&#123; curans-=cnt[num[id]]*cnt[num[id]]; cnt[num[id]]+=val; curans+=cnt[num[id]]*cnt[num[id]];&#125;#undef intint main()&#123;#define int long long int n,m; scanf(\"%lld%lld\",&amp;n,&amp;m); int sz=sqrt(n); for (int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/sz+1; &#125; for (int i=1;i&lt;=n;++i)&#123; scanf(\"%lld\",&amp;num[i]); &#125; for (int i=1;i&lt;=m;++i)&#123; scanf(\"%d%d\",&amp;querys[i].l,&amp;querys[i].r); querys[i].id=i; &#125; sort(querys+1,querys+1+m); int l=1,r=0; int curans=0; for (int i=1;i&lt;=m;++i)&#123; while (r&lt;querys[i].r) Change(curans,++r,1); while (r&gt;querys[i].r) Change(curans,r--,-1); while (l&gt;querys[i].l) Change(curans,--l,1); while (l&lt;querys[i].l) Change(curans,++l,-1); if (querys[i].l==querys[i].r)&#123; ans[querys[i].id].a=0,ans[querys[i].id].b=1; &#125; else &#123; ans[querys[i].id].a=curans-(querys[i].len()); ans[querys[i].id].b=querys[i].len()*(querys[i].len()-1); ans[querys[i].id].yue(); &#125; &#125; for (int i=1;i&lt;=m;++i)&#123; printf(\"%lld/%lld\\n\",ans[i].a,ans[i].b); &#125;&#125; 有技巧的莫队莫队算法套路千变万化，有必要掌握几个常用的技巧。 例题3P3674 小清新人渣的本愿 莫队还能和$\\rm bitset$结合？ 这道题需要运用一些小技巧。 设现在莫队指针$l,r$维护的区间中不同的数组成的集合为${a_1,a_2,a_3…a_n}$ 我们维护这样一个$\\rm bitset$$s$，对于$a_i$，$s[a_i]=1$ Query1考虑如何实现查询$x-y=n$，发现$x=y+n$，所以对于所有出现在$a$集合中的数$a_i$，查询$a_i+n$在$a$集合中有没有出现即可。 这个可以通过操作$(s \\text{&amp;} (s&lt;&lt;n)).any()$实现，其中$any()$查询$\\rm bitset$中有没有$1$ Query2考虑实现查询$x+y=n$，其实本质和上面一种一样，就是化成$x=-y+n$，再维护一个下标为$-a_i$的$\\rm bitset$$s1$即可，但是这样做会有一个严重的问题，$\\rm bitset$下标不能为负数。 考虑给$-a_i$加上一个很大的正数$N$，这里使用$MAXN-1$ 把$s1$维护的数变为集合$b_i=-a_i+N$，原来的式子化成$x=-y+N+n-N$ 查询的操作转换成查询$b_i+n-N$有没有在$a_i$中出现。 注意到$n-N$为负数，于是左移$n-N$转换成右移$N-n$。 通过操作$(s \\text{&amp;} (s1&gt;&gt;(N-n))).any()$实现。 Query3这个比较简单，将$xy=n$转换成$x=\\frac{n}{y}$，于是$O(\\sqrt{n})$枚举$n$的所有因数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;bitset&lt;MAXN&gt;s,s1;int a[MAXN],cnt[MAXN],pos[MAXN];inline void Add(int x)&#123; if (cnt[x]++==0) s[x]=1,s1[MAXN-1-x]=1;&#125;inline void Del(int x)&#123; if (--cnt[x]==0) s[x]=0,s1[MAXN-1-x]=0;&#125;struct Query&#123; int opt,l,r,x,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return (pos[a.l]^pos[b.l])?pos[a.l]&lt;pos[b.l]:((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r);&#125;int ans[MAXN];int main()&#123; int n=read(),m=read(); int Size=(int)(sqrt(n)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; int opt=read(),l=read(),r=read(),x=read(); q[i]=Query&#123;opt,l,r,x,i&#125;; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(a[l++]); while (l&gt;q[i].l) Add(a[--l]); while (r&gt;q[i].r) Del(a[r--]); while (r&lt;q[i].r) Add(a[++r]); if (q[i].opt==1)&#123; ans[q[i].id]=(s&amp;(s&lt;&lt;(q[i].x))).any(); &#125; else if (q[i].opt==2)&#123; ans[q[i].id]=(s&amp;(s1&gt;&gt;(MAXN-1-q[i].x))).any(); &#125; else if (q[i].opt==3)&#123; for (register int j=1;j*j&lt;=q[i].x;++j)&#123; if (q[i].x%j!=0) continue; if (s[j]&amp;&amp;s[q[i].x/j])&#123; ans[q[i].id]=1; break; &#125; &#125; &#125; &#125; for (register int i=1;i&lt;=m;++i)&#123; puts(ans[i]==1?\"hana\":\"bi\"); &#125;&#125; 例题4U80812 相同颜色对 莫队可以套上容斥，达到$4$个指针$\\to $$2$个指针的效果。 题解 例题5P5071 [Ynoi2015]此时此刻的光辉 小范围前缀和，大范围莫队是哪个毒瘤想出来的？ 题解 例题6P4689 [Ynoi2016]这是我自己的发明 子树拍平，变成“上树莫队”。 题解 带修莫队只要再维护一个修改的指针就可以辣！ 例题7P1903 [国家集训队]数颜色 / 维护队列 我们来想一想莫队如何支持修改，我们把查询和修改操作离线下来，如图，将查询标为蓝色，将修改标为红色。 假设我们要查询六号查询的答案，考虑哪些修改会影响答案，肯定是在六号之前的修改，且这些修改的下标$ind$在六号查询的区间$[l,r]$之内，如图中$2$，$4$号修改，要把这些修改全部做完，才能得到正确的结果。 所以，我们在每个查询中除了$l,r,id$，还要记录一个$last$，代表最近的修改位置，查询时，我们要把$last$前面的修改全部做完，如代码。 123struct Query&#123; int l,r,id,last;//last为最近的修改位置&#125;q[MAXN]; 同时记录每个修改操作，只用记录修改的下标$ind$和修改的值$val$即可。 123struct Update&#123; int ind,val;//把ind修改成val&#125;u[MAXN]; 为了做带修莫队，我们记录一个指针$p$ ，代表我们把$[1,p]$的修改操作全部做完了，做莫队的时候，除了常规的莫队操作，还要有下面两行： 12while (p&lt;q[i].last) Upd(++p,i);while (p&gt;q[i].last) Upd(p--,i); 如果操作做少了，那么我们调用$Upd(++p,i)$，多做一次操作，如果操作做少了，我们调用$Upd(p—,i)$，撤销一次操作。 那么这个撤销怎么弄呢？ 很容易想到的是，我们在每个$Update$结构体里面再多存一个$flag$，代表当前是增加操作还是撤销操作，如果是撤销操作，那么我们删除$u[p].val$，加入$num[u[p].ind]$，每次操作后，$flag$取反，即撤销操作变成加入操作，加入操作变成撤销操作。 但是呢，这样代码量不但增加，常数也增多了，这道题你可能$TLE$，考虑有没有更加简洁优美的方法替代$flag$。 有！ 我们每次操作之后，将$num[u[p].ind]$和$u[p].val$对调，我们再撤销回去的时候，就相当于将$u[p].val$改成$num[u[p].ind]$，非常巧妙。 实现如下，注意只有修改的下标在现在查询范围之内才会对答案造成影响： 123456inline void Upd(int p,int i)&#123; if (q[i].l&lt;=u[p].ind&amp;&amp;u[p].ind&lt;=q[i].r)&#123; Del(num[u[p].ind]),Add(u[p].val);//修改，先删去原有的，再加进val &#125; swap(num[u[p].ind],u[p].val);&#125; 注意要加$sort$，（虽然我不加$sort$也卡过） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Query&#123; int l,r,id,last;//last为最近的修改位置&#125;q[MAXN];struct Update&#123; int ind,val;//把ind修改成val&#125;u[MAXN];int pos[MAXN],num[MAXN];inline bool operator &lt; (const Query &amp;x,const Query &amp;y)&#123; if(pos[x.l]!=pos[y.l]) return pos[x.l]&lt;pos[y.l]; if(pos[x.r]!=pos[y.r]) return pos[x.r]&lt;pos[y.r]; return x.last&lt;y.last;&#125;int cntq,cntu;inline char gc()&#123; char ch=getchar(); while (ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;int ans,Ans[MAXN];static int cnt[MAXN];#define Add(x) (++cnt[x]==1)?++ans:0#define Del(x) (--cnt[x]==0)?--ans:0inline void Upd(int p,int i)&#123; if (q[i].l&lt;=u[p].ind&amp;&amp;u[p].ind&lt;=q[i].r)&#123; Del(num[u[p].ind]),Add(u[p].val);//修改，先删去原有的，再加进val &#125; swap(num[u[p].ind],u[p].val);&#125;inline void Print(register int x)&#123; if (x&gt;=10ll) Print(x/10ll); putchar(x%10ll+48ll);&#125;inline void print(register int x,const char ch)&#123; if (x&lt;0)&#123;x=-x,putchar('-');&#125; if (x==0)&#123;putchar('0');putchar(ch);return ;&#125; Print(x);putchar(ch);&#125;int main()&#123; int n=read(),m=read(); const int Size=pow(n,(double)0.666666666); for (register int i=1;i&lt;=n;++i)&#123; num[i]=read(); &#125; for (register int i=1;i&lt;=m;++i)&#123; char opr=gc(); if (opr=='Q') q[++cntq]=Query&#123;read(),read(),cntq,cntu&#125;; else u[++cntu]=Update&#123;read(),read()&#125;; &#125; for (register int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/Size+1; &#125; sort(q+1,q+1+cntq); register int l=1,r=0; register int p=0;//修改的操作 for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(num[l++]); while (l&gt;q[i].l) Add(num[--l]); while (r&lt;q[i].r) Add(num[++r]); while (r&gt;q[i].r) Del(num[r--]); while (p&lt;q[i].last) Upd(++p,i); while (p&gt;q[i].last) Upd(p--,i); Ans[q[i].id]=ans; &#125; for (register int i=1;i&lt;=cntq;++i)&#123; print(Ans[i],'\\n'); &#125;&#125; 树上莫队 普通莫队是在一个一个地移动指针，树上莫队是一个一个爬节点—-SXYZ巨佬 例题8BZOJ苹果树 这才是真的树上莫队。 题解 例题9SP10707 COT2 - Count on a tree II 和上面那题几乎一样，这里只放代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MAXM 17using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int c[MAXN];//每个点的颜色int anc[MAXN][MAXM],dep[MAXN];int euler[MAXN];//欧拉序(出栈入栈都要记录)int L[MAXN],R[MAXN];//左右端点int tot;void dfs(int u,int father)&#123; dep[u]=dep[father]+1; anc[u][0]=father; euler[L[u]=++tot]=u; for (register int i=1;i&lt;MAXM;++i) anc[u][i]=anc[anc[u][i-1]][i-1]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father) dfs(v,u); &#125; euler[R[u]=++tot]=u;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i],v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;int n,m;inline void discrete()&#123; int tempc[MAXN]; for (register int i=1;i&lt;=n;++i) tempc[i]=c[i]; sort(tempc+1,tempc+1+n); for (register int i=1;i&lt;=n;++i)&#123; c[i]=lower_bound(tempc+1,tempc+1+n,c[i])-tempc; &#125;&#125;int b[MAXN];//块编号struct Query&#123; int u,v,lca,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123;//莫队的玄学优化 return (b[A.u]^b[B.u])?b[A.u]&lt;b[B.u]:((b[A.u]&amp;1)?A.v&lt;B.v:A.v&gt;B.v);&#125;int inq[MAXN];//在不在莫队维护的范围内int ans,cnt[MAXN];inline void Update(int i)&#123;//相应地加上/减去元素 if (!inq[i])&#123;//加上 cnt[c[i]]++; if (cnt[c[i]]==1) ans++; inq[i]=true; &#125; else &#123; cnt[c[i]]--; if (cnt[c[i]]==0) ans--; inq[i]=false; &#125;&#125;int Ans[MAXN];inline Query make_q(int u,int v,int lca,int id)&#123; Query temp; temp.id=id; temp.u=u,temp.v=v; temp.lca=lca; return temp;&#125;int main()&#123; n=read(),m=read();int Size=sqrt(n);//块大小 for (register int i=0;i&lt;MAXN;++i)&#123; b[i]=i/Size+1; &#125; for (register int i=1;i&lt;=n;++i)&#123; c[i]=read(); &#125; discrete(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; dfs(1,1); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); if (L[u]&gt;L[v]) swap(u,v);//保证这条链是从左往右 int lca=LCA(u,v); if (u==lca) q[i]=make_q(L[u],L[v],0,i);//u为这条链的顶点 else q[i]=make_q(R[u],L[v],lca,i); &#125; sort(q+1,q+1+m); int l=1,r=0;//模仿STL队列 for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].u) Update(euler[l++]); while (l&gt;q[i].u) Update(euler[--l]); while (r&lt;q[i].v) Update(euler[++r]); while (r&gt;q[i].v) Update(euler[r--]); if (q[i].lca) Update(q[i].lca);//注意处理lca Ans[q[i].id]=ans; if (q[i].lca) Update(q[i].lca); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d \",Ans[i]); &#125;&#125; 回滚莫队回滚莫队这个名字好可爱呀！ 有时候加上一个元素可以$O(1)$算出答案，但是减去一个元素不能$O(1)$算出，而一些加上或者减去时间复杂度$O(\\log n)$的算法会被卡成狗，此时回滚莫队就派上用场了。 事实上就是$l$端点移动的部分每一次都重新计算。 分只增不减和只减不增两个种类。 例题10AT1219 歴史の研究 回滚莫队的基础题。 题解 例题11BZOJ 4358 permu 我的解法绝对是全网最易懂的。 题解 例题12P4137 Rmq Problem / mex 虽然权值线段树也是可做的。 只减不增的回滚莫队（虽然我智障写了一个只增不减的版本） 题解 例题13SP20644 ZQUERY - Zero Query 另一种鬼畜的莫队套路。 题解 分块+莫队分块$O(\\sqrt n)$的怎么会跑得比$O(\\log n)$的线段树/树状数组快？ 结合莫队算法的特性，发现有时候使用分块+莫队会使得复杂度少一个$\\log$避免被卡。 例题14P4867 Gty的二逼妹子序列 洛谷数据水，$O(n \\sqrt n \\log n)$的做法也可以卡过。 但是这个就是一个$\\log $的差距： 题解 例题15P4396 [AHOI2013]作业 一样的套路呀 题解 总结：莫队是一种扩展性极强的算法，而且常数小极难被卡，缺点是必须在线，强制在线就gg了（虽然有在线莫队这种东西）。掌握还是非常必要的。","categories":[],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"}]},{"title":"Codeforces Round #589 (Div. 2)","slug":"Codeforces-Round-589-Div-2","date":"2019-09-30T11:41:52.000Z","updated":"2019-09-30T12:50:08.002Z","comments":true,"path":"archives/9b983113.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/9b983113.html","excerpt":"","text":"比赛传送门 $Pro1$传送门 让你找到任意一个数$x \\in [l,r]$，使得$x$的各位数字都不同。 $Sol1$注意到$1 \\le l \\le r \\le 10^5$，每个数最多$5$位。 于是硬上$O(n \\log _{10} n)$大模拟即可。 $Code1$123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int Check(int x)&#123; int cnt[10]; memset(cnt,0,sizeof(cnt)); while (x) &#123; cnt[x%10]++; x/=10; &#125; for (register int i=0;i&lt;=9;++i)&#123; if (cnt[i]&gt;1) return false; &#125; return true;&#125;int main()&#123; int l=read(),r=read(); for (register int i=l;i&lt;=r;++i)&#123; if (Check(i))&#123; printf(\"%d\\n\",i); return 0; &#125; &#125; puts(\"-1\"); return 0;&#125; $Pro2$传送门 给你两个数列$r[i],c[i]$，要你构造一个长$h$宽$w$的格子图，使得第$i$个纵列从最上面数起刚好有$c[i]$个连续的黑色格子，第$i$个横列从最左边数起刚好有$r[i]$个连续的黑色格子。 求满足条件的格子图的总数。 $Sol2$设这个图是$map$，注意到$map[i][1 \\to r[i]]$都必须是黑色的，$map[i][r[i]+1]$为白色的，对于$c[i]$也是同理。 如果这样染色出现冲突，答案就是$0$。 发现剩下的格子都可以随意染色，于是答案就是$2^{未被染色的格子个数}$ $Code2$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[1005][1005];int main()&#123; int h=read(),w=read(); memset(a,-1,sizeof(a)); for (register int i=1;i&lt;=h;++i)&#123; int len=read(); for (register int j=1;j&lt;=len;++j)&#123; if (a[i][j]==0)&#123;//出现冲突 puts(\"0\"); return 0; &#125; a[i][j]=1; &#125; if (a[i][len+1]==1)&#123; puts(\"0\"); return 0; &#125; a[i][len+1]=0; &#125; for (register int i=1;i&lt;=w;++i)&#123; int len=read(); for (register int j=1;j&lt;=len;++j)&#123; if (a[j][i]==0)&#123; puts(\"0\"); return 0; &#125; a[j][i]=1; &#125; if (a[len+1][i]==1)&#123; puts(\"0\"); return 0; &#125; a[len+1][i]=0; &#125; long long ans=1; for (register int i=1;i&lt;=h;++i)&#123; for (register int j=1;j&lt;=w;++j)&#123; if (a[i][j]==-1) ans=(ans*2ll)%((long long)1e9+7);//没被染色 &#125; &#125; printf(\"%lld\\n\",ans);&#125; $Pro3$传送门 定义$prime(x)$为$x$的质因子的集合，比如说$prime(140)=\\{2,5,7\\}$ 设$g(x,p)$是能够整除$x$的最大的$p^k$，比如说$g(45,3)=9$ 设$f(x,y)$为$\\prod _{p \\in prime(x)} g(y,p)$，比如说$f(30, 70) = g(70, 2) \\cdot g(70, 3) \\cdot g(70, 5) = 2^1 \\cdot 3^0 \\cdot 5^1 = 10$ 给你$x,n$，计算$\\prod _{i=1}^n f(x,i)$ $Sol3$数论不会先打表 先计算一下$x=10,n=10$的情况： $f(10,1)=1$ $f(10,2)=2$ $f(10,3)=1$ $f(10,4)=4$ $f(10,5)=5$ $f(10,6)=2$ $f(10,7)=1$ $f(10,8)=8$ $f(10,9)=1$ $f(10,10)=10$ 如何考虑，不妨对$prime(x)$中的元素分别考虑，考虑质因子$2$对答案的贡献，他会分别对$f(x,2 \\times i)$做出一个$2$的贡献，同时对$f(x,2^2 \\times i)$做出一个$2$的贡献，对$f(x,2^3 \\times i)$做出一个$2$的贡献。 于是总的贡献是$2^ {⌊n/2⌋} \\times 2 ^ {⌊n/2^2⌋} \\times 2^{⌊n/2^3⌋} …$ 于是我们得到核心代码： 1234567inline int Calc(int x,int n)&#123; while (n)&#123; ans=(ans*ksm(x,n/x,MOD))%MOD; n/=x; &#125; return 0;&#125; 就是计算每一个质因子$x$对于答案的贡献。 $Code3$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define int long long#define MOD 1000000007using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int ans=1;inline int ksm(int b,int p,int k)&#123; int ans=1; while (p&gt;0)&#123; if (p&amp;1ll)&#123; ans=(b*ans)%k; &#125; b=(b*b)%k; p&gt;&gt;=1ll; &#125; return ans%MOD;&#125;inline int Calc(int x,int n)&#123; while (n)&#123; ans=(ans*ksm(x,n/x,MOD))%MOD; n/=x; &#125; return 0;&#125;int cnt,primes[MAXN];inline void Sieve(int x)&#123; int bd=sqrt(x); for (register int i=2;i&lt;=bd;++i)&#123; if (x%i==0)&#123; primes[++cnt]=i; while (x%i==0) x/=i; &#125; &#125; if (x&gt;1) primes[++cnt]=x;//x是质数&#125;#undef intint main()&#123;#define int long long int x,n; cin&gt;&gt;x&gt;&gt;n; Sieve(x);//找出x的所有质因子 for (register int i=1;i&lt;=cnt;++i)&#123; Calc(primes[i],n); &#125; cout&lt;&lt;ans;&#125; $Pro4$传送门 称两个点集$v_1,v_2$是好的，当且仅当$v_1,v_2$之间没有连边，而且任意$x \\in v_1,y \\in v_2$，$x,y$都有边相连。 要你把$1 \\dots n$的点分成$3$个集合$v_1,v_2,v_3$，满足$v_1 ∪ v_2 ∪ v_3 = \\{1 \\dots n\\}$，而且$v_1,v_2$是好的，$v_2,v_3$是好的，$v_3,v_1$是好的。 如下图$\\{1\\},\\{2,3\\},\\{4,5,6\\}$就是一个合法的解。 $Sol4$首先，这个图如果不联通，就无解。 仔细观察上图，发现从一个点连出的边，总是到达和这个点不属于同一个集合的一个点，我们可以利用这个性质。 首先，令点$1$所在的集合编号为$1$，显然，将$1$连出的边遍历一遍，就可以找到不在$1$中的点，剩下的点在集合$1$。 123for (register int i=0;i&lt;G[1].size();++i)&#123; vis[G[1][i]]=true;//标记2,3组&#125; 在从标记到的点集中随便抽出一个点$u$，钦定它在集合$2$中，那么它能够到达的点肯定是在集合$1,3$中，此时$1$集合中的点我们已经知道了，于是$3$集合我们也可以知道是那些。 12345678910111213bool flag=true;for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i])&#123; ans[i]=1; &#125; else if (vis[i]&amp;&amp;flag)&#123; for (register int j=0;j&lt;G[i].size();++j)&#123;//这次到达的是1,3组 int v=G[i][j]; if (vis[v]) ans[v]=3; &#125; flag=false; &#125;&#125; 下面是麻烦的验证过程： 首先，计算出在集合$1$，$2$，$3$中的点数$cnt1,cnt2,cnt3$ 注意到$cnt1 !=0,cnt2!=0,cnt3!=0$且$cnt1cnt2+cnt2cnt3+cnt1*cnt3=m$。 而且和每个点相邻的所有点都在另外两个集合中，可以根据这个性质进一步验证。 123456789101112131415161718192021int cnt1=0,cnt2=0,cnt3=0;for (register int i=1;i&lt;=n;++i)&#123; if (ans[i]==0) ans[i]=2; if (ans[i]==1) cnt1++; if (ans[i]==2) cnt2++; if (ans[i]==3) cnt3++; &#125;if (cnt1==0||cnt2==0||cnt3==0) return puts(\"-1\"),0;if (cnt1*cnt2+cnt2*cnt3+cnt3*cnt1!=m) return puts(\"-1\"),0;int c[4];for (register int i=1;i&lt;=n;++i)&#123; memset(c,0,sizeof(c)); for (register int j=0;j&lt;G[i].size();++j)&#123; c[ans[G[i][j]]]++; &#125; if (c[ans[i]]!=0) return puts(\"-1\"),0;//两个点在同一个集合 if (ans[i]==1) if (c[2]!=cnt2||c[3]!=cnt3) return puts(\"-1\"),0;//和不相等 if (ans[i]==2) if (c[1]!=cnt1||c[3]!=cnt3) return puts(\"-1\"),0; if (ans[i]==3) if (c[1]!=cnt1||c[2]!=cnt2) return puts(\"-1\"),0;&#125; $Code4$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define MAXN 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int deg[MAXN],vis[MAXN];int vised[MAXN];vector&lt;int&gt;G[MAXN];inline void dfs(int u)&#123; vised[u]=true; for (register int i=0;i&lt;G[u].size();++i)&#123; if (!vised[G[u][i]]) dfs(G[u][i]); &#125;&#125;int ans[MAXN];int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); G[u].push_back(v),G[v].push_back(u); deg[u]++,deg[v]++; &#125; dfs(1); for (register int i=1;i&lt;=n;++i)&#123; if (!vised[i]) return puts(\"-1\"),0;//判断联通 &#125; for (register int i=0;i&lt;G[1].size();++i)&#123; vis[G[1][i]]=true;//标记2,3组 &#125; bool flag=true; for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i])&#123; ans[i]=1; &#125; else if (vis[i]&amp;&amp;flag)&#123; for (register int j=0;j&lt;G[i].size();++j)&#123;//这次到达的是1,3组 int v=G[i][j]; if (vis[v]) ans[v]=3; &#125; flag=false; &#125; &#125; int cnt1=0,cnt2=0,cnt3=0; for (register int i=1;i&lt;=n;++i)&#123; if (ans[i]==0) ans[i]=2; if (ans[i]==1) cnt1++; if (ans[i]==2) cnt2++; if (ans[i]==3) cnt3++; &#125; if (cnt1==0||cnt2==0||cnt3==0) return puts(\"-1\"),0; if (cnt1*cnt2+cnt2*cnt3+cnt3*cnt1!=m) return puts(\"-1\"),0; int c[4]; for (register int i=1;i&lt;=n;++i)&#123; memset(c,0,sizeof(c)); for (register int j=0;j&lt;G[i].size();++j)&#123; c[ans[G[i][j]]]++; &#125; if (c[ans[i]]!=0) return puts(\"-1\"),0; if (ans[i]==1) if (c[2]!=cnt2||c[3]!=cnt3) return puts(\"-1\"),0; if (ans[i]==2) if (c[1]!=cnt1||c[3]!=cnt3) return puts(\"-1\"),0; if (ans[i]==3) if (c[1]!=cnt1||c[2]!=cnt2) return puts(\"-1\"),0; &#125; for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"比赛","slug":"比赛","permalink":"https://gaisaiyuno.github.io/tags/比赛/"}]},{"title":"P5339 [TJOI2019]唱、跳、rap和篮球","slug":"P5339-TJOI2019-唱、跳、rap和篮球","date":"2019-09-26T13:57:28.000Z","updated":"2019-09-26T15:05:41.760Z","comments":true,"path":"archives/c2f53ce.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c2f53ce.html","excerpt":"","text":"传送门 容易想到的是，枚举讨论蔡徐坤的组数，设至少有$k$组讨论蔡徐坤的人方案数是$f(k)$，容斥一下，答案就是$\\sum _{i=0}^{n/4} f(k) \\times (-1)^k$。 现在的主要问题是求出$f(k)$，将讨论蔡徐坤的四个人缩成一个组，所以这样的组数是$k$组，剩下的人数$left=n-k \\times 4$。 于是问题转化为一个长度为$n-k \\times 4+k$的序列，往里面放$k$个讨论蔡徐坤的组，剩下放入$a’$个喜欢唱的，$(0\\le a’ \\le a-k)$，放入$b’$个喜欢跳的，$(0 \\le b’ \\le b-k)$，……，满足$a’+b’+c’+d’=n-k \\times 4$。（即放满） 放入$k$个讨论蔡徐坤的组，方案数是$C_{left+k}^k$。 剩下如何处理唱跳rap篮球呢？ 第一种方法：放入$a’$个喜欢唱的，方法数$C_{left}^{a’}$，剩下$left-a’$个空位。 放入$b’$个喜欢跳的，方法数$C_{left-a’}^{b’}$，剩下$left-a’-b’$个空位。 放入$c’$个喜欢rap的，方法数$C_{left-a’-b’}^{c’}$，由于确定了$a’,b’,c’$，剩下的$d’$即确定，后面的$d’$不用枚举。 令$A=a-k,B=b-k,C=c-k,D=d-k$。 答案方案数$\\sum_{a’ \\in [0,A],b’ \\in [0,B] ,c’ \\in [0,C]} C_{left}^{a’} \\times C_{left-a’}^{b’} \\times C_{left-a’-b’}^{c’}$。 但是注意到我们要枚举$a’,b’,c’$，时间复杂度$O(n^4)$，过不去。 就算是前缀和优化$C_{left-a’-b’}^{c’}$，时间复杂度$O(n^3)$，还是gg。 第二种方法：不妨把喜欢唱和喜欢跳的放在一起考虑。 先枚举他们加起来的总数$tot1=a’+b’$，方案数$C_{left}^{tot1}$。 再枚举$a’$，方案数$C_{tot1}^{a’}$，同理，确定了$a’$，剩下的$b’$就确定了，所以不用枚举。 剩下的喜欢rap的和喜欢篮球的，总数也确定为$tot2=left-tot1$ 枚举$c’$，方案数$C_{tot2}^{c’}$。 这样答案就是$\\sum_{tot1 \\in [0,left] ,a’ \\in [tot1-B,A] , c’ \\in [tot2-D,C]} C_{left}^{tot1} \\times C_{tot1}^{a’} \\times C_{tot2}^{c’}$ 为什么是$[tot1-B,A]$，因为$i$的取值不能小于$tot1-B$，否则喜欢跳的超过$B$，不行。 注意到这样我们还是要枚举三个变量$tot1,a’,c’$ ，时间复杂度$O(n^4)$，gg。 不妨考虑固定住$tot1$，只考虑后面一坨。 答案就是$\\sum_{tot1 \\in [0,left],tot2=left-tot1}C_{left}^{tot1}\\times((\\sum_{a’\\in [tot1-B,A]} C_{tot1}^{a’}) \\times (\\sum_{c’ \\in [tot2-D,C]} C_{tot2}^{c’}))$ 后面两坨都可以通过前缀和$O(1)$算出，所以总时间复杂度$O(n^2)$，可以$AC$。 总结，可以通过类似于折半搜索的方法减少时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define MOD 998244353#define MAXN 1005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int n,a,b,c,d;int C[MAXN][MAXN],sum[MAXN][MAXN];inline void Init()&#123; for (register int i=0;i&lt;=n;++i)&#123; C[i][0]=sum[i][0]=1; for (register int j=1;j&lt;=i;++j)&#123; C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD; &#125; for (register int j=1;j&lt;=n;++j)&#123; sum[i][j]=(sum[i][j-1]+C[i][j])%MOD; &#125; &#125;&#125;inline long long QuerySum(int i,int l,int r)&#123; if (l&gt;r) return 0; if (l&lt;=0) return sum[i][r]; return (sum[i][r]-sum[i][l-1]+MOD)%MOD;&#125;int main()&#123; n=read(); a=min(n,read());b=min(n,read());c=min(n,read());d=min(n,read());//超过n和n取min，因为任何一种都不可能用超过n次 Init(); int ans=0; for (register int cxk=0;cxk&lt;=n/4ll;++cxk)&#123;//cxk是讨论cxk的组数 int ret=0; int left=n-cxk*4; for (register int i=0;i&lt;=left;++i)&#123;//从剩下的人里面选出i个人讨论唱跳，剩下讨论rap篮球 int j=left-i;//讨论rap和篮球 ret=(ret+(long long)C[left][i]*QuerySum(i,i-b,a)%MOD*QuerySum(j,j-d,c)%MOD)%MOD; &#125; ret=((long long)ret*C[cxk+left][cxk])%MOD; if (cxk&amp;1) ans=(ans-ret+MOD)%MOD; else ans=(ans+ret)%MOD; --a,--b,--c,--d; if (a&lt;0||b&lt;0||c&lt;0||d&lt;0) break; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"Raney引理","slug":"Raney引理","date":"2019-09-24T10:30:26.000Z","updated":"2019-09-24T10:53:47.626Z","comments":true,"path":"archives/c03dcfce.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c03dcfce.html","excerpt":"","text":"一个非常有趣的结论： $Raney$引理： 给你一个数列$\\{a_i\\} (1 \\le i \\le n)$，而且定义$S_i=\\sum _{i=1}^n a_i$，并且$S_n=1$，求证$\\{a_i\\}$的循环排列里面有且仅有一个序列，满足$\\forall i \\in [1,n],S_i &gt; 0$。 循环排列的意思也非常好理解。 举一个例子：$a=\\{1,4,-5,3,-2,0\\}$ 循环排列为： $$ $$ $&lt;-5, 3, -2, 0, 1, 4&gt;$ $$ $&lt;-2, 0, 1, 4, -5, 3&gt;$ $$ 显然对于这组数据来说，$4$是满足条件的。 如何证明？ 看到这类环上的问题，首先考虑拆环成链。 考虑一个无限的数列$b=\\{a_1,a_2,a_3,…a_n,a_1,a_2,a_3,…a_n,a_1,a_2…\\}$ 对于这个数列，再做一次前缀和，设$f_x=\\sum _{i=1}^x a[i]$ 注意到$f_{x+n}-f_x=f_n=1$，所以这个函数每过$n$格就会整体向上平移一格： 资料来源：浅谈数形结合思想在信息学竞赛中的应用 可以看图理解。 于是我们可以构造斜率为$\\frac{1}{n}$的两条直线”夹住”原函数。 可以发现每过$n$个点，下面那条直线就会和函数相切一次。 从那个切点（图中为$(3,0)$）向上走，发现所有的$S_i$都$&gt;0$，因为函数不可能和下面的直线相交。 同时在每$n$个点中，有且仅有一个点和直线相切（因为每过$n$个点函数才会经过一次整点），这就证明了唯一性。 思考，$S_n!=1$时，为什么不能说明唯一性？ 因为$S_n!=1$时，斜率为$\\frac{S_n}{n}$，不能保证一定只经过一个整点。 比如$S_n=2,n=6$时，就会发现会有矛盾。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"闵可夫斯基和","slug":"闵可夫斯基和","date":"2019-09-23T13:58:40.000Z","updated":"2019-09-23T14:46:30.962Z","comments":true,"path":"archives/ecbc42ec.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ecbc42ec.html","excerpt":"","text":"对于两个凸包$A,B$，把它们的最下面的点平移到$(0,0)$的位置，对于$\\vec a \\in A,\\vec b \\in B$，$\\vec a+\\vec b$构成的凸包就是两个凸包的闵可夫斯基和。 如何理解呢？ （图片来自洛谷） 对于这张图，顶点已经平移到$(0,0)$，先固定$\\vec a$，现在我们把另一个凸包的顶点平移到$\\vec a$代表的点，发现另一个凸包现在代表的区域是$\\vec a + \\vec b$，于是，我们把另一个凸包的顶点平移到第一个凸包内的点上，把平移后的区域全部涂上颜色，最后所有有颜色的区域就是他们俩的闵可夫斯基和。 继续观察，发现这个大凸包上面有7条边，第一个凸包有3条边，第二个凸包有4条边，仿佛暗示着大凸包的所有边是第一个和第二个凸包所有边首尾相连形成的。 怎么首尾相连，观察到是按照极角大小从小到大依次首尾相连形成的。 于是我们有了一个奇妙的结论：把两凸包的边极角排序后直接顺次连起来就是闵可夫斯基和。 实现起来非常容易，因为两个凸包的边本来就是有序的，只要把两个凸包的边归并一下即可。 例题：P4557 [JSOI2018]战争 九条可怜最可爱了！ 假设移动的向量是$\\vec d$，第二个凸包里面的向量$\\vec b$变成$\\vec b +\\vec d$ 于是题目要求的就是是否存在$\\vec a,\\vec b$，使得$\\vec a = \\vec b + \\vec d$ 简单移项，变成$\\vec d = \\vec a -\\vec b$ 于是就是询问$\\vec d$是否属于$\\{ \\vec c | \\vec c = \\vec a - \\vec b\\}$ 这个就是把第二个凸包的所有点按照$(0,0)$对称，再求闵可夫斯基凸包和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Point&#123; ll x,y;&#125;;inline ll operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double dis(const Point &amp;A)&#123; return sqrt(A.x*A.x+A.y*A.y);&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; ll ans=(A*B); if (ans!=0) return ans&gt;0; else return dis(A)&lt;dis(B);&#125;Point stk[MAXN];int top;struct Convex&#123; Point A[MAXN]; int tot,pos; Convex()&#123;pos=1;memset(A,0,sizeof(A));tot=0;&#125; Point &amp; operator[] (int pos)&#123;return A[pos];&#125; inline void Insert(Point P)&#123; A[++tot]=P; if (A[pos].x&gt;P.x||(A[pos].x==P.x&amp;&amp;A[pos].y&gt;P.y)) pos=tot; &#125; inline void Build()&#123;//建立凸包 swap(A[1],A[pos]); for (register int i=2;i&lt;=tot;++i) A[i]=A[i]-A[1]; sort(A+2,A+1+tot); for (register int i=2;i&lt;=tot;++i) A[i]=A[i]+A[1]; top=0; for (register int i=1;i&lt;=tot;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(A[i]-stk[top-1])&lt;=0) top--; stk[++top]=A[i]; &#125; memcpy(A,stk,sizeof(A)); tot=top; &#125; inline Point Top()&#123;//获取凸包上面最后一个元素 return A[tot]; &#125;&#125;F,S;Point s1[MAXN],s2[MAXN];Point temp;inline Convex Minkowski(Convex X,Convex Y)&#123; int n=X.tot,m=Y.tot; for (register int i=1;i&lt;n;++i) s1[i]=X[i+1]-X[i]; s1[n]=X[1]-X[n]; for (register int i=1;i&lt;m;++i) s2[i]=Y[i+1]-Y[i]; s2[m]=Y[1]-Y[m]; Convex Ans; Ans.Insert(X[1]+Y[1]); int j=1,k=1;//凸包归并 while (j&lt;=n&amp;&amp;k&lt;=m) Ans.Insert(Ans.Top()+(s1[j]*s2[k]&gt;=0?s1[j++]:s2[k++])); while (j&lt;=n) Ans.Insert(Ans.Top()+s1[j++]); while (k&lt;=m) Ans.Insert(Ans.Top()+s2[k++]); temp=Ans[1]; for (register int i=Ans.tot;i&gt;=1;--i)&#123; Ans[i]=Ans[i]-temp; &#125; return Ans;&#125;Convex A;inline bool Inside(Point P)&#123;//判断P是否在凸包内 if (P*A[1]&gt;0||A.Top()*P&gt;0) return false; int pos=lower_bound(A.A+1,A.A+1+A.tot,P)-A.A-1; return (P-A[pos])*(A[pos%A.tot+1]-A[pos])&lt;=0;&#125;int main()&#123; int n=read(),m=read(),q=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(); F.Insert(Point&#123;x,y&#125;); &#125; for (register int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); S.Insert(Point&#123;-x,-y&#125;); &#125; F.Build(),S.Build(); A=Minkowski(F,S); A.Build(); while (q--)&#123; int dx=read(),dy=read(); puts(Inside(Point&#123;dx,dy&#125;-temp)?\"1\":\"0\"); &#125;&#125; 是不是感觉九条题目就是这样？","categories":[],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://gaisaiyuno.github.io/tags/计算几何/"},{"name":"凸包","slug":"凸包","permalink":"https://gaisaiyuno.github.io/tags/凸包/"}]},{"title":"初赛错题汇总","slug":"初赛错题汇总","date":"2019-09-18T14:06:15.000Z","updated":"2019-09-20T14:11:03.719Z","comments":true,"path":"archives/cd22ebc6.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/cd22ebc6.html","excerpt":"","text":"1.不同类型的存储器组成了多层次结构的存储器体系，按存取速度从快到慢排列的是( ) [分值：1.5]您的回答：A．快存/辅存/主存正确答案为：C．快存/主存/辅存 其实辅存为硬盘之类的东西，以前一直搞错了。 2.下列文件名中，属于DOS中的保留设备名的为( ) [分值：1.5]您的回答：C．CON1正确答案为：B．COM 常识题，不知道为什么如此毒瘤。 DOS保留设备名： CON 作为输入用的文件名，指键盘AUX或COM1 作为输出用的文件名，指屏幕COM2 第一串行口COM3 第二串行口COM4 第三串行口LPT1 或PRN 第四串行LPT1 第一并行口或者打印机LPT2 第二并行口LPT3 第三并行口PRN 打印机NUL 空设备 3.用拼音法输入汉字“国”，拼音是“guo”。那么，“国”的汉字内码占字节的个数是( ) [分值：1.5]您的回答：D．4正确答案为：B．2 在国内流行的汉字系统中，一个汉字的机内码占2个字节。 那么为什么要告诉拼音啊！ 4.一个字长为8位的整数的补码是1111 1001，则它的原码是( )。 [分值：1.5]您的回答：A．0000 0111正确答案为：D．1000 0111 看错了，原数绝对值为$0000110+1=0000111$，又因为是负数，所以原码是$10000111$。 5.G 是一个非连通简单无向图，共有 28 条边，则该图至少有( )个顶点。 [分值：1.5]您的回答：C. 8正确答案为：B. 9 非联通。。。。 6.在CONFIG.SYS文件中，装入特定可安装设备驱动器程序的命令是( ) [分值：1.5]您的回答：C．DRIVER正确答案为：D．DEVICE 常识题 7.24针打印机的分辨率约为180dpi。Dpi数越大，打印精度越高。其中单位dpi是指( ) [分值：1]您的回答：D．印点/寸正确答案为：C．印点/英寸 常识题 8.在计算机行业中，MIS是指( ) [分值：1]您的回答：C．多指令系统正确答案为：A．管理信息系统 原来以为是multiple instruction system，没想到是manage information system。 9.将DOS系统盘插入A驱动器启动机器，随后使用一批应用软件，在此过程中，DOS系统盘( ) [分值：1]您的回答：C．可能有时要插入A驱动器中正确答案为：B．不必再用 10.在MS DOS的根目录中，有如下文件：TIME.EXE、TIME.COM、TIME.BAT，则C:\\TIME&lt;回车&gt;执行的是( ) [分值：1]您的回答：B．TIME.COM正确答案为：A．TIME.EXE 11.关于拓扑排序，下面说法正确的是( )。 [分值：1]您的回答：A．所有连通的有向图都可以实现拓扑排序正确答案为：D．拓扑排序结果序列中的第一个结点一定是入度为0的点 如果图是$,,…$那么无法拓扑排序。 12.现有一段文言文，要通过二进制哈夫曼编码进行压缩。简单起见，假设这段文言文只由4个汉字“之”、“呼”、“者”、“也”组成，它们出现的次数分别为700、600、300、200。那么，“也”字的编码长度是( )。 [分值：1]您的回答：D．4正确答案为：C．3 之： 700 0 乎： 600 11 者： 300 101 也： 200 100 13.以下哪个是面向对象的高级语言( )。 [分值：1]您的回答：C. Fortran正确答案为：B.C++ C++是面向对象的。","categories":[],"tags":[{"name":"初赛","slug":"初赛","permalink":"https://gaisaiyuno.github.io/tags/初赛/"}]},{"title":"半夜笑死系列","slug":"半夜笑死系列","date":"2019-09-15T13:19:45.000Z","updated":"2019-09-15T13:22:43.901Z","comments":true,"path":"archives/3b37304e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3b37304e.html","excerpt":"","text":"hhh不解释 不知道是哪位神人做的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306/*演奏乐曲《小星星》《茉莉花》《找朋友》《上学歌》《一分钱》《征服》《沧海一声笑》《童话》《同桌的你》《小熊和洋娃娃》*/#include&lt;stdio.h&gt;#include&lt;windows.h&gt; void _wo_men_duo_me_xing_fu(void); void _long_de_chuan_ren(void); void play_zhaopengyou(void); void play_shangxuege(void); void play_yifenqian(void); void play_zhengfu(void); void play_canghaiyishengxiao(void); void play_tonghua(void); void play_tongzhuodeni(void); void play_xiaoxiongheyangwawa(void);int main()&#123; int choice; while(1) &#123; printf(\"请选择：\");scanf(\"%d\",&amp;choice); switch(choice) &#123; case 1: _wo_men_duo_me_xing_fu(); break; case 2: _long_de_chuan_ren();break; case 3: play_zhaopengyou();break; case 4: play_shangxuege();break; case 5: play_yifenqian();break; case 6: play_zhengfu();break; case 7: play_canghaiyishengxiao();break; case 8: play_tonghua();break; case 9: play_tongzhuodeni();break; case 10: play_xiaoxiongheyangwawa();break; case 0: break; default: printf(\"输入有误！请正确输入！\\n\"); &#125; Beep(0,1000);//暂停一秒钟 printf(\"\\n\"); if(choice==0) &#123; printf(\"\\n谢谢使用，再见！\"); Beep(0,1000);//暂停一秒钟 break; &#125; &#125; return 0;&#125;/*返回数字简谱中数字t所对应的频率*/int notation_frequency(int t)&#123; switch (t) &#123; /*中音部分:1,2,3,4,5,6,7*/ case 1:return 523; case 2:return 587; case 3:return 659; case 4:return 698; case 5:return 784; case 6:return 880; case 7:return 988; /*低音部分:-1,-2,-3,-4,-5,-6,-7*/ case -1:return 262; case -2:return 294; case -3:return 330; case -4:return 349; case -5:return 392; case -6:return 440; case -7:return 494; /*高音部分:11,12,13,14,15,16,17*/ case 8:return 1047; case 9:return 1175; case 10:return 1319; case 11:return 1397; case 12:return 1568; case 13:return 1760; case 14:return 1976; /*安静:0,不合法数值*/ default:return 0; &#125;&#125;void _wo_men_duo_me_xing_fu(void)&#123; int i; int _xiaoxingxing[]=&#123;&#125;; int notation_frequency(int t); Beep(0,1000); for (i=0;i&lt;=47;i++) &#123; if(_xiaoxingxing[i]==0) printf(\"\\n\"); else printf(\"%d\",_xiaoxingxing[i]); Beep(notation_frequency(_xiaoxingxing[i]),1000); &#125; printf(\"thanks \\n\");&#125;void _long_de_chuan_ren(void)&#123; int i,t; int _molihua[]=&#123;&#125;; Beep(0,1000); for (i=0;i&lt;=71;i++) &#123; t=_molihua[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_molihua[i]),1000); &#125; printf(\"thanks \\n\");&#125;void play_zhaopengyou(void)&#123; int i,t; int _zhaopengyou[32]=&#123;5,6,5,6,5,6,5,0, 5,11,7,6,5,5,3,0, 5,5,3,3,5,5,3,0, 2,4,3,2,1,2,1,0, &#125;;//找朋友乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《找朋友》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=31;i++) &#123; t=_zhaopengyou[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_zhaopengyou[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《上学歌》*/void play_shangxuege(void)&#123; int i,t; int _shangxuege[30]=&#123;1,2,3,1,5,0, 6,6,11,6,5,0, 6,6,11,0, 5,6,3,0, 6,5,3,5,3,1,2,3,1,0 &#125;;//找朋友乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《上学歌》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=29;i++) &#123; t=_shangxuege[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_shangxuege[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《一分钱》*/void play_yifenqian(void)&#123; int i,t; int _yifenqian[52]=&#123;5,11,6,11,5,0, 3,5,2,3,5,0, 3,5,6,11,5,6,5,3,5,1,0, 3,2,0, 3,2,1,2,3, 0, 6,5,3,5,6,0, 5,11,11,6,5,6,3,0, 5,2,3,2,1,0 &#125;;//找朋友乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《一分钱》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=51;i++) &#123; t=_yifenqian[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_yifenqian[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《征服》*/void play_zhengfu(void)&#123; int i,t; int _zhengfu[33]=&#123;5,11,7,5,5,6,5,0, 5,11,7,5,6,3,6,0, 6,6,6,5,3,3,4,0, 4,4,4,5,6,3,2,2,0, &#125;;//征服乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《征服》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=32;i++) &#123; t=_zhengfu[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_zhengfu[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《沧海一声笑》*/void play_canghaiyishengxiao(void)&#123; int i,t; int _canghaiyishengxiao[31]=&#123;12,12,1,6,5,4,0, 6,5,4,2,1,0, 1,2,1,2,4,4,5,6,11,0, 12,12,11,6,5,4,5,0 &#125;;//沧海一声笑乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《沧海一声笑》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=30;i++) &#123; t=_canghaiyishengxiao[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_canghaiyishengxiao[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《童话》*/void play_tonghua(void)&#123; int i,t; int _tonghua[46]=&#123;5,4,3,0, 3,4,3,0, 3,4,3,4,3,2,1,0, 1,3,5,6,0, 6,6,5,2,2,4,3,0, 1,3,5,6,0, 6,6,7,6,5,4,3,4,3,2,1,0, &#125;;//童话乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《童话》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=45;i++) &#123; t=_tonghua[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_tonghua[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《同桌的你》*/void play_tongzhuodeni(void)&#123; int i,t; int _tongzhuodeni[71]=&#123;5,5,5,5,3,4,5,7,0, 6,6,6,6,4,6,5,0, 5,5,5,5,7,6,5,4,0, 4,4,4,4,3,2,1,0, 11,11,11,11,5,6,11,11,11,11,0, 12,12,12,12,11,7,6,0, 7,7,7,7,7,11,12,0, 5,0, 7,7,11,12,11,7,11,0, &#125;;//同桌的你乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《同桌的你》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=70;i++) &#123; t=_tongzhuodeni[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_tongzhuodeni[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;/*演奏《小熊和洋娃娃》*/void play_xiaoxiongheyangwawa(void)&#123; int i,t; int _xiaoxiongheyangwawa[77]=&#123;1,0, 2,3,4,5,5,5,4,3,4,4,4,3,2,1,3,5,1,0, 2,3,4,5,5,5,4,3,4,4,4,3,2,1,3,1,6,0, 6,6,5,4,5,5,5,4,3,4,4,4,3,2,1,3,5,6,0, 6,6,5,4,5,5,5,4,3,4,0, 4,4,3,2,1,0, 3,1,0, &#125;;//小熊和洋娃娃乐谱 int notation_frequency(int t); printf(\"请欣赏乐曲《小熊和洋娃娃》……\\n\"); Beep(0,1000);//暂停一秒钟 for (i=0;i&lt;=76;i++) &#123; t=_xiaoxiongheyangwawa[i]; if(t&lt;0) t=-t; t=t%10; if(t==0) printf(\"\\n\"); else printf(\"%d\",t); Beep(notation_frequency(_xiaoxiongheyangwawa[i]),1000); &#125; printf(\"演奏完毕！谢谢欣赏！\\n\");&#125;","categories":[],"tags":[{"name":"乱搞","slug":"乱搞","permalink":"https://gaisaiyuno.github.io/tags/乱搞/"}]},{"title":"BZOJ 3133 [Baltic2013]ballmachine","slug":"BZOJ-3133-Baltic2013-ballmachine","date":"2019-09-15T07:47:14.000Z","updated":"2019-09-15T08:27:50.042Z","comments":true,"path":"archives/d32df71b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d32df71b.html","excerpt":"","text":"传送门 注意到题目条件如果同时有多个点可以走，那么会选择编号最小的节点所在路径的方向。 不妨考虑对树的节点进行一些安排，使得我们按照$dfs$顺序找到的第一个点就是球落到的点。 不要考虑编号最小的节点在的方向，而是考虑从一个点下落的时候，他会选择哪一条边，使得这条路径可以到达编号最小的点。 没错，假设现在的节点是$u$，它的子节点为$v$，它选择的路径就是子树最小值最小的$v$ 于是，可以按照子树最小值的顺序对$u$的子节点$v$进行排序，这样就可以保证我们$dfs$到的第一个没有放球的点就是球下落到的位置，相当于对这棵树进行了重构。 123456789101112inline bool cmp1(const int &amp;a,const int &amp;b)&#123; return mino[a]&lt;mino[b];&#125;void Init(int u)&#123; mino[u]=u; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; Init(v); mino[u]=min(mino[u],mino[v]); &#125; sort(G[u].begin(),G[u].end(),cmp1);&#125; 于是现在重构之后，发现现在按照$dfs$的顺序遍历整棵树，遍历到的顺序就是小球的掉入的顺序。 开始我们维护一个堆，维护的是放球的节点的编号，堆按照先序遍历的顺序排序。 对于插入$num$个小球，就是直接插入。 对于删除，也比较好办，注意到删除一个小球，影响的只是这一条链上面的所有球，于是可以倍增找到同一条链最上面的小球，并且删除，掉下来的小球数量就是他们深度之差。 但是，发现堆并不能$O(\\log n)$删除，反向考虑，堆维护改成没有放球的节点的编号，此时堆按照后序遍历的顺序排序。 对于插入$num$个小球，就是直接$pop$出来堆顶元素。 对于删除，找到最上面的小球，直接插入即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define LOG 25using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int anc[LOG][MAXN],mino[MAXN],dfn[MAXN];vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;inline bool cmp1(const int &amp;a,const int &amp;b)&#123; return mino[a]&lt;mino[b];&#125;struct cmp&#123;bool operator()(const int &amp;a,const int &amp;b)&#123;return dfn[a]&gt;dfn[b];&#125;&#125;;//后序遍历顺序void Init(int u)&#123; mino[u]=u; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; Init(v); mino[u]=min(mino[u],mino[v]); &#125; sort(G[u].begin(),G[u].end(),cmp1);&#125;int cnt;void dfs(int u,int father)&#123; anc[0][u]=father; for (register int i=1;i&lt;LOG;++i) anc[i][u]=anc[i-1][anc[i-1][u]]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; dfs(v,u); &#125; dfn[u]=++cnt;&#125;int inq[MAXN];int main()&#123; int n=read(),q=read(); for (register int i=1;i&lt;=n;++i)&#123; int fa=read(); AddEdge(fa,i); &#125; Init(0); dfs(0,0); priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; Q; for (register int i=1;i&lt;=n;++i) Q.push(i),inq[i]=true;//Q维护没有放球的位置 while (q--)&#123; int opr=read(),num=read(); if (opr==1)&#123; int lst; while (num--)&#123; int u=Q.top();Q.pop(); inq[lst=u]=false; &#125; printf(\"%d\\n\",lst);//输出最后一个小球 &#125; else &#123; int ans=0; for (register int i=LOG-1;i&gt;=0;--i)&#123; if (anc[i][num]&amp;&amp;!inq[anc[i][num]])&#123; ans|=(1&lt;&lt;i);//ans记录深度 num=anc[i][num]; &#125; &#125; inq[num]=true; Q.push(num); printf(\"%d\\n\",ans); &#125; &#125;&#125;","categories":[],"tags":[{"name":"堆","slug":"堆","permalink":"https://gaisaiyuno.github.io/tags/堆/"},{"name":"贪心","slug":"贪心","permalink":"https://gaisaiyuno.github.io/tags/贪心/"},{"name":"倍增","slug":"倍增","permalink":"https://gaisaiyuno.github.io/tags/倍增/"}]},{"title":"LOJ 6435.「PKUSC2018」星际穿越","slug":"LOJ-6435-「PKUSC2018」星际穿越","date":"2019-09-14T08:12:04.000Z","updated":"2019-09-14T09:17:25.840Z","comments":true,"path":"archives/d4c30d8d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d4c30d8d.html","excerpt":"","text":"传送门 为了方便，定义$a[i]=g[i]$。 首先做一次差分，将$\\sum _{y=l} ^r dist(y,x)$变成$\\sum _{y=l}^x dist(y,x) - \\sum _{y=r+1}^x dist(y,x)$ 问题转换为给定$l,r$，求$\\sum_{i=l}^{r-1} dist(i,r)$ 不要从最短路的方向考虑，而是考虑从从$x$点走$k$步能够到达的点是哪些 首先，考虑$k=1$，显然能够到达的点是$[a[x],x-1]$，并且，$k=1$是最少的可能步数，于是$x-&gt;[a[x],x-1]$的最短路已经钦定为$1$了，注意到只有这些点到$x$的步数是$1$，于是以后的任何点到$x$的最短路绝对不是$1$ 考虑$k=2$，（敲黑板），我们巧妙地定义$m[i],p[i]$数组，表示$[i,n]$的点走一步能够走到的最左的点，显然$m[i]=\\min\\{ a[j] \\},(j\\in [i,n]),p[i]$代表这个$j$，之后你就会发现它非常有用。 注意到$m[i]$有一个特殊的性质，$\\forall x \\in [m[i],p[i]-1] $，都能通过道路$p[i]-&gt;x$到达（也是废话，但是最容易忽略） 我们接着证明$[m[a[x],a[x]-1]$的所有点都可以通过$2$条道路从$x$到达： 1.若$p[a[x]] \\in [a[x],x-1]$ 那么可以通过两条道路$x-&gt;p[a[x]] (\\because p[a[x]] \\in [a[x],x-1])$ $p[a[x]] -&gt; \\forall y \\in [m[a[x],a[x]-1] (\\because p[a[x]] &gt;= a[x])$ 到达。 如果这里没有明白请回去看一下刚才说的性质。 2.若$p[a[x]] \\in [x+1,n]$，注意到我们说的性质，$\\forall y \\in [m[a[x]],p[a[x]]-1] $，都可以通过一条道路$p[a[x]-&gt;y$到达，$\\because xp[a[x]]$的道路。于是我们直接从$x-&gt;p[a[x]]$，再$p[a[x]]-&gt; \\forall y \\in [m[a[x],a[x]-1]$即可通过两次到达。 3.若$p[a[x]] = x$ ，显然这样是不行的，因为$a[x] &gt; m[a[i]]$。 考虑$k=3$，记$m[a[x]]=x_1$，所以有$[m[x_1],x_1-1]$的点可以通过$3$次到达。 考虑$k=4$，记$m[a[x_1]]=x_2$，所以有$[m[x_2],x_2-1]$的点可以通过$4$次到达。 …………………… 最终这个最短路序列被分成$[a[x],x-1],[m[a[x]],a[x]-1],[m[m[a[x]]],m[a[x]]-1] , \\cdots , [1, …] $等部分，他们对答案的贡献分别是$1,2,3,4,\\cdots$ 不妨考虑换一种方法记录这个答案，这个答案等价于$x-1+(a[x]-1)+(m[a[x]]-1)+(m[m[a[x]]]-1)+(m[m[m[a[x]]]]-1) \\cdots $ 发现了什么，$m[m[]]$嵌套的格式让我们想起了倍增，于是我们记录$to[i][j]$，代表$m[m[m[…m[j]…]]$的值，其中嵌套了$2^i$个$m[]$ 同样，也要记录$sum[i][j]$，代表上面那个东西的前缀和。 到了最终的问题，如何算出$\\sum_{i=l}^{r-1} dist(i,r)$，考虑到我们在上面的计算过程中重复算了很多值，我们现在要一个一个减去，记$\\min\\{ k,使得m[m[m[..(k个m)..m[x]]]] \\le l \\}$，只有嵌套$\\le k$次的$m[m[ ]]$才会对答案造成贡献，于是我们只要求出前$k$个即可。 而且注意到我们重复算了很多东西，对于$[1,l-1]$的数，每次都会被重复算，于是减去$k*(l-1)$即可。 这样就完了。 注意代码里面有一个小特判，如果$a[r]\\le l$，那么每个数都可以通过一次调到$r$，答案就是$r-l$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define MAXN 300005#define LOG 25using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],m[MAXN];int to[MAXN][LOG],sum[MAXN][LOG];inline int Calc(int l,int r)&#123;//sigma_&#123;i=l&#125;^r-1 dist(i,r) if (a[r]&lt;=l) return (r-1)-l+1; int s=r-1,p=a[r],cnt=0; for (register int i=LOG-1;i&gt;=0;--i)&#123; if (to[p][i]&gt;l)&#123;//可以跳 cnt|=(1&lt;&lt;i); s+=sum[p][i]; p=to[p][i]; &#125; &#125; s+=(p-1),cnt+=2; return s-cnt*(l-1);//去掉前面部分&#125;int main()&#123; int n=read(); for (register int i=2;i&lt;=n;++i) a[i]=read(); m[n]=a[n]; for (register int i=n-1;i&gt;=1;--i)&#123; m[i]=min(m[i+1],a[i]); &#125; for (register int i=1;i&lt;=n;++i) to[i][0]=m[i],sum[i][0]=i-1; for (register int j=1;j&lt;LOG;++j)&#123; for (register int i=1;i&lt;=n;++i)&#123; to[i][j]=to[to[i][j-1]][j-1]; sum[i][j]=sum[i][j-1]+sum[to[i][j-1]][j-1]; &#125; &#125; int q=read(); while (q--)&#123; int l=read(),r=read(),x=read(); int ans=Calc(l,x)-Calc(r+1,x); int down=r-l+1; int g=__gcd(ans,down); printf(\"%d/%d\\n\",ans/g,down/g); &#125;&#125;","categories":[],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://gaisaiyuno.github.io/tags/倍增/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"}]},{"title":"P2048 [NOI2010]超级钢琴","slug":"P2048-NOI2010-超级钢琴","date":"2019-09-13T08:46:53.000Z","updated":"2019-09-13T09:30:53.485Z","comments":true,"path":"archives/5eb0f95d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5eb0f95d.html","excerpt":"","text":"传送门 强烈谴责出题者，题面都花了好几分钟读。 题意： 给你$\\{ A_i\\}$，让你从集合$S=\\{x|x= \\sum _{k=i} ^{j} A[k] , j-i+1 \\in[L,R] \\}$选出$k$个数，使他们的和尽可能大。 首先考虑一件事，如何表示$[i,j]$。 一种思路是枚举区间长度$l$，$l \\in [L,R],[1,l],[2,l+1],[3,l+2] \\cdots$，但是这样不好表示。 另一种思路是枚举左端点$i$，$i \\in [1,n-L+1] , [i,i+L-1],[i,i+L], \\cdots [i,i+R-1]$，这样就有了确定的范围。 我们有一个显然的贪心，要从$S$中选出前$k$大的值。 设$Max(i,j,k)=使\\sum _{p=i} ^a A[p]最大的 a，且a \\in [j,k]$ 考虑$S$中最大值，肯定是$\\sum _{j=i} ^{Max(i,i+L-1,i+R-1)} A[j]$中的一个，根据贪心，我们要取走这个最大值，设这个最大值的$i$为$p_1$，设$Max(p_1,p_1+L-1,p_1+R-1)=p_2$那么取走它之后，显然它会分裂成两个，之后的最大值只可能在$Max(p_1,p_1+L-1, p_2-1),Max(p_1,p_2+1,p_1+R-1)$中取到。 于是由上述性质，我们需要用堆维护，每次将某个数取走之后，将分裂成的两个数$push$进去即可。 这个$Max(i,j,k)$也比较好求，$\\sum _{p=i} ^a A[p] \\Rightarrow sum[a]-sum[i-1]$，用$ST$表维护使$sum[i]$最大的位置即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define LOG 25using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],sum[MAXN],n,k,L,R;namespace RMQ&#123; int pos[LOG][MAXN],lg[MAXN]; inline int cmp(int x,int y)&#123; return sum[x]&lt;sum[y]; &#125; inline void Init()&#123; lg[0]=-1; for (register int i=1;i&lt;MAXN;++i)&#123; lg[i]=lg[i&gt;&gt;1]+1; &#125; for (register int i=1;i&lt;=n;++i) pos[0][i]=i;//注意是位置 for (register int i=1;i&lt;LOG;++i)&#123; for (register int j=1;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; pos[i][j]=max(pos[i-1][j],pos[i-1][j+(1&lt;&lt;(i-1))],cmp); &#125; &#125; &#125; inline int Query(int l,int r)&#123; int k=lg[r-l+1]; return max(pos[k][l],pos[k][r-(1&lt;&lt;k)+1],cmp); &#125;&#125;using namespace RMQ;struct Piano&#123; int p,l,r,m;&#125;;inline Piano make(int p,int l,int r)&#123; return Piano&#123;p,l,r,Query(l,r)&#125;;&#125;inline int Calc(const Piano &amp;A)&#123; return sum[A.m]-sum[A.p-1];&#125;inline bool operator &lt; (const Piano &amp;A,const Piano &amp;B)&#123; return Calc(A)&lt;Calc(B);&#125;int main()&#123; n=read(),k=read(),L=read(),R=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); for (register int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+a[i]; Init(); priority_queue&lt;Piano&gt;Q; for (register int i=1;i&lt;=n-L+1;++i)&#123; Q.push(make(i,i+L-1,min(i+R-1,n))); &#125; long long ans=0; while (k--)&#123; int p=Q.top().p,l=Q.top().l,r=Q.top().r,m=Q.top().m; ans+=Calc(Q.top()); Q.pop(); if (l&lt;m) Q.push(make(p,l,m-1)); if (m&lt;r) Q.push(make(p,m+1,r)); //分裂成两个区间 &#125; printf(\"%lld\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"堆","slug":"堆","permalink":"https://gaisaiyuno.github.io/tags/堆/"},{"name":"倍增","slug":"倍增","permalink":"https://gaisaiyuno.github.io/tags/倍增/"}]},{"title":"P3295 [SCOI2016]萌萌哒","slug":"P3295-SCOI2016-萌萌哒","date":"2019-09-13T07:47:46.000Z","updated":"2019-09-14T04:43:02.885Z","comments":true,"path":"archives/a909c55c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a909c55c.html","excerpt":"","text":"传送门 首先考虑暴力的做法，不要把注意力放在字串上面，考虑$S_{l_1}S_{l_1+1}S_{l_1+2} \\cdots S_{r_1} == S_{l_2}S_{l_2+1}S_{l_2+2} \\cdots S_{r_2}$的意义，就是$S_{l_1}==S_{l_2} \\text{&amp;&amp;} S_{l_1 +1} == S_{l_2+1} \\text{&amp;&amp;} \\cdots \\text{&amp;&amp;} S_{r_1}==S_{r_2}$ 于是考虑并查集，把$l_1,l_2$和$l_1+1,l_2+1 \\cdots$$r_1,r_2$连边，发现一个连通块里面的数字必须是一样的，于是每个连通块里面数字有$10$种选择，但是包含$1$的那个连通块不能为$0$，只有$9$种选择，设连通块个数是$num$，答案就是$9 \\times 10^{num-1}$ 这样时间复杂度$O(n^2 \\alpha(n))$，能够拿$30 pts$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MOD 1000000007using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i) fa[i]=i; &#125; inline int Find(int x)&#123; return fa[x]==x?x:fa[x]=Find(fa[x]); &#125;&#125;using namespace BCJ;int main()&#123; int n=read(),m=read(); Init(); for (register int i=1;i&lt;=m;++i)&#123; int l1=read(),r1=read(),l2=read(),r2=read(); for (register int j=l1;j&lt;=r1;++j)&#123; fa[Find(j)]=Find(j-l1+l2); &#125; &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (fa[i]==i) ans++; &#125; long long ret=9; for (register int i=1;i&lt;=ans-1;++i) ret=(ret*10)%MOD; printf(\"%d\\n\",ret);&#125; 考虑如何优化，肯定是在刚才的并查集上面优化，不妨考虑以空间换时间，我们创建一个二维的并查集数组$f[][]$，其中$f[i][j]$代表$\\forall p \\in [0,2^i-1] , (j+p)和(f[i][j]+p)$之间都有边相连。 考虑如何连边，这个类似于二进制拆分。 1234567for (register int j=LOG-1;j&gt;=0;--j)&#123; int d=(1&lt;&lt;j); if (l1+d-1&lt;=r1)&#123; Merge(l1,l2,j); l1+=d,l2+=d; &#125;&#125; 比方说我们连边$[1,3],[5,7]$如下图： 连完边以后还没有结束，我们现在还不能知道有多少连通块，于是我们要层层下推。 具体来说$ \\text{on } f[j] \\Rightarrow \\text{on } f[j-1] \\text{ &amp;&amp; } \\text{on } f[j-1]$ 这个过程可以类比$\\rm ST$表初始化： 1ST[i][j]=max(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]); 处理完之后，$f[0]$这一层就是我们要的并查集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define LOG 25#define MOD 1000000007using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int f[LOG][MAXN]; inline void Init(int n)&#123; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=0;j&lt;LOG;++j)&#123; f[j][i]=i; &#125; &#125; &#125; inline int Find(int *fa,int x)&#123; return fa[x]==x?x:fa[x]=Find(fa,fa[x]); &#125; inline void Merge(int x,int y,int lev)&#123; int fax=Find(f[lev],x),fay=Find(f[lev],y); if (fax!=fay) f[lev][f[lev][fax]]=f[lev][fay]; &#125;&#125;using namespace BCJ;int main()&#123; int n=read(),m=read(); Init(n); for (register int i=1;i&lt;=m;++i)&#123; int l1=read(),r1=read(),l2=read(),r2=read(); for (register int j=LOG-1;j&gt;=0;--j)&#123; int d=(1&lt;&lt;j); if (l1+d-1&lt;=r1)&#123; Merge(l1,l2,j); l1+=d,l2+=d; &#125; &#125; &#125; for (register int j=LOG-1;j&gt;=1;--j)&#123; int d=(1&lt;&lt;j); for (register int i=1;i+d-1&lt;=n;++i)&#123; int fa=Find(f[j],i); Merge(i,fa,j-1); Merge(i+(d&gt;&gt;1),fa+(d&gt;&gt;1),j-1); &#125; &#125; int ans=0; for (register int i=1;i&lt;=n;++i) ans+=(Find(f[0],i)==i); long long ret=9; for (register int i=1;i&lt;=ans-1;++i) ret=(ret*10)%MOD; printf(\"%d\\n\",ret);&#125; 总结：这道题将多次重复的加边操作通过倍增优化到$O(\\log n)$级别，和线段树优化建图比较像，都是把多个重复的边压成一条，以优化时间/内存。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"倍增","slug":"倍增","permalink":"https://gaisaiyuno.github.io/tags/倍增/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"}]},{"title":"BZOJ 4025 二分图","slug":"BZOJ-4025-二分图","date":"2019-09-08T13:14:36.000Z","updated":"2019-09-08T14:50:38.549Z","comments":true,"path":"archives/86905927.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/86905927.html","excerpt":"","text":"传送门 本题暴力： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int col[MAXN],vis[MAXN];inline void Init()&#123; memset(col,0,sizeof(col)),memset(vis,0,sizeof(vis)); for (register int i=0;i&lt;MAXN;++i) G[i].clear();&#125;vector&lt;int&gt;E[MAXN];int U[MAXN],V[MAXN];inline bool Check(int u)&#123; vis[u]=true; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (vis[v]&amp;&amp;col[v]!=(!col[u])) return false; else if (!vis[v])&#123; col[v]=!col[u]; Check(v); &#125; &#125; return true;&#125;inline void AddE(int j)&#123; for (register int i=0;i&lt;E[j].size();++i)&#123; int id=E[j][i]; AddEdge(U[id],V[id]); AddEdge(V[id],U[id]); &#125;&#125;int main()&#123; int n=read(),m=read(),T=read(); for (register int i=1;i&lt;=m;++i) &#123; U[i]=read(),V[i]=read(); int s=read(),e=read(); for (register int j=s;j&lt;e;++j) E[j].push_back(i); &#125; for (register int i=0;i&lt;T;++i)&#123; Init(); AddE(i); bool flag=true; for (register int j=1;j&lt;=n;++j)&#123; if (!vis[j])&#123; if (!Check(j)) &#123; flag=false; break; &#125; &#125; &#125; puts(flag?\"Yes\":\"No\"); &#125; return 0;&#125; 注意到暴力的时候，我们从$t$转移到$t+1$的时候，可能只会加入少量的边，如果每次$O(n)$计算，会造成大量重复计算。 注意到这张图是二分图等价于这张图里面没有奇环，于是可以并查集维护，维护每个点到它的父亲节点的距离，注意要支持可撤销，所以需要启发式合并。 不妨换一个思路，对于一个时刻$t$，只有$t \\in [s,e]$，$[s,e]$区间里面的加边操作才能对答案产生影响，这个结论可以推广，对于时间在$[l,r]$的答案（不妨在这段答案全部都是$\\rm Yes$或者$\\rm No$），只有$[l,r] \\in [s,e]$，$[s,e]$区间里面的操作才会对答案产生影响，于是我们想要查询$[l,r]$的答案时，先要把$[l,r] \\in [s,e]$的操作全部做完，如果操作做完之后，产生奇环，那么就把这段区间的答案全部设成$\\rm No$，并且撤销并查集。 这样说得有点玄学，为甚假定答案都是一样的呢，看不懂没有关系，请继续往下： 考虑一个类似于线段树的分治结构，$Solve(l,r,E)$表示总的边集为$E$，求解$[l,r]$区间的答案，如果按照上面所说地加边，出现奇环，那么将$[l,r]$的答案设成$\\rm No$，撤销并查集，退出递归，因为之后不管怎么加边，都不可能将这个图变回二分图，如果没有出现奇环，找出来所有$s \\le mid$的边，加入左边的集合$L$，$e &gt; mid$的边加入右边的集合$R$，递归求解$Solve(l,mid,L),Solve(mid+1,r,R)$。 看到这里你应该明白了，其实这个递归过程是把答案序列按照线段树建树的模式分成许多段，每段答案都是$\\rm No$， 如图所示，标成红色代表这段答案都是$\\rm No$，停止递归，标成灰色代表这段根本递归不到，标成绿色代表确定了答案是$\\rm Yes$（绿色只在叶子节点有），标成蓝色代表不知道这段答案是$\\rm Yes$还是$\\rm No$。 这样为什么是正确的呢，因为对于所有$s\\le l,e \\geq r$，都被算在并查集里面，递归求解$Solve(l,mid,L)$的时候，发现只要考虑$s \\le l,e \\in [mid+1,r)$的边，（其他的情况就是$s \\le l ,e \\geq r$，在上面的递归里面算到了），刚好是我们加进$L$的边，但是注意到我们加进$L$的不是$e &gt; mid$的边，为什么呢，发现我们还要照顾到$s \\le mid$的边，虽然这些边不一定在下一次递归会加入并查集，但是在更深层的递归就可能，不能把他们漏掉。 时间复杂度分析：注意到每条边至多算一次，于是时间复杂度$O(n \\log ^2 n)$（启发式合并还有一个$\\log $） 这样使用线段树，巧妙地减少了加边的次数。 接下来考虑并查集如何实现 注意到我们要使$\\forall w \\in subtree(fa(u))$，$v -&gt; fa(v) -&gt; fa(u) -&gt; w$和$v -&gt; u -&gt; w$长度在$\\mod 2$意义上面是相等的。 于是$dep(v)+val[fa(v)]+dep(w)\\equiv 1+dep(u)+dep(w)-dep(LCA(u,w)) \\times 2 \\pmod{2}$ 化一下：$val[fa(v)]\\equiv dep(u)-dep(v)+1 \\pmod{2}$ 这个式子等价于$val[fa(v)]\\equiv dep(u)+dep(v)+1 \\pmod{2}$ 注意到我们还有一个条件要满足： $\\forall w \\in subtree(fa(v))$，$u -&gt; fa(u) -&gt; fa(v) -&gt; w$和$u -&gt; v -&gt; w$长度在$\\mod{2}$意义上面相等，把上面的式子带入，发现也是成立的，于是发现我们的式子很好地把两个条件都满足了 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; #define P pair&lt;int,int&gt; #define mp make_pair int fa[MAXN],sz[MAXN],val[MAXN]; inline void Init(int n)&#123; for (register int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1; &#125; int GetDep(int i)&#123; return fa[i]==i?val[i]:GetDep(fa[i])+val[i]; &#125; int Find(int i)&#123; return fa[i]==i?i:Find(fa[i]); &#125; inline bool Merge(int u,int v,stack&lt;P&gt; &amp;s)&#123;//形成奇环return false，else return true int tu=u,tv=v; u=Find(u),v=Find(v); if (u==v)&#123; return !((GetDep(tu)+GetDep(tv))%2==0); &#125; if (sz[u]&lt;sz[v]) swap(u,v); sz[u]+=sz[v],fa[v]=u; val[v]=GetDep(tu)+GetDep(tv)+1; s.push(mp(u,v)); return true; &#125; inline void Reverse(stack&lt;P&gt; &amp;s)&#123;//回溯 while (s.size())&#123; int u=s.top().first,v=s.top().second; fa[v]=v,sz[u]-=sz[v],val[v]=0; s.pop(); &#125; &#125;&#125;using namespace BCJ;struct Edge&#123; int u,v,l,r;&#125;;int Ans[MAXN];void Solve(int l,int r,vector&lt;Edge&gt; &amp;A)&#123; vector&lt;Edge&gt;L,R; stack&lt;P&gt;s;//用来撤销的栈 bool flag=true; int mid=(l+r)&gt;&gt;1; for (register int i=0;i&lt;A.size();++i)&#123; if (A[i].l&lt;=l&amp;&amp;r&lt;=A[i].r)&#123;//只要记录跨越左右的边 if (!Merge(A[i].u,A[i].v,s))&#123; for (register int i=l;i&lt;=r;++i) Ans[i]=0;//这样不用递归下去，因为都是0 flag=false; break; &#125; &#125; else &#123; if (A[i].l&lt;=mid) L.push_back(A[i]); if (A[i].r&gt;mid) R.push_back(A[i]); &#125; &#125; if (flag&amp;&amp;l&lt;r)&#123;Solve(l,mid,L);Solve(mid+1,r,R);&#125; Reverse(s);//回溯&#125;int main()&#123; int n=read(),m=read(),T=read(); vector&lt;Edge&gt;A; for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),l=read(),r=read(); A.push_back(Edge&#123;u,v,l+1,r&#125;); &#125; Init(n); for (register int i=1;i&lt;=T;++i) Ans[i]=true; Solve(1,T,A); for (register int i=1;i&lt;=T;++i) puts(Ans[i]?\"Yes\":\"No\");&#125; 总结：这类和时间/区间有关的题目大多数要用到线段树分治。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"分治","slug":"分治","permalink":"https://gaisaiyuno.github.io/tags/分治/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://gaisaiyuno.github.io/tags/启发式合并/"}]},{"title":"P4197 Peaks","slug":"P4197-Peaks","date":"2019-09-08T12:54:30.000Z","updated":"2019-09-08T13:09:27.739Z","comments":true,"path":"archives/897ab7a0.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/897ab7a0.html","excerpt":"","text":"传送门 这道题其实就是P4185 [USACO18JAN]MooTube和P3224 [HNOI2012]永无乡的结合。 看到第$k$高，就要想到主席树，但是考虑到题目条件：只经过困难值小于等于x的路径，于是考虑离线操作，把询问和边按照边权从小到大排序，来了一个边权为$x$的询问，只要把$ \\le x$的边全部连上，同时合并两个连通块所代表的主席树即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],rt[MAXN];namespace SegmentTree&#123; struct node&#123; int cnt; int l,r; &#125;tree[MAXN*50]; inline void pushup(int i,int lson,int rson)&#123; tree[i].cnt=tree[lson].cnt+tree[rson].cnt; &#125; int tot; void Update(int &amp;i,int l,int r,int index)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].cnt=1; return ; &#125; int mid=(l+r)&gt;&gt;1; if (index&lt;=mid) Update(tree[i].l,l,mid,index); else Update(tree[i].r,mid+1,r,index); pushup(i,tree[i].l,tree[i].r); &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; pushup(x,x,y); tree[x].l=Merge(tree[x].l,tree[y].l); tree[x].r=Merge(tree[x].r,tree[y].r); tree[y].l=tree[y].r=0; return x; &#125; int Query(int i,int l,int r,int k)&#123; if (l==r)&#123; return l; &#125; int mid=(l+r)&gt;&gt;1; if (tree[tree[i].l].cnt&gt;=k) return Query(tree[i].l,l,mid,k); else return Query(tree[i].r,mid+1,r,k-tree[tree[i].l].cnt); &#125;&#125;;using namespace SegmentTree;struct Edge&#123; int u,v,len;&#125;E[MAXN];int cnte;inline bool operator &lt; (const Edge &amp;A,const Edge &amp;B)&#123; return A.len&lt;B.len;&#125;inline void AddEdge(int u,int v,int w)&#123; E[++cnte]=Edge&#123;u,v,w&#125;;&#125;struct query&#123; int u,x,k,id;&#125;Q[MAXN];int cntq;inline bool operator &lt; (const query &amp;A,const query &amp;B)&#123; return A.x&lt;B.x;&#125;inline void AddQuery(int u,int x,int k,int id)&#123; Q[++cntq]=query&#123;u,x,k,id&#125;;&#125;namespace BCJ&#123; int fa[MAXN],sz[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i) fa[i]=i,sz[i]=1; &#125; int Find(int i)&#123; return fa[i]==i?i:fa[i]=Find(fa[i]); &#125;&#125;using namespace BCJ;inline void Union(int u,int v)&#123; int fau=Find(u),fav=Find(v); if (fau==fav) return ; fa[fav]=fau; sz[fau]+=sz[fav]; sz[fav]=0; rt[fau]=Merge(rt[fau],rt[fav]);&#125;int n,m,q,b[MAXN];inline void discrete()&#123; for (register int i=1;i&lt;=n;++i) b[i]=a[i]; sort(b+1,b+1+n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b; &#125;&#125;int id[MAXN],Ans[MAXN];int main()&#123; n=read(),m=read(),q=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; discrete(); for (register int i=1;i&lt;=n;++i)&#123; Update(rt[i],1,n,a[i]); id[a[i]]=i; &#125; for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); &#125; sort(E+1,E+1+m); for (register int i=1;i&lt;=q;++i)&#123; int v=read(),x=read(),k=read(); AddQuery(v,x,k,i); &#125; sort(Q+1,Q+1+q); Init(); int pos=1; for (register int i=1;i&lt;=q;++i)&#123; while (pos&lt;m&amp;&amp;E[pos].len&lt;=Q[i].x) &#123;//连边 Union(E[pos].u,E[pos].v); pos++; &#125; int k=Q[i].k,t=Find(Q[i].u); if (sz[t]&lt;k) Ans[Q[i].id]=-1; else Ans[Q[i].id]=b[Query(rt[t],1,n,sz[t]-k+1)]; &#125; for (register int i=1;i&lt;=q;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; 有兴趣可以看一看这一道题P5443 [APIO2019]桥梁 是上面离线思想加上分块的一道大毒瘤好题","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://gaisaiyuno.github.io/tags/线段树合并/"}]},{"title":"P3302 [SDOI2013]森林","slug":"P3302-SDOI2013-森林","date":"2019-09-08T12:29:08.000Z","updated":"2019-09-08T12:50:00.180Z","comments":true,"path":"archives/2836f18e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2836f18e.html","excerpt":"","text":"查询第$k$大/小，首先想到主席树，每棵主席树记录当前节点到根节点的路径上面的所有值，每次查询$u,v$，我们使用第$u,v,LCA(u,v),fa[LCA(u,v)]$棵主席树，做一次差分即可。 主要是如何实现连边，最暴力的方式是把$y$所在的联通块的节点全部一个一个连到$x$上面，同时为了实现查询操作，还要更新$LCA$。 考虑优化，注意到只有加边操作，于是可以用启发式合并在$O(\\log^2 n)$的时间内实现。 使用并查集，目的是为了获得连通块的大小，以便启发式合并，并查集里面可以路径压缩。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define LOG 35using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN],n,m,q;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i) b[i]=a[i]; sort(b+1,b+1+n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b; &#125;&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int cnt; &#125;tree[MAXN*LOG]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void pushup(int i,int lson,int rson)&#123; tree[i].cnt=tree[lson].cnt+tree[rson].cnt; &#125; void Build(int &amp;i,int l,int r)&#123; i=++tot; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc(i),l,mid); Build(rc(i),mid+1,r); &#125; void Update(int &amp;i,int pre,int l,int r,int index)&#123; tree[i=++tot]=tree[pre]; tree[i].cnt++; if (l==r) return void(); int mid=(l+r)&gt;&gt;1; if (index&lt;=mid) Update(lc(i),lc(pre),l,mid,index); else Update(rc(i),rc(pre),mid+1,r,index); &#125; int Query(int rt1,int rt2,int rt3,int rt4,int l,int r,int k)&#123; if (l==r) return l; int mid=(l+r)&gt;&gt;1,cnt=tree[lc(rt1)].cnt+tree[lc(rt2)].cnt-tree[lc(rt3)].cnt-tree[lc(rt4)].cnt; if (k&lt;=cnt) return Query(lc(rt1),lc(rt2),lc(rt3),lc(rt4),l,mid,k); else return Query(rc(rt1),rc(rt2),rc(rt3),rc(rt4),mid+1,r,k-cnt); &#125; void Merge(int &amp;rt,int x,int y)&#123; if (!x||!y) return rt=x+y,void(); pushup(rt=++tot,x,y); Merge(lc(rt),lc(x),lc(y)); Merge(rc(rt),rc(x),rc(y)); &#125;&#125;using namespace SegmentTree;void dfs(int,int,int);inline void AddEdge(int,int);namespace BCJ&#123; int fa[MAXN],sz[MAXN]; inline void Init()&#123; for (register int i=1;i&lt;=n;++i) fa[i]=i; &#125; int Find(int i)&#123; return fa[i]==i?i:fa[i]=Find(fa[i]); &#125; inline void Add(int u,int v)&#123; AddEdge(u,v); AddEdge(v,u); int fau=Find(u),fav=Find(v); if (sz[fau]&lt;sz[fav]) swap(u,v),swap(fau,fav); dfs(v,u,fau); &#125; inline void Union(int u,int v)&#123; fa[Find(u)]=Find(v); &#125;&#125;using namespace BCJ;vector&lt;int&gt;G[MAXN];int anc[MAXN][LOG],dep[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int vis[MAXN];void dfs(int u,int father,int r)&#123; Update(rt[u],rt[father],1,n,a[u]); vis[u]=true,sz[r]++,fa[u]=father;//注意此时的fa为并查集的fa anc[u][0]=father; dep[u]=dep[father]+1; for (register int i=1;i&lt;LOG;++i) anc[u][i]=anc[anc[u][i-1]][i-1]; for (register int i=0;i&lt;(int)G[u].size();++i)&#123; int v=G[u][i]; if (v==father) continue; dfs(v,u,r); &#125;&#125;inline int LCA(int u,int v)&#123; if (u==v) return u; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=LOG-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; &#125; if (u==v) return u; for (register int i=LOG-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i]) u=anc[u][i],v=anc[v][i]; &#125; return anc[u][0];&#125;inline void Solve()&#123; n=read(),m=read(),q=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); discrete(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; Init(); for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i])&#123;dfs(i,0,i);fa[i]=i;&#125; &#125; int lstans=0; char ch[3]; for (register int i=1;i&lt;=q;++i)&#123; scanf(\"%s\",ch); int u=read()^lstans,v=read()^lstans; if (ch[0]=='Q')&#123; int k=read()^lstans; int lca=LCA(u,v); printf(\"%d\\n\",lstans=b[Query(rt[u],rt[v],rt[lca],rt[anc[lca][0]],1,n,k)]); &#125; else &#123; Add(u,v); &#125; &#125;&#125;int main()&#123; int T=read(); Solve();&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://gaisaiyuno.github.io/tags/启发式合并/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"}]},{"title":"BZOJ 4668 冷战","slug":"BZOJ-4668-冷战","date":"2019-09-08T12:18:47.000Z","updated":"2019-09-08T12:28:11.205Z","comments":true,"path":"archives/45b67070.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/45b67070.html","excerpt":"","text":"传送门 注意到一个性质，如果加入的边$$已经在连通块里面，发现连通块任意两点都是联通的，于是加入边并不会对答案有任何影响，我们就不加入这一条边。 于是发现这张图在任意时刻都是一个森林，森林就比较好办，考虑记录加入边的时间$tim[]$，于是答案即是$\\max\\{ tim[w] ,w \\in route(u,v)\\}$，$route(u,v)$表示$u,v$之间的路径，于是从$u,v$两点分别往上跳并且记录最大值，跳到$lca$为止。 考虑到这样会超时，不妨考虑启发式合并，于是每次查询均摊$\\log (n)$，可以AC。 注意异或不要少了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; static int fa[MAXN],sz[MAXN],dep[MAXN],tim[MAXN]; inline void Init(int n)&#123; for (int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1; &#125; int Find(int i)&#123; return fa[i]==i?i:Find(fa[i]); &#125; int InitDep(int i)&#123; return (fa[i]==i)?(dep[i]):(dep[i]=(InitDep(fa[i])+1)); &#125; inline void Merge(int t,int u,int v)&#123; u=Find(u),v=Find(v); if (u==v) return ; if (sz[u]&lt;sz[v]) swap(u,v);//v -&gt; u sz[u]+=sz[v]; fa[v]=u; tim[v]=t;//连边时间 &#125; inline int Query(int u,int v)&#123; if (InitDep(u)&lt;=InitDep(v)) swap(u,v); int ans=0; while (dep[u]&gt;dep[v]) ans=max(ans,tim[u]),u=fa[u]; if (u==v) return ans; while (u!=v) ans=max(ans,max(tim[u],tim[v])),u=fa[u],v=fa[v]; return ans; &#125;&#125;using namespace BCJ;int main()&#123; int n=read(),m=read(); Init(n); int lstans=0,cnt=0; while (m--)&#123; int opr=read(),u=read()^lstans,v=read()^lstans; if (opr==0) &#123; Merge(++cnt,u,v); &#125; else &#123; if (Find(u)!=Find(v)) printf(\"%d\\n\",lstans=0); else printf(\"%d\\n\",lstans=Query(u,v)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"}]},{"title":"音乐爬虫","slug":"音乐爬虫","date":"2019-09-08T12:12:30.000Z","updated":"2019-09-08T12:14:32.556Z","comments":true,"path":"archives/b701d16.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b701d16.html","excerpt":"","text":"自己没事写了一个爬虫。 介绍missevan爬虫，可以当做Aplayer自定义来源 使用说明1.编辑config.ini download代表要不要下载，如果要下载，程序将把封面和mp3文件下载到当前路径的cover和mp3目录 outfile代表输出文件，如music.js usetitle代表是否自定义文件标题，默认使用原标题进行歌词查找。 server代表音乐网站服务器，用来搜索歌词 取值 含义 netease 网易云 tencent QQ音乐 xiami 虾米 kugou 酷狗 maxlrc代表最多显示的歌词条数。 2.输入url后面?id=……的一串数字。 3.如果你要自定义标题，请输入标题，程序会自动搜索歌词和作者。 4.输入e结束后，程序自动写入music.js，如图所示： 下载链接","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]},{"title":"Codeforces Round #583 (Div. 1 + Div. 2, based on Olympiad of Metropolises)","slug":"Codeforces-Round-583-Div-1-Div-2-based-on-Olympiad-of-Metropolises","date":"2019-09-07T14:21:46.000Z","updated":"2019-09-07T14:59:46.933Z","comments":true,"path":"archives/dfe225c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/dfe225c.html","excerpt":"","text":"比赛传送门 $Pro1$A. Optimal Currency Exchange $Sol1$根据贪心的原则，我们只用选择1元的欧元和5元的美元，注意到$d \\le 100,e \\le 100$，所以$O(n/e)$枚举即可。 $Code1$12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define int long longinline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;using namespace std;#undef intint main()&#123;#define int long long int n=read(); int d=read(),e=read()*5; int ans=0x7fffffff; for (register int i=0;i&lt;=n/e;++i)&#123; ans=min(ans,(n-(i*e))%d); &#125; printf(\"%I64d\\n\",ans);&#125; $Pro2$B. Badges $Sol2$这道题纯粹是在考英语吧，只要$i \\le b$而且$n-i \\le g$都是合法方案，于是枚举即可。 $Code2$123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAXN 500005inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;using namespace std;int main()&#123; int b=read(),g=read(),n=read(); int ans=0; for (register int i=0;i&lt;=n;++i)&#123; int x=i,y=n-i; if (x&lt;=b&amp;&amp;y&lt;=g)&#123; ans++; &#125; &#125; printf(\"%d\\n\",ans);&#125; $Pro3$C. Bad Sequence 给你一个括号序列，你可以把一个括号移到括号序列的任意一个位置，问能不能是括号全部匹配。 $Sol3$我们有一个关于括号序列的结论，如果现在的字符是$”(“$，那么把它入栈，如果现在的字符是$”)”$，就把栈顶弹出，如果现在没有元素可以弹走，那么括号不匹配，如果这样扫一遍之后，都可以弹出，那么括号序列可以匹配。 转到此题，首先判断左右括号是否数量相同，发现我们有一次添加左括号的机会，于是记录没有元素可以弹走次数，如果$\\geq 2$，那么输出$\\rm No$，剩下输出$\\rm Yes$ $Code3$1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define MAXN 200005inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;using namespace std;char ch[MAXN];int main()&#123; int n=read(); scanf(\"%s\",ch); int ans1=0,ans2=0; for (register int i=0;i&lt;n;++i)&#123; if (ch[i]=='(') ans1++; else ans2++; &#125; if (ans1!=ans2) return puts(\"No\"),0; int cnt1=0,cnt2=0; int cnt=0; for (register int i=0;i&lt;n;++i)&#123; if (ch[i]=='(') cnt1++; else&#123; if (cnt1&gt;0) cnt1--; else cnt++; &#125; &#125; if (cnt&lt;=1) return puts(\"Yes\"),0; else return puts(\"No\"),0;&#125; $Pro4$D. Treasure Island 给你一个地图，标有.的地方可以走，标有#的地方不能走，要你添加尽量少的#使得左上角不能走到右下角。 $Sol4$注意到只要把起点相邻的两个格子全部封住，就可以了，于是答案只能是0,1,2其中一个。 分情况讨论，如果答案是0，那么原来就不能从左下角走到右下角。 如果答案是1，说明从左下角走到右下角只有一条唯一的路径，怎么判断，我们先从起点dfs一次，把路径上面所以的点都标成#，然后再dfs一次，如果没有路径可以走，那么答案是1，如果还有路径可走，那么答案是$2$ $Code4$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAXN 1000005inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;using namespace std;char ch[MAXN];vector&lt;int&gt;G[MAXN];int n,m;inline bool Inside(int x,int y)&#123; return x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m;&#125;vector&lt;int&gt;Mark[MAXN];bool dfs(int x,int y)&#123; if (Mark[x][y]==1) return false; if (G[x][y]==1) return false; if (x==n-1&amp;&amp;y==m-1) return true; if (Inside(x+1,y)&amp;&amp;!G[x+1][y])&#123; if (dfs(x+1,y)==true) return Mark[x+1][y]=true; Mark[x+1][y]=true; &#125; if (Inside(x,y+1)&amp;&amp;!G[x][y+1])&#123; if (dfs(x,y+1)==true) return Mark[x][y+1]=true; Mark[x][y+1]=true; &#125; return false;&#125;int main()&#123; n=read(),m=read(); for (register int i=0;i&lt;n;++i)&#123; scanf(\"%s\",ch); for (register int j=0;j&lt;m;++j)&#123; G[i].push_back(ch[j]=='#'); &#125; &#125; for (register int i=0;i&lt;n;++i)&#123; Mark[i].resize(m); &#125; int ans=dfs(0,0); if (ans==false) return puts(\"0\"),0; for (register int i=0;i&lt;n;++i)&#123; for (register int j=0;j&lt;m;++j)&#123; if (Mark[i][j]) G[i][j]=true; Mark[i][j]=0; &#125; &#125; G[0][0]=false; G[n-1][m-1]=false; if (dfs(0,0)==false) return puts(\"1\"),0; else return puts(\"2\"),0;&#125;","categories":[],"tags":[{"name":"比赛","slug":"比赛","permalink":"https://gaisaiyuno.github.io/tags/比赛/"}]},{"title":"Aplayer test","slug":"Aplayer-test","date":"2019-09-07T06:25:55.000Z","updated":"2019-09-07T06:30:54.814Z","comments":true,"path":"archives/ba73d53d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ba73d53d.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"P5290 [十二省联考2019]春节十二响","slug":"P5290-十二省联考2019-春节十二响","date":"2019-09-05T13:59:14.000Z","updated":"2019-09-05T14:42:18.972Z","comments":true,"path":"archives/5c8cefc6.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5c8cefc6.html","excerpt":"","text":"传送门 如果是一条链，我们将这条链从$1$节点提起来，显然我们不能选择同时选择左半部分或者右半部分的两个点放在一组，于是我们有如下思路：左半部分的点和右半部分的点两两配对，剩下的点（包括$1$）自成一组。 考虑如何使结果最小，肯定是左半部分最大值和右半部分最大值配对，第二大值互相配对，第三大值互相配对…… 正确性怎么证明，考虑我们把$x_1,y_1$和$x_2,y_2$互相配对，需要证明的是$x_1 \\le x_2$且$y_1 \\le y_2$时，$ans=\\max(x_1,y_1)+\\max(x_2,y_2)$有最小值。 为了方便证明，我们这里设$x_1 \\le x_2$且$y_1 \\le y_2$，接下来说明交换$x_1,x_2$或者交换$y_1,y_2$答案不会减少。 我们这里只讨论两种情况，剩下两种请读者自行推导。 $1. y_1 \\le x_1 \\le x_2 \\le y_2$ $ans=x_1 +y_2$ $swap(x_1,x_2)$：$ans \\Rightarrow x_2 + y_2 \\geq x_1 + y_2$ $swap(y_1,y_2)$：$ans \\Rightarrow x_2 + y_2 \\geq x_1+y_2$ $2. x_1 \\le y_1 \\le x_2 \\le y_2$ $ans=y_1 +y_2$ $swap(x_1,x_2)$：$ans \\Rightarrow x_1 + y_2 \\geq y_1+y_2$ $swap(y_1,y_2)$：$ans \\Rightarrow y_2 + x_2 \\geq y_1+y_2$ 于是我们发现这样贪心是最优的，我们把左半部分的所有点和右半部分的所有点从大到小排序，依次配对即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int M[MAXN],f[MAXN];vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int a[MAXN],b[MAXN];int cnt1,cnt2;void dfs(int u,int father,int chain)&#123; if (chain!=-1)&#123; if (chain==0) a[++cnt1]=M[u]; else b[++cnt2]=M[u]; &#125; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v==father) continue; if (chain==-1) dfs(v,u,i); else dfs(v,u,chain); &#125;&#125;inline int cmp(int a,int b)&#123;return a&gt;b;&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;=n;++i) M[i]=read(); for (register int i=2;i&lt;=n;++i) &#123; f[i]=read(); AddEdge(i,f[i]); AddEdge(f[i],i); &#125; dfs(1,1,-1); sort(a+1,a+1+cnt1,cmp); sort(b+1,b+1+cnt2,cmp); int ans=0; for (register int i=1;i&lt;=min(cnt1,cnt2);++i)&#123; ans+=max(a[i],b[i]); &#125; if (cnt1&lt;cnt2) for (register int i=cnt1+1;i&lt;=cnt2;++i) ans+=b[i]; else for (register int i=cnt2+1;i&lt;=cnt1;++i) ans+=a[i]; printf(\"%lld\\n\",ans+M[1]);&#125; 这样我们就得到了$20pt$ 这个思路推广一下就可以得到正解（我就是没有想到） 不妨把求解的过程看成将链不断合并的过程，一开始我们总是能够找到一个节点，它的左子树和右子树都是一条链，然后将这个节点和左子树右子树一起合并成一个大的链即可。 这样说有点抽象，不妨看图： 根据上面我们的贪心，我们需要维护链的有序性，于是使用堆维护，合并的时候就可以从两个堆的顶上依次pop出元素，取最大值，注意到我们需要使用启发式合并： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;priority_queue&lt;int&gt;Q[MAXN];int stk[MAXN],top;inline void Merge(int x,int y)&#123;//Merge x to y if (Q[x].size()&gt;Q[y].size()) swap(Q[x],Q[y]); top=0; while (Q[x].size())&#123; stk[++top]=max(Q[x].top(),Q[y].top()); Q[x].pop(),Q[y].pop(); &#125; for (register int i=1;i&lt;=top;++i) Q[y].push(stk[i]);&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int M[MAXN];void dfs(int u,int father)&#123; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father) dfs(v,u),Merge(v,u); &#125; Q[u].push(M[u]);&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i) M[i]=read(); for (register int i=2;i&lt;=n;++i)&#123; int f=read(); AddEdge(i,f); AddEdge(f,i); &#125; dfs(1,1); long long ans=0; while (Q[1].size()) ans+=Q[1].top(),Q[1].pop(); printf(\"%lld\\n\",ans);&#125; 细心的读者一定会发现，其实$Merge$函数对应的就是上面链情况的代码： 123456int ans=0;for (register int i=1;i&lt;=min(cnt1,cnt2);++i)&#123; ans+=max(a[i],b[i]);&#125;if (cnt1&lt;cnt2) for (register int i=cnt1+1;i&lt;=cnt2;++i) ans+=b[i];else for (register int i=cnt2+1;i&lt;=cnt1;++i) ans+=a[i];","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"堆","slug":"堆","permalink":"https://gaisaiyuno.github.io/tags/堆/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://gaisaiyuno.github.io/tags/启发式合并/"}]},{"title":"P4211 [LNOI2014]LCA","slug":"P4211-LNOI2014-LCA","date":"2019-09-01T04:12:27.000Z","updated":"2019-09-01T04:36:31.321Z","comments":true,"path":"archives/da799c8c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/da799c8c.html","excerpt":"","text":"传送门 考虑离线+差分。 将$\\sum _{l \\le i \\le r} dep[LCA(i,z)]$转化成$\\sum _{1 \\le i \\le r} dep[LCA(i,z)]-\\sum _{1 \\le i \\le l-1} dep[LCA(i,z)]$ （代码里面下标整体+1，所以略有出入） 仔细观察，发现$LCA(i,z)$都在$z$到根节点的路径上面，我们转化概念，$dep[u]$其实上是$u$上面节点的个数$+1$，于是我们有了思路：将$i$到根节点路径上面节点全部+1，$z$到根节点上面所有节点权值之和就是$dep[LCA(i,z)]$。 这样有什么好处，首先，我们去掉了$LCA$，其次，这个东西可以树剖维护，因为它具有可加性。 于是实现非常简单，只要支持链+1，链求和即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;#define MOD 201314#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int sz[MAXN],big[MAXN],fa[MAXN],top[MAXN],dep[MAXN];void dfs1(int u)&#123; sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=fa[u])&#123; dep[v]=dep[u]+1; dfs1(v); sz[u]+=sz[v]; if (sz[big[u]]&lt;sz[v]) big[u]=v; &#125; &#125;&#125;int seq[MAXN],cnt;void dfs2(int u,int t)&#123; seq[u]=++cnt; top[u]=t; if (big[u]) dfs2(big[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=fa[u]&amp;&amp;v!=big[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; inline int len()&#123;return r-l+1;&#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Change(int i,int v)&#123; tree[i].val=(tree[i].val+v*tree[i].len()%MOD)%MOD; tree[i].tag=(tree[i].tag+v)%MOD; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag),Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; inline void pushup(int i)&#123; tree[i].val=(tree[lc].val+tree[rc].val)%MOD; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].val=tree[i].tag=0; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; pushdown(i); if (L&lt;=mid) ans=(ans+Query(lc,L,R))%MOD; if (mid&lt;R) ans=(ans+Query(rc,L,R))%MOD; return ans; &#125;&#125;using namespace SegmentTree;inline void Update_Chain(int u,int v)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; Update(1,seq[top[u]],seq[u],1); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); Update(1,seq[u],seq[v],1);&#125;inline int Query_Chain(int u,int v)&#123; int ans=0; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; ans=(ans+Query(1,seq[top[u]],seq[u]))%MOD; u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); return (ans+Query(1,seq[u],seq[v]))%MOD;&#125;int n;inline void Init()&#123; dep[1]=1; dfs1(1); dfs2(1,1); Build(1,1,n);&#125;struct Q&#123; int pos,flag,z,id;&#125;q[MAXN&lt;&lt;2];int ans[MAXN];inline bool operator &lt; (const Q &amp;A,const Q &amp;B)&#123; return A.pos&lt;B.pos;&#125;int tot;int main()&#123; n=read();int m=read(); for (register int i=2;i&lt;=n;++i)&#123; int f=read()+1; fa[i]=f; AddEdge(f,i); &#125; Init(); for (register int i=1;i&lt;=m;++i)&#123; int l=read(),r=read()+1,z=read()+1; q[++tot]=Q&#123;l,-1,z,i&#125;; q[++tot]=Q&#123;r,1,z,i&#125;; &#125; sort(q+1,q+1+tot); int now=0;//现在加入到那个点 for (register int i=1;i&lt;=tot;++i)&#123; while (now&lt;q[i].pos)&#123; Update_Chain(1,++now); &#125; ans[q[i].id]+=Query_Chain(1,q[i].z)*q[i].flag; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",(ans[i]+MOD)%MOD); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P3899 [湖南集训]谈笑风生","slug":"P3899-湖南集训-谈笑风生","date":"2019-09-01T02:03:00.000Z","updated":"2019-09-01T02:28:02.365Z","comments":true,"path":"archives/f1f2b3e9.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/f1f2b3e9.html","excerpt":"","text":"传送门 你们搞的这道题啊，exciting。 首先，看到标题我们就知道用什么算法实现，于是我们使用主席树。 容易发现，$a,b$和$c$都在同一条到根节点的链上面，而且$c$是这条链最下面的节点，但是$a,b$关系未知。 于是分类讨论： $1.b \\in anc(a)$，发现$c \\in subtree(a),dis(a,b) \\le k$，发现$c$有$sz[a]-1$种选择，$b$有$\\min(k,dep[a]-1)$，这里$dep[rt]=1$ 于是乘法原理相乘即可。 1(sz[u]-1)*min(k,dep[u]-1) $2.a \\in anc(b)$，这种情况比较复杂， 注意到$dis(a,b) \\le k$，所以$b$能够选择的区域类似于红色区域。 选择好$b$以后，发现$c \\in subtree(b)$于是每选择一个$b$会对答案产生$sz[b]-1$的贡献。 于是答案即是$\\sum _{u ,dep[u] \\in [dep[a],dep[a]+k]}(sz[u]-1)$ 考虑每个节点开一棵主席树，对于下标为$d$的位置，维护$\\sum _{u,dep[u]=d} (sz[u]-1)$，于是每次查询区间求和即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MAXN 300005#define LOG 55#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val; &#125;tree[MAXN*LOG]; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void pushup(int i,int lson,int rson)&#123; tree[i].val=tree[lson].val+tree[rson].val; &#125; int tot; void Update(int &amp;i,int l,int r,int index,int val)&#123; if (!i) i=++tot; if (l==r) return tree[i].val+=val,void(); int mid=(l+r)&gt;&gt;1; if (index&lt;=mid) Update(lc(i),l,mid,index,val); else Update(rc(i),mid+1,r,index,val); pushup(i,lc(i),rc(i)); &#125; int Query(int i,int l,int r,int L,int R)&#123; if (!i) return 0; if (L&lt;=l&amp;&amp;r&lt;=R) return tree[i].val; int mid=(l+r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans+=Query(lc(i),l,mid,L,R); if (mid&lt;R) ans+=Query(rc(i),mid+1,r,L,R); return ans; &#125; void Merge(int &amp;rt,int x,int y)&#123;//注意Merge要新建节点 if (!x||!y) return rt=x+y,void(); pushup(rt=++tot,x,y); Merge(lc(rt),lc(x),lc(y)); Merge(rc(rt),rc(x),rc(y)); &#125;&#125;using namespace SegmentTree;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int sz[MAXN],dep[MAXN],n,q;void dfs(int u,int father)&#123; dep[u]=dep[father]+1; sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father) &#123; dfs(v,u); sz[u]+=sz[v]; &#125; &#125; Update(rt[u],1,n,dep[u],sz[u]-1); if (father) Merge(rt[father],rt[father],rt[u]);&#125;#undef intint main()&#123;#define int long long n=read(),q=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; dfs(1,0); while (q--)&#123; int u=read(),k=read(); printf(\"%lld\\n\",Query(rt[u],1,n,dep[u]+1,dep[u]+k)+(sz[u]-1)*min(k,dep[u]-1)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"}]},{"title":"P2986 [USACO10MAR]伟大的奶牛聚集","slug":"P2986-USACO10MAR-伟大的奶牛聚集","date":"2019-08-30T14:59:55.000Z","updated":"2019-08-31T03:58:30.935Z","comments":true,"path":"archives/db7b4afe.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/db7b4afe.html","excerpt":"","text":"传送门 考虑预处理出$sz$数组，表示子树的大小，处理出来$val[u]$数组，表示$u$的子树里面的所有奶牛到$u$集合的不方便度。 于是$dp$就十分简单，初始化$dp[1]=val[1]$，然后考虑集合地点从$u$变到$v$，$v$子树里面的所有奶牛都会少走$w$路程，而剩下奶牛都会都走$w$路程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int C[MAXN];struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;int sz[MAXN],sum;int val[MAXN],dp[MAXN];void init(int u,int father)&#123; sz[u]=C[u]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father)&#123; init(v,u); sz[u]+=sz[v]; val[u]+=val[v]; val[u]+=sz[v]*w; &#125; &#125;&#125;int ans;void dfs(int u,int father)&#123; ans=min(ans,dp[u]); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father)&#123; dp[v]=dp[u]-sz[v]*w+(sz[1]-sz[v])*w; dfs(v,u); &#125; &#125;&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;=n;++i)&#123; C[i]=read(); &#125; for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); &#125; init(1,1); ans=1e15; dp[1]=val[1]; dfs(1,1); printf(\"%lld\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"}]},{"title":"P3237 [HNOI2014]米特运输","slug":"P3237-HNOI2014-米特运输","date":"2019-08-30T14:47:29.000Z","updated":"2019-08-31T03:58:30.935Z","comments":true,"path":"archives/3ea8172b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3ea8172b.html","excerpt":"","text":"传送门 这个题目背景真的是太孙了，必须吐槽！ $Pro$给一棵树，每个点有一个权值，要求修改一些权值，使： 一个点的权值必须是其所有儿子的权值之和 一个点的儿子权值必须相同 求最少的被修改的数目 $Sol$其实此题充满套路的气息，首先，如果一个节点的权值确定，整个树都会确定。 假设节点$u$的权值是$val[u]$，孩子数量是$son[u]$，假设确定是节点$v$，对于节点$v$的子节点$w$，$val[w]=val[v]/son[v]$，对于节点$v$的父节点$f$，$val[f]=val[v] \\times son[f]$，依次类推，可以知道所有权值。 考虑求出一个$dp$数组，代表当前节点的权值不变的话，根节点的权值是多少，发现$dp[u]=\\prod _{v \\in anc(u)} son[v] \\times a[u]$，于是求出该数组里面出现次数最多的数，用$n$减去即可，表示剩下的节点都要被修改。 注意到$dp$数组会爆long long，于是考虑取$\\log$解决。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define eps 1e-6using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int a[MAXN];double dp[MAXN];void dfs(int u,int father,double sum)&#123; dp[u]=log(a[u])+sum; double son=log(G[u].size()-(u==1?0:1)); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father) dfs(v,u,sum+son); &#125;&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v),AddEdge(v,u); &#125; dfs(1,1,0); sort(dp+1,dp+1+n); int ans=1,cnt=0; for (register int i=1;i&lt;n;++i)&#123; if (abs(dp[i]-dp[i+1])&lt;=eps) ans=max(ans,++cnt); else cnt=1; &#125; printf(\"%d\\n\",n-ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P3338 [ZJOI2014]力","slug":"P3338-ZJOI2014-力","date":"2019-08-29T13:50:32.000Z","updated":"2019-08-29T14:23:03.043Z","comments":true,"path":"archives/b448651b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b448651b.html","excerpt":"","text":"传送门 题外话，那个式子巨神ypy说是电磁公式之类的，反正我觉得和电磁力什么很像。 $F_j = \\sum_{ij}\\frac{q_i q_j}{(i-j)^2 }$ 考虑化简： 第一步： $E_i = \\sum_{ji}\\frac{q_j}{(i-j)^2 }$ 谁都会。 令$f[i]=\\frac{1}{i^2},g[i]=q_i$ 有$E_i=\\sum _{j&lt;i} f[j]g[i-j]-\\sum _{j&lt;i} f[j]g[j-i]$ 为什么第二个式子不能化成$f[j]g[i-j]$，第一眼看上去，这样显然不对，那还让你做，第二眼看上去，其实有一个重要的性质不能忘记：多项式下标不能为负数，$i-j&lt;0$不能作为下标。 注意到第一个式子就是卷积的形式，但是第二个式子$j+(j-i)$不是一个常数，考虑翻转。 令$g’[i]=g[n-i]$，那么我们有$g’[n-j+i]=g[j-i]$，于是式子化成$E_i=\\sum _{j&lt;i} f[j]g[i-j]-\\sum _{j&lt;i} f[j]g’[n-j+i]$ 但是，做两次FFT有一点麻烦，考虑将$g$数组开两倍，同时包含$g,g’$，即对于$in,g[i]=\\frac{1}{(i-n)^2}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;const double PI=acos(-1.0);struct Complex&#123; double x,y;&#125;;inline Complex operator + (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline Complex operator - (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Complex operator * (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;&#125;int r[MAXN];Complex a[MAXN],b[MAXN];inline void FFT(Complex *A,int n,int type)&#123; for (register int i=1;i&lt;=n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=(i&lt;&lt;1); Complex Wn=Complex&#123;cos(2*PI/R),type*sin(2*PI/R)&#125;; for (register int j=0;j&lt;n;j+=R)&#123; Complex w=Complex&#123;1,0&#125;; for (register int k=0;k&lt;i;++k,w=w*Wn)&#123; Complex x=A[j+k],y=A[i+j+k]*w; A[j+k]=x+y,A[i+j+k]=x-y; &#125; &#125; &#125;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); for (register int i=1;i&lt;=n;++i)&#123; scanf(\"%lf\",&amp;a[i].x); &#125; for (register int i=0;i&lt;n;++i)&#123; b[i].x=-1.0/((double)(n-i)*(n-i)); &#125; for (register int i=n+1;i&lt;=2*n;++i)&#123; b[i].x=1.0/((double)(i-n)*(i-n)); &#125; int sz=2*n,m=1,L=0; while (m&lt;=sz) m&lt;&lt;=1,L++; for (register int i=0;i&lt;=m;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125; FFT(a,m,1),FFT(b,m,1); for (register int i=0;i&lt;=m;++i) a[i]=a[i]*b[i]; FFT(a,m,-1); for (register int i=n+1;i&lt;=2*n;++i) printf(\"%.3lf\\n\",a[i].x/m);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"}]},{"title":"P5075 [JSOI2012]分零食","slug":"P5075-JSOI2012-分零食","date":"2019-08-29T09:06:22.000Z","updated":"2019-08-29T09:48:47.395Z","comments":true,"path":"archives/3fae4db3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3fae4db3.html","excerpt":"","text":"$Pro$你可以把一个数$m$分成不超过$n$个数$a_i$，每一种方案对答案的贡献是$\\prod f(a_i)$，求最后的贡献值。 $Sol$很容易列出$O(nm^2)$的$dp$方程 $dp[i][y]=\\sum dp[i-1][y-x]+f[x]$ 其中$f[x]=f(x)=Ox^2+Sx+U$ （$f[x]$代表多项式$f$的第$x$项代表的值，$f(x)$代表题目所说的函数） 注意到$dp[i-1][y-x]+f[x]$是一个卷积的形式，可以化成$dp[i]=dp[i-1] * f$ 于是发现$dp_i=f^i$， 但是发现题目要求的是$\\sum _{i=1} ^n dp_i$，于是不能暴力$O(nm\\log m)$枚举，怎么办呢。 先看一道简化版的题目： 给你$a,n,p$，求$\\sum _{i=1}^n a^i \\mod p$的值。（$n \\le 10^{18}$） 不要用数学方法乱搞。 考虑类似于快速幂，使用倍增，不同的是，我们在倍增过程中记录两个变量$F,G$ 其中$F=\\sum _{i=1}^n a^i \\mod p,G=a^n \\mod p$ 发现$F’=F+F \\times G,G’=G \\times G$ 当$n$为奇数的时候还有处理一下边角，$G=G \\times a,F=F+G$ 于是得到以下代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int F;// ansint G;// a^iint a,n,p;inline void ksm(int n)&#123; if (n==1) return F=G=a,void(); ksm(n&gt;&gt;1ll); F=(F+F*G)%p; G=(G*G)%p; if (n&amp;1)&#123; G=(G*a)%p; F=(F+G)%p; &#125;&#125;#undef intint main()&#123;#define int long long a=read(),n=read(),p=read(); ksm(n); printf(\"%lld\\n\",F);&#125; 回到本题，也能得到类似的结论，设$F=\\sum _{i=1} ^n f^i,G=f^n$，我们有$F’=F+F \\times G,G’=G \\times G$ 于是就得到了$O(m \\log m \\log n)$的解法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;const double PI=acos(-1.0);inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Complex&#123; double x,y;&#125;;inline Complex operator + (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline Complex operator - (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Complex operator * (const Complex &amp;A,const Complex &amp;B)&#123; return Complex&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;&#125;int r[MAXN];inline void FFT(Complex *A,int n,int type)&#123; for (register int i=0;i&lt;n;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (register int i=1;i&lt;n;i&lt;&lt;=1)&#123; int R=(i&lt;&lt;1); Complex Wn=Complex&#123;cos(2*PI/R),type*sin(2*PI/R)&#125;; for (register int j=0;j&lt;n;j+=R)&#123; Complex w=Complex&#123;1,0&#125;; for (register int k=0;k&lt;i;++k,w=w*Wn)&#123; Complex x=A[j+k],y=w*A[i+j+k]; A[j+k]=x+y; A[i+j+k]=x-y; &#125; &#125; &#125;&#125;struct Poly&#123; int num[MAXN];&#125;;Poly F,G,org,temp;int sz,m,n,o,s,u,L,mod;inline int f(int x)&#123; return (o*x*x%mod+s*x%mod+u)%mod;&#125;Complex a[MAXN],b[MAXN];inline void Mul(Poly &amp;des,const Poly &amp;A,const Poly &amp;B)&#123; for (register int i=0;i&lt;=sz;++i) a[i]=Complex&#123;(double)A.num[i],0&#125;,b[i]=Complex&#123;(double)B.num[i],0&#125;; FFT(a,sz,1),FFT(b,sz,1); for (register int i=0;i&lt;=sz;++i) a[i]=a[i]*b[i]; FFT(a,sz,-1); for (register int i=1;i&lt;=m;++i) des.num[i]=((int)(a[i].x/sz+0.5))%mod;&#125;inline void Add(Poly &amp;A,const Poly &amp;B)&#123; for (register int i=1;i&lt;=m;++i) A.num[i]=(A.num[i]+B.num[i])%mod;&#125;inline void Init(int m)&#123; sz=1,L=0; while (sz&lt;=2*m) sz&lt;&lt;=1,L++; for (register int i=0;i&lt;=sz;++i)&#123; r[i]=(r[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(L-1))); &#125;&#125;inline void ksm(int n)&#123; if (n==1)&#123; F=org,G=org; return ; &#125; ksm(n&gt;&gt;1); Mul(temp,F,G); Add(F,temp); Mul(G,G,G); if (n&amp;1)&#123; Mul(G,G,org); Add(F,G); &#125;&#125;int main()&#123; m=read(),mod=read(); Init(m); n=read(),o=read(),s=read(),u=read(); for (register int i=1;i&lt;=m;++i) org.num[i]=f(i); ksm(n); printf(\"%d\\n\",F.num[m]);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"倍增","slug":"倍增","permalink":"https://gaisaiyuno.github.io/tags/倍增/"},{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"}]},{"title":"FFT学习笔记","slug":"FFT学习笔记","date":"2019-08-27T14:08:51.000Z","updated":"2019-08-28T11:58:48.583Z","comments":true,"path":"archives/386bf641.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/386bf641.html","excerpt":"","text":"前置技能：单位根 我们有一个玄学函数$f(x)=\\sum _{i=0}^{n-1} a_i x^i$ 不妨换一个好看的形式：$f(x)= \\{a_0,a_1,a_2,…a_{n-1} \\}$ 还有另一个玄学函数$g(x)=\\{b_0,b_1,b_2,…b_{n-1}\\}$ 我们要计算$h$，其中$h_k=\\sum_{i=0}^k a_i \\times b_{n-i}$ 一个典型的例子即是十进制整数乘法，此时$x=10$，$a_i,b_i$是每一位代表的值 不妨换一种思路，我们将一些未知数$x_0,x_1,x_2…x_{n-1}$带入$f,g$ 此时我们使用点值表达式 $f(x)=\\{(x_0,f(x_0)),(x_1,f(x_1)),(x_2,f(x_2)),…,(x_{n-1},f(x_{n-1}))\\}$ $g(x)=\\{(x_0,g(x_0)),(x_1,g(x_1)),(x_2,g(x_2)),…,(x_{n-1},g(x_{n-1}))\\}$ 我们就可以$O(n)$得到 $h(x)=\\{(x_0,f(x_0)·g(x_0)),(x_1,f(x_1)·g(x_1)),…,(x_{n-1},f(x_{n-1})·g(x_{n-1}))\\}$ 于是可以高斯消元，求解系数。 等等，真的是这样的吗？高斯消元是$O(n^2)$的，时间复杂度没变。 考虑带入特殊的$x_0,x_1,x_2…x_{n-1}$","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"关于单位根和原根","slug":"关于单位根","date":"2019-08-27T12:54:09.000Z","updated":"2019-10-06T03:41:36.322Z","comments":true,"path":"archives/3594e75f.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3594e75f.html","excerpt":"","text":"这两个”根“在多项式乘法里面运用非常广泛。 单位根（FFT）关于我自己对单位根的理解。 单位根其实就是一些复数，他们的模长为$1$。 所以单位根一定在单位圆上 假设一个单位根$z$的极角为$\\theta$，那么我们可以将$z$表示为$\\cos \\theta +i \\sin \\theta$ 数形结合考虑，从圆上某一个点做一条垂线，那么垂线长度为$\\sin \\theta$，垂足到原点距离为$\\cos \\theta$ 考虑使用向量模长验证，$|z|=\\sqrt{\\sin ^2 \\theta + \\cos ^2 \\theta}=1$ $\\omega_n^k = \\cos \\frac{k}{n} 2 \\pi+ i \\sin \\frac{k}{n} 2 \\pi $ 感性地理解这个式子，注意到$2 \\pi$为$360°$，所以这个式子的意义就是将单位圆用一些经过圆心的线分成$n$份，从$1+0i$往逆时针数$k$次，数到的线的端点所代表的复数。 于是发现四个推$FFT$所用的经典的式子都非常$naive$ $1.\\omega _n^k=\\omega _{2n}^{2k}$这个代表的意思就是把单位圆分成$n$份，数$k$次，和分成$2n$份，数$2k$次所代表复数是一样的。非常智障。 也可以通过三角函数证明： $\\omega^k_n=\\cos{k\\over n}2 \\pi +i\\sin{k\\over n} 2\\pi =\\cos{2k\\over 2n}2\\pi+i\\sin{2k\\over 2n} 2\\pi=\\omega^{2k}_{2n}$ $2.\\omega _n^{k+{n \\over 2}}=-\\omega _n^k$定义：对于复数$z=a+bi$，$-z=-a-bi$ 这个也非常好理解，$n/2$代表半圈，所以这个式子的意思是从编号为$k$的复数开始走半圈，代表的复数和之前的正好相反（实部和虚部都相反） $3. \\omega _n^0=\\omega _n^n =1,\\omega _n^{\\frac{n}{2}}=-1$编号为$0$和编号为$n$的点代表的复数相等，都为$1+0i$，编号为$n/2$的点其实就是$1+0i$转过半圈，就是$-1+0i$ $4.\\omega _n^p \\times \\omega _n^q = \\omega _n ^ {p+q}$复数的乘法其实像三角函数一样，设$z_1=a_1+ib_1,z_2=a_2+ib_2$ 根据复数乘法定义，那么我们有$z_1 \\times z_2 = (a_1 \\times a_2 - b_1 \\times b_2)+i(a_1 \\times b_2+a_2 \\times b_1)$ 我们有三角函数的合角公式： $\\sin(A+B)=\\sin A \\cos B+\\cos A \\sin B$$\\cos (A+B)=\\cos A\\cos B-\\sin A \\sin B$ 换元：$\\alpha = \\frac{p}{n} 2 \\pi, \\beta = \\frac{q}{n} 2 \\pi $ 于是$\\omega _n^p = \\cos \\alpha + i \\sin \\alpha$ 还有$\\omega _n^q = \\cos \\beta + i \\sin \\beta$ 于是$\\omega _n ^p \\times \\omega _n ^q = (\\cos \\alpha \\cos \\beta-\\sin \\alpha \\sin \\beta) + i (\\sin \\alpha \\cos \\beta+\\cos \\alpha \\sin \\beta) = \\cos (\\alpha + \\beta)+i \\sin(\\alpha +\\beta) = \\omega ^{p+q}_n$ （吐槽一句，复数的乘法好像就是为了这个东西定义的） 这个式子要好好体会。 有了第四个式子，我们就可以再推出第三个式子： $\\omega _n ^{k+\\frac{n}{2}}=\\omega _n^{\\frac{n}{2}} \\times \\omega _n^k = (-1+0i) \\times \\omega _n^k = -\\omega_n^k$ 原根（NTT）有时候题目要求对一个大质数取模，这时就不能用单位根，要用原根。 $p$的原根是满足$g^0\\%p,g^1\\%p,g^2\\%p…g^{p-2}\\%p$恰好等于$[1,p-1]$中的所有数的最小的$g$。 现实中，可以从$2 \\to p-1$枚举$g$，如果满足$g ^\\frac{p-1}{p_i} !=1 \\pmod p$均成立，那么我们就找到了$p$的原根。 我们称$g_n$为$n$的原根，那么我们也得到了类似于$\\omega_n^k$一长串的$g_n^0,g_n^1,g_n^2, … ,g^{n-2}_{n}$，而且他们模意义下和$[1,p-1]$中的所有数一一对应。 我们设一个素数$p=a \\times 2^b+1$ 有以下等价关系：$g_n=g^{\\frac{p-1}{n}} \\Leftrightarrow \\omega_n=\\cos \\frac{2\\pi}{n}+i\\sin\\frac{2\\pi}{n}$。（下面证明） 并且有$g_n^k=g^{\\frac{p-1}{n} \\times k}$ 显然有$g_n^p \\times g_n^q=g^{\\frac{p-1}{n} \\times (p+q)}=g_n^{p+q}$。 $1.g_{2n}^{2k}=g_n^k$显然，$g_{2n}^{2k}=g^{\\frac{p-1}{2n} \\times 2k}=g^{\\frac{p-1}{n}k}=g_n^k$。 $2.g_n^{\\frac{n}{2}}=-1,g_n^{0}=g_{n}^n=1$显然$g_n^0=g^0=1,g_n^n=g^{p-1}=1 \\pmod p$。 因为$(g_n^{\\frac{n}{2}})^2=g_n^n=1$ 得$g_n^{\\frac{n}{2}}=\\pm 1$。 又因为$g_n^n!=g_n^{\\frac{n}{2}}$，且$g_n^n=1$，所以$g_n^{\\frac{n}{2}}=-1$。 $3.g_n^{k+\\frac{n}{2}}=-g_n^k$上面的式子套入$p=k,q=\\frac{n}{2}$，显然。","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"复数","slug":"复数","permalink":"https://gaisaiyuno.github.io/tags/复数/"},{"name":"质数","slug":"质数","permalink":"https://gaisaiyuno.github.io/tags/质数/"}]},{"title":"Manthan, Codefest 19","slug":"Manthan-Codefest-19","date":"2019-08-27T12:01:41.000Z","updated":"2019-08-27T12:08:49.806Z","comments":true,"path":"archives/a3cbb677.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a3cbb677.html","excerpt":"","text":"比赛传送门 $Pro1$A. XORinacci 定义： $f(0)=a,f(1)=b,f(n)=f(n-1) \\oplus f(n-2)$ 给你$a,b$，求$f(n)$ $Sol1$找规律： $f(0)=a,f(1)=b,f(2)=a \\oplus b,f(3)=b \\oplus (a \\oplus b)=a,f(4)=a \\oplus (a \\oplus b)=b …. $ 于是发现以$3$个数为循环节： $Code1$1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;#undef intint main()&#123;#define int long long int t=read(); for (register int i=1;i&lt;=t;++i)&#123; int a=read(),b=read(),n=read(); printf(\"%I64d\\n\",(n%3==0?a:(n%3==1?b:a^b))); &#125;&#125; $Pro2$B. Uniqueness 给你一个序列$a_1,a_2,…a_n$，你要选定一段连续的区间$[l,r]$并且删去，使得剩下的数互不相同。 求删去区间长度的最小值。 $Sol2$由于$n \\le 2000$，所以$O(n^2)$的解法应该能轻松过。 考虑枚举左端点$l$，然后从$n$开始推$r$。 假设$[l,r]$是不合法的区间，那么$[l,r-1]$肯定不合法，于是只要枚举到一个不合法的$r$，就统计答案，退出循环。 还有一个$O(n)$的解法，观察到$l$往左推进，右端点的极左位置肯定是向右移动的，于是维护$l,r$两个指针，注意到两个指针最多移动$n$次，于是这个解法是$O(n)$的。 $Code2$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//n^2解法#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN],n;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i) b[i]=a[i]; sort(b+1,b+1+n); for (register int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+n,a[i])-b;&#125;int cnt[MAXN];int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; discrete(); int ans=0x7fffffff; memset(cnt,0,sizeof(cnt)); for (register int i=1;i&lt;=n;++i)&#123; cnt[a[i]]++; if (cnt[a[i]]&gt;1)&#123; break; &#125; ans=min(ans,n-i); &#125; memset(cnt,0,sizeof(cnt)); for (register int i=n;i&gt;=1;--i)&#123;//两种特判 cnt[a[i]]++; if (cnt[a[i]]&gt;1)&#123; break; &#125; ans=min(ans,i-1); &#125; for (register int i=1;i&lt;=n;++i)&#123; memset(cnt,0,sizeof(cnt)); for (register int j=1;j&lt;=i;++j)&#123; cnt[a[j]]++; if (cnt[a[j]]&gt;1) &#123;//如果前半部分不合法，就退出 printf(\"%d\\n\",ans==0x7fffffff?0:ans); return 0; &#125; &#125; for (register int j=n;j&gt;=i+1;--j)&#123; cnt[a[j]]++; if (cnt[a[j]]&gt;1) break;//退出 ans=min(ans,j-i-1); &#125; &#125; printf(\"%d\\n\",ans);&#125; $Pro3$C. Magic Grid 给你$0$到$n^2-1$的数，将他们填进$n \\times n$的矩阵，满足每行和每列的异或和相等。 $n$是$4$的倍数。 $Sol3$考虑每$4 \\times 4$个矩阵填数。 对于$4 \\times t,4 \\times t+1,4 \\times t+2,4 \\times t+3$四个数，都可以表示为$…00,…01,…10,…10$的形式，异或一下，全部都可以抵消。 对于$4 \\times t,4 \\times (t+1),4 \\times (t+2),4 \\times (t+3)$四个数，也是同样可以抵消。 $Code3$12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int ans[1005][1005];int main()&#123; int n=read(); int p=n/4; int cnt=0; for (register int i=1;i&lt;=p;++i)&#123; for (register int j=1;j&lt;=p;++j)&#123; for (register int k=0;k&lt;4;++k)&#123; for (register int l=0;l&lt;4;++l)&#123; ans[(i-1)*4+k+1][(j-1)*4+l+1]=cnt++; &#125; &#125; &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=n;++j)&#123; printf(\"%d \",ans[i][j]); &#125; printf(\"\\n\"); &#125;&#125; $Pro4$D. Restore Permutation 给你一个数组$p_1,p_2,…p_n$，要你求数组$a_1,a_2,…a_n$ 其中$\\{a\\}$是$1$到$n$的排列，数组$p$的生成方式为$p_i=\\sum _{j=1}^i a[j] (a[j]\\le a[i])$ $Sol4$考虑逆推，即从$a_n$推到$a_1$ 维护一个树状数组，一开始的值为$1,2,…n$。 对于$a_i$，在树状数组上面二分，找到使得前缀和$\\le p_i$的最大位置$pos$ 把$a_i$设成$pos$，然后将树状数组上面把位置$pos$设成$0$即可。 $Code4$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BIT&#123; int C[MAXN]; #define lowbit(i) (i&amp;(-i)) inline void Add(int x,int val)&#123; for (register int i=x;i&lt;MAXN;i+=lowbit(i))&#123; C[i]+=val; &#125; &#125; inline int Query(int x)&#123; int ans=0; for (register int i=x;i&gt;0;i-=lowbit(i))&#123; ans+=C[i]; &#125; return ans; &#125;&#125;;using namespace BIT;int a[MAXN],n;inline int BinSearch(int pos)&#123; int l=0,r=MAXN-1,ans; while (l&lt;r-1)&#123; int mid=(l+r)&gt;&gt;1; if (Query(mid)&lt;=a[pos]) l=mid; else r=mid; &#125; return r;&#125;int ans[MAXN];#undef intint main()&#123;#define int long long n=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); for (register int i=1;i&lt;=n;++i)&#123; Add(i,i); &#125; for (register int i=n;i&gt;=1;--i)&#123; int pos=BinSearch(i); Add(pos,-pos); ans[i]=pos; &#125; for (register int i=1;i&lt;=n;++i)&#123; printf(\"%I64d \",ans[i]); &#125;&#125;","categories":[],"tags":[]},{"title":"P3761 [TJOI2017]城市","slug":"P3761-TJOI2017-城市","date":"2019-08-27T11:44:45.000Z","updated":"2019-08-27T12:01:00.298Z","comments":true,"path":"archives/2b63c947.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2b63c947.html","excerpt":"","text":"P3761 [TJOI2017]城市 注意到两个城市之间的最大交通费用就是树的直径。 考虑枚举删去哪一条边，假设删的是$$，那么我们发现直径可能有三种选择： $1.$直径缩在蓝色子树里面。 $2.$直径缩在红色子树里面。 上面两种情况，我们都不能通过加边来缩短直径，是无法掌控的。 $3.$直径的一段在蓝色子树里面，另一端在红色子树里面，这时直径必定跨越边$$ 如图所示，黄色部分代表直径。 注意图中的$u,v$是你新增的边的端点。 于是问题转化为在蓝色子树和红色子树里面选两个点$p,q$，并且连边，使得蓝色子树里面的点到$p$的距离最大值+$$边权+红色子树里面的点到$q$的距离的最大值最小。 不妨将这样的点称为树的中心，将树的中心和树上每一个点之间距离的最大值称为树的半径。 感性理解一下，树的中心一定在直径上面。 如何证明呢？ 考虑把整棵树表示为直径上面连着一大堆子树的形式。 假设我们现在选择了某个子树里面的点$u$，设$v$是这个子树的根的父亲，考虑证明$v$是更优的选择。 把距离$u$最远的点记为$w$。 $1.w$不属于这个子树​：$dis(u,w)=dis(u,v)+dis(v,w)&gt;dis(v,w)$，显然选择$v$最优。 $2.w$属于这个子树： 慢慢证明： 首先，树上距离$v$最远的点一定是$p$或$q$。 否则假设距离$v$最远的点是$r$，那么$p-v-r$或者$r-v-q$这条路径肯定比$p-v-q$长，$p-q$就不是直径了。 由于对称性，不妨设距离$v$最远的点是$p$。 我们有$dis(u,w)&gt;dis(u,v)+dis(v,p)$ 所以$dis(u,w)&gt;-dis(u,v)+dis(v,p)$ 移项，得：$dis(u,w)+dis(u,v)&gt;dis(v,p)$ 同时加上$dis(v,q)$ $dis(u,w)+dis(u,v)+dis(v,q)&gt;dis(v,p)+dis(v,q)$ 于是$q-v-u-w$这条路径可以成为更优的直径，造成矛盾。 所以$w$肯定不属于这个子树。 所以，我们找出蓝色部分和红色部分的子树，枚举直径上面每个点，计算这个点和直径两个端点的距离即可。 时间复杂度$O(n^2)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define MAXN 5005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;int n;int fa[MAXN],d[MAXN];int vis[MAXN];queue&lt;int&gt;Q;inline int bfs(int u,int father)&#123; while (Q.size()) Q.pop(); memset(vis,0,sizeof(vis)); memset(fa,0,sizeof(fa)); memset(d,0,sizeof(d)); fa[u]=father,d[u]=0; vis[u]=vis[father]=1;//等于是阻断到另一个子树的路 Q.push(u); int ans=0; while (Q.size())&#123; int u=Q.front();Q.pop(); vis[u]=true; if (d[u]&gt;d[ans]) ans=u; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (vis[v]) continue; d[v]=d[u]+w; fa[v]=u;//记录父亲，等于是记录直径 Q.push(v); &#125; &#125; return ans;&#125;inline int FindMid(int p,int q)&#123;//树的半径的长度，q为最深的点 int len=d[q]; int ans=0x7fffffff; while (true)&#123; ans=min(ans,max(d[q],len-d[q])); q=fa[q];//慢慢爬上来 if (q==0) break; &#125; return ans;&#125;int U[MAXN],V[MAXN],W[MAXN];int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; U[i]=read(),V[i]=read(),W[i]=read(); AddEdge(U[i],V[i],W[i]); AddEdge(V[i],U[i],W[i]); &#125; int ans=0x7fffffff; for (register int i=1;i&lt;n;++i)&#123; int u=U[i],v=V[i]; int p1=bfs(u,v);int q1=bfs(p1,v);//直径的两个端点 int len1=d[q1];int ans1=FindMid(p1,q1); int p2=bfs(v,u);int q2=bfs(p2,u); int len2=d[q2];int ans2=FindMid(p2,q2); ans=min(ans,max(max(len1,len2),ans1+W[i]+ans2)); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"树的直径","slug":"树的直径","permalink":"https://gaisaiyuno.github.io/tags/树的直径/"}]},{"title":"树形dp之最小支配集详解","slug":"树形dp之最小支配集详解","date":"2019-08-25T12:34:03.000Z","updated":"2019-08-25T14:16:27.488Z","comments":true,"path":"archives/a18ff24e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a18ff24e.html","excerpt":"","text":"最小支配集的定义：给你一棵树，让你选出一些节点，选出来的节点会把自己和相邻的节点全部覆盖，让你求出选出来节点的最小数量。 考虑树形dp： 定义:$dp[i][0]$: 点$i$属于支配集，并且以点$i$为根的子树都被覆盖了的情况下支配集中包含的最少点数 也就是$i$支配自己 合法状态举例（不一定最少） $dp[i][1]$: 点$i$不属于支配集，且以$i$为根的子树都被覆盖，且$i$被其中不少于$1$个子节点覆盖的情况下支配集包含的最少点数 也就是$i$的孩子支配$i$ $dp[i][2]$: 点$i$不属于支配集，且以$i$为根的子树都被覆盖，且$i$没被子节点覆盖的情况下支配集包含的最少点数 也就是$i$由父亲支配 希望你们好好研究子状态，容易混淆的地方已经用粗体字标出 初始值的设置： 因为$u$由自己支配，所以至少选$u$自己； 因为$u$由孩子支配，而且$u$一定不能选，所以这种情况设成INF，表示未知； 因为$u$由父亲支配，而且$u$一定不能选，所以这种情况设成0。 1dp[u][0]=1;dp[u][1]=INF;dp[u][2]=0;//INF不能太大 $1.u$支配自己​：剩下怎么搞，都能满足节点$v$被覆盖 12int val=min(min(dp[v][0],dp[v][1]),dp[v][2]);dp[u][0]+=val; 统计方案数也非常简单，只要等于最小值，都可以加入最佳方案 12345ll temp=0;for (register int i=0;i&lt;=2;++i)&#123; if (dp[v][i]==val) Add(temp,cnt[v][i]);//加入方案&#125;Mul(cnt[u][0],temp); $2.u$由孩子节点支配： 这种情况是最复杂的： 12345678val=min(dp[u][1]+min(dp[v][0],dp[v][1]),dp[u][2]+dp[v][0]);temp=0;for (register int i=0;i&lt;=1;++i) &#123; if (dp[u][1]+dp[v][i]==val) Add(temp,cnt[v][i]);&#125;Mul(cnt[u][1],temp);if (dp[u][2]+dp[v][0]==val) Add(cnt[u][1],cnt[u][2]*cnt[v][0]%MOD);dp[u][1]=val;//要最后更新 $—1.$只要$u$已经由孩子支配了，发现$v$可以由自己支配，也可以由孩子支配，但是不能由父亲支配，因为$u$不支配自己。 $—2.$如果$u$由父亲支配，那么加入一个自己支配自己的子节点，就可以变成一个合法的由孩子支配的状态，注意这样的状态不是由父亲支配的状态，因为前面的子状态保证了$u$的孩子不支配$u$，与此矛盾。 $3.u$由父亲支配，发现$v$只能由孩子支配，就这样完了。 12dp[u][2]+=dp[v][1];Mul(cnt[u][2],cnt[v][1]); 完整代码，可以求出方案数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*定义:dp[i][0]: 点i属于支配集，并且以点i为根的子树都被覆盖了的情况下支配集中包含的最少点数 也就是i支配自己dp[i][1]: 点i不属于支配集，且以i为根的子树都被覆盖，且i被其中不少于1个子节点覆盖的情况下支配集包含的最少点数 也就是i的孩子支配idp[i][2]: 点i不属于支配集，且以i为根的子树都被覆盖，且i没被子节点覆盖的情况下支配集包含的最少点数 也就是i由父亲支配 */#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3f#define memmax(a) memset(a,0x3f,sizeof(a))#define MAXN 500005#define MOD 1032992941#define ll long long#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];void AddEdge(int u,int v)&#123; G[u].push_back(v); G[v].push_back(u);&#125;int dp[MAXN][3];ll cnt[MAXN][3];void Add(ll &amp;A,ll B)&#123; A=(A+B)%MOD;&#125;void Mul(ll &amp;A,ll B)&#123; A=(A*B)%MOD;&#125;void dfs(int u,int father)&#123; dp[u][0]=1;dp[u][1]=INF;dp[u][2]=0;//INF不能太大 cnt[u][0]=cnt[u][1]=cnt[u][2]=1;//因为方案是乘起来的 for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dfs(v,u); //---------------------------------------------------------- //只要u支配了自己，剩下怎样都可以 int val=min(min(dp[v][0],dp[v][1]),dp[v][2]); dp[u][0]+=val; ll temp=0; for (register int i=0;i&lt;=2;++i)&#123; if (dp[v][i]==val) Add(temp,cnt[v][i]); &#125; Mul(cnt[u][0],temp); //---------------------------------------------------------- //1.u由其中一个子节点支配,子节点由自己或是孩子支配，而不由u支配 //2.u由父亲支配,子节点支配自己 val=min(dp[u][1]+min(dp[v][0],dp[v][1]),dp[u][2]+dp[v][0]); temp=0; for (register int i=0;i&lt;=1;++i) &#123; if (dp[u][1]+dp[v][i]==val) Add(temp,cnt[v][i]); &#125; Mul(cnt[u][1],temp); if (dp[u][2]+dp[v][0]==val) Add(cnt[u][1],cnt[u][2]*cnt[v][0]%MOD); dp[u][1]=val;//要最后更新 //---------------------------------------------------------- //u由父亲支配,子节点只能支配自己 //(子节点不能由父亲支配，因为u没有；也不能由自己支配，因为u仅仅由父亲支配) dp[u][2]+=dp[v][1]; Mul(cnt[u][2],cnt[v][1]); &#125; &#125;&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;n;++i)&#123; AddEdge(read(),read()); &#125; dfs(1,0); int val=min(dp[1][0],dp[1][1]);//1没有父亲 ll ans=0; for (register int i=0;i&lt;=1;++i) &#123; if (dp[1][i]==val) Add(ans,cnt[1][i]); &#125; printf(\"%d\\n%lld\\n\",val,ans);&#125;","categories":[],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"}]},{"title":"APIO2019毒瘤题记录","slug":"APIO2019毒瘤题记录","date":"2019-08-25T08:11:31.000Z","updated":"2019-08-25T12:04:59.920Z","comments":true,"path":"archives/61bab5e6.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/61bab5e6.html","excerpt":"","text":"T1:P5444 [APIO2019]奇怪装置 其实这题比较简单，考虑两个数对相同的条件： $x_1==x_2 \\text{&amp;&amp;} y_1==y_2$ 设两个数对对应的时刻是$t_1,t_2$，那么我们有 $\\begin{cases} (t_1+\\lfloor\\frac{t_1}{B}\\rfloor)\\mod A == (t_2+\\lfloor\\frac{t_2}{B}\\rfloor)\\mod A \\ t_1\\mod B == t_2 \\mod B \\end{cases}$ 不妨设$t_1 = i B+j $其中$0 \\le j \\le B-1$ 由第二个式子，有$t_2 \\mod B = j$ 那么我们不妨设$t_2 = kB+j$ 带入第一个式子： $(iB+j + i) \\mod A == (kB+j+k)\\mod A$ 化简一下： $(i(B+1)+j)\\mod A==(k(B+1)+j)\\mod A$ 发现左右两边的$j$可以消掉： $(i(B+1))\\mod A==(k(B+1))\\mod A$ 所以两式相等的条件就是$(k-j)(B+1) \\mod A ==0$ 即$k == j (\\mod \\frac{A}{gcd(A,B+1)})$ 带入原始式子，发现$t_1,t_2$对应的数对相同的充要条件就是$t_1 == t_2 (\\mod \\frac{AB}{gcd(A,B+1)})$ 所以问题转化为线段求并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline long long read()&#123; long long x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;long long gcd(long long x,long long y)&#123; return x%y==0?y:gcd(y,x%y);&#125;struct Segment&#123; long long l,r;&#125;s[MAXN];int cnt;inline void AddSegment(long long l,long long r)&#123; s[++cnt]=Segment&#123;l,r&#125;;&#125;inline bool operator &lt; (const Segment &amp;A,const Segment &amp;B)&#123; return A.l!=B.l?A.l&lt;B.l:A.r&lt;B.r;&#125;inline bool operator == (const Segment &amp;A,const Segment &amp;B)&#123; return A.l==B.l&amp;&amp;A.r==B.r;&#125;int main()&#123; int n=read(); long long a=read(),b=read(); long long M=a/(gcd(a,b+1)); 2e18/M&lt;b?M=2e18:M*=b; for (register int i=1;i&lt;=n;++i)&#123; long long l=read(),r=read(); if (r-l+1&gt;=M)&#123; printf(\"%lld\\n\",M); return 0; &#125; l%=M,r%=M; if (l&lt;=r)&#123; AddSegment(l,r); &#125; else &#123; AddSegment(0,r); AddSegment(l,M-1); &#125; &#125; sort(s+1,s+1+cnt); cnt=unique(s+1,s+1+cnt)-s-1; long long L=s[1].l,R=s[1].r; long long ans=0; for (register int i=2;i&lt;=cnt;++i)&#123; if (R&lt;s[i].l) ans+=R-L+1,L=s[i].l,R=s[i].r; else R=max(R,s[i].r); &#125; ans+=R-L+1; printf(\"%lld\\n\",ans);&#125; T2:P5443 [APIO2019]桥梁 口胡一下部分分做法： subtask1:大暴力，跑一个bfs即可。 subtask2:用线段树维护一条链，每次二分找出最左/最右边界。 subtask4:离线+并查集，按照边权从大到小，重量从大到小对汽车和桥分别排序，遍历每辆汽车，设其重量是$w$，将承重能力大于等于$w$的边全部加入并查集，容易发现并查集是越变越大的，因为汽车重量依次减少，所以它能到达的地方越来越多，大力kruskal重构树也是可以的。 讲一讲正解做法，不妨将暴力和并查集的思路结合在一起，对询问分块，因为桥可能越改越烂，所以并查集的大小不是只增不减的，于是需要支持可撤销。 剩下的部分在代码里面有详细注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int U[MAXN],V[MAXN],D[MAXN],n,m;int t[MAXN],s[MAXN],w[MAXN],vis[MAXN];struct Query&#123; int w,s,id;&#125;q[MAXN];int cntq;inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return A.w&gt;B.w;&#125;inline void AddQuery(int w,int s,int id)&#123; q[++cntq]=Query&#123;w,s,id&#125;;&#125;int u[MAXN],cntu;inline void AddUpdate(int e)&#123; u[++cntu]=e;&#125;struct Edge&#123; int w,id;&#125;e[MAXN];int cnte;inline bool operator &lt; (const Edge &amp;A,const Edge &amp;B)&#123; return A.w&gt;B.w;&#125;inline void AddEdge(int w,int i)&#123; e[++cnte]=Edge&#123;w,i&#125;;&#125;int tag[MAXN],cnt;namespace BCJ&#123; int fa[MAXN],sz[MAXN]; int _u[MAXN],_v[MAXN]; inline void Init_BCJ()&#123; for (register int i=1;i&lt;=n;++i) fa[i]=i,sz[i]=1; &#125; int GetFa(int i)&#123; return fa[i]==i?i:GetFa(fa[i]); &#125; inline void Union(int i)&#123; int fau=GetFa(U[i]),fav=GetFa(V[i]); if (fau==fav) return ; if (sz[fau]&gt;sz[fav]) swap(fau,fav); fa[fau]=fav,sz[fav]+=sz[fau]; _u[i]=fau,_v[i]=fav;//记录修改的点 &#125; inline void Reverse()&#123;//回溯 for (register int i=cnt;i&gt;=1;--i)&#123; int from=_u[tag[i]],to=_v[tag[i]]; _u[tag[i]]=0,_v[tag[i]]=0; if (from&lt;0) continue; sz[to]-=sz[from],fa[from]=from; &#125; cnt=0; &#125;&#125;using namespace BCJ;int temp[MAXN],ans[MAXN];inline void Clear()&#123; cntu=cntq=cnte=0; memset(vis,0,sizeof(vis));&#125;int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; U[i]=read(),V[i]=read(),D[i]=read(); &#125; int alb=read(); int Size=1000,lst=1; for (register int i=1;i&lt;=alb;++i)&#123; t[i]=read(),s[i]=read(),w[i]=read(); if (t[i]==1)&#123;//Update s[i]-&gt;w[i] if (!vis[s[i]])&#123; AddUpdate(s[i]); vis[s[i]]=true;//vis[i]==true表示i修改过 &#125; &#125; else &#123;//Query AddQuery(w[i],s[i],i); &#125; if (i==alb||i%Size==0)&#123;//搞完一个块 for (register int j=1;j&lt;=m;++j) AddEdge(D[j],j),_u[j]=0;//加入所有边 Init_BCJ(); sort(e+1,e+1+cnte),sort(q+1,q+1+cntq);//按照边权从大到小排序 int p=1; for (register int j=1;j&lt;=cntq;++j)&#123;//遍历每个询问 for (;p&lt;=cnte&amp;&amp;e[p].w&gt;=q[j].w;++p)&#123;//没有修改过的边 int id=e[p].id; if (vis[id]) continue; Union(id),_u[id]=0;//这条边一定在后面的并查集里面，所以不需要回滚 &#125; for (register int k=lst;k&lt;q[j].id;++k)&#123;//lst后面都没有做到 int id=s[k]; if (t[k]==1) temp[id]=1;//标记需要修改的边 &#125; for (register int k=1;k&lt;=cntu;++k)&#123; int id=u[k]; if (!temp[id]&amp;&amp;D[id]&gt;=q[j].w) &#123;//没有修改，但是需要回滚，因为后面的操作可能把桥变得更坏 Union(id),tag[++cnt]=id; &#125; &#125; for (register int k=q[j].id;k&gt;=lst;--k)&#123; int id=s[k]; if (t[k]==1) temp[id]=0;//回滚temp数组，所以是倒序 if (t[k]==2||_u[id]) continue;//如果是query就跳过 _u[id]=-1,tag[++cnt]=id;//需要回滚 if (w[k]&gt;=q[j].w) Union(id);//w[k]&gt;=q[j].w对答案可能会有影响 &#125; ans[q[j].id]=sz[GetFa(q[j].s)];//记录答案 Reverse();//回溯并查集 &#125; for (;lst&lt;=i;++lst)&#123;//lst记录修改和查询到哪里 if (t[lst]==1) D[s[lst]]=w[lst];//把这一块的修改全部做掉，防止影响后面的答案 else printf(\"%d\\n\",ans[lst]); &#125; Clear();//清空 &#125; &#125;&#125; 总结：此题的分块做法将暴力可以修改边的性质和离线做法对询问排序的做法结合在一起，十分巧妙。 T3：P5445 [APIO2019]路灯 其实这道题部分分可以拿到60分，现在来详细讲解一下： subtask1:$n,q&lt;=100$暴力，每次暴力复制一份数组： 1234567891011121314151617181920212223242526272829303132333435namespace BruteForce&#123; int a[MAXN][MAXN]; inline void Copy(int i,int j,int n)&#123;//Copy i to j for (register int k=1;k&lt;=n;++k)&#123; a[j][k]=a[i][k]; &#125; &#125; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0'; for (register int i=1;i&lt;=q;++i)&#123; Copy(i-1,i,n); if (cmd[i]==0)&#123; int l=ql[i],r=qr[i]; int ans=0; for (register int j=0;j&lt;i;++j)&#123; bool flag=false; for (register int k=l;k&lt;r;++k)&#123; if (a[j][k]==0) &#123; flag=true;break; &#125; &#125; if (flag==false)&#123; ans++; &#125; &#125; printf(\"%d\\n\",ans); &#125; else &#123; int pos=qval[i]; a[i][pos]=!a[i][pos]; &#125; &#125; return 0; &#125;&#125; subtask2:这个部分分思维难度比较大，考虑到一个灯的贡献，如果它在$t_1$时刻被点亮，而在$t_2$时刻被熄灭，发现它对答案的贡献是$t_2-t_1$ 不妨记录一个$lst$，代表最后一次这个路灯被点亮/熄灭的时刻，还有一个$ans$，对于$t \\in [1,lst]$如果$t$时，$a[i]==1$，那么$ans[i]++$。 每次Update时这样更新$ans$： 1234if (a[pos]==0)&#123; ans[pos]+=t-lst[pos];&#125;lst[pos]=t; 查询时则是，把前缀和分为两个部分记录： 1ans[l]+(t-lst[l])*a[l] 1234567891011121314151617181920212223242526namespace Special_2&#123; int lst[MAX];//最后一次这个路灯被点亮/熄灭的时刻 int ans[MAX],a[MAX]; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0'; for (register int i=1;i&lt;=n;++i) &#123; if (a[i]==1) lst[i]=0; else lst[i]=-1; &#125; for (register int t=1;t&lt;=q;++t)&#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; printf(\"%d\\n\",ans[l]+(t-lst[l])*a[l]); &#125; else &#123; int pos=qval[t]; a[pos]=!a[pos]; if (a[pos]==0)&#123; ans[pos]+=t-lst[pos]; &#125; lst[pos]=t; &#125; &#125; return 0; &#125;&#125; subtask3： 对于区间$[l,r-1]$它全部被点亮的时刻之和，就是$[l,r-1]$所有路灯之中，最后一个被点亮的时刻$lst$，用现在时刻$t$减去$lst$即可。 维护一个支持单点覆盖，区间求最大值的线段树即可。 初始化成$INF$，如果查询结果是$INF$，说明这个区间没有灯被点亮，输出$0$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace SegmentTree&#123; struct node&#123; int l,r; int maxn; &#125;tree[1000005*4]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].maxn=0x7fffffff; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int pos,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].maxn=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val); else Update(rc,pos,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;namespace Special_3&#123; inline int Solve(int n,int q)&#123; //printf(\"coming into 3\\n\"); Build(1,1,n); for (register int i=1;i&lt;=n;++i)&#123; if ((s[i]-'0')==1) Update(1,i,0); &#125; for (register int t=1;t&lt;=q;++t) &#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; int ans=Query(1,l,r-1); if (ans==0x7fffffff) puts(\"0\");//这条路上面有灯从未被点亮 else printf(\"%d\\n\",t-ans); &#125; else &#123; int i=qval[t]; Update(1,i,t); &#125; &#125; return 0; &#125;&#125; subtask4:不知道怎么搞。 $60pt$代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;bits/stdc++.h&gt;#define MAXN 205#define MAX 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;/*把询问离线下来 */int cmd[MAX],ql[MAX],qr[MAX],qval[MAX],vis[MAX];char opr[10],s[MAX];bool flag2,flag3;inline void ReadQuerys(int q)&#123; flag2=flag3=true; for (register int i=1;i&lt;=q;++i)&#123; scanf(\"%s\",opr); if (opr[0]=='q')&#123; cmd[i]=0; int l=read(),r=read(); if (r!=l+1) flag2=false; ql[i]=l,qr[i]=r; &#125; else &#123; cmd[i]=1; int pos=read(); if (vis[pos]==1) flag3=false; vis[pos]=1; qval[i]=pos; &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int maxn; &#125;tree[1000005*4]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].maxn=0x7fffffff; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int pos,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].maxn=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val); else Update(rc,pos,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;namespace Special_3&#123; inline int Solve(int n,int q)&#123; //printf(\"coming into 3\\n\"); Build(1,1,n); for (register int i=1;i&lt;=n;++i)&#123; if ((s[i]-'0')==1) Update(1,i,0); &#125; for (register int t=1;t&lt;=q;++t) &#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; int ans=Query(1,l,r-1); if (ans==0x7fffffff) puts(\"0\");//这条路上面有灯从未被点亮 else printf(\"%d\\n\",t-ans); &#125; else &#123; int i=qval[t]; Update(1,i,t); &#125; &#125; return 0; &#125;&#125;namespace Special_2&#123; int lst[MAX];//最后一次这个路灯被点亮的时刻 int ans[MAX],a[MAX]; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0'; for (register int i=1;i&lt;=n;++i) &#123; if (a[i]==1) lst[i]=0; else lst[i]=-1; &#125; for (register int t=1;t&lt;=q;++t)&#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; printf(\"%d\\n\",ans[l]+(t-lst[l])*a[l]); &#125; else &#123; int pos=qval[t]; a[pos]=!a[pos]; if (a[pos]==0)&#123; ans[pos]+=t-lst[pos]; &#125; lst[pos]=t; &#125; &#125; return 0; &#125;&#125;namespace BruteForce&#123; int a[MAXN][MAXN]; inline void Copy(int i,int j,int n)&#123;//Copy i to j for (register int k=1;k&lt;=n;++k)&#123; a[j][k]=a[i][k]; &#125; &#125; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0'; for (register int i=1;i&lt;=q;++i)&#123; Copy(i-1,i,n); if (cmd[i]==0)&#123; int l=ql[i],r=qr[i]; int ans=0; for (register int j=0;j&lt;i;++j)&#123; bool flag=false; for (register int k=l;k&lt;r;++k)&#123; if (a[j][k]==0) &#123; flag=true;break; &#125; &#125; if (flag==false)&#123; ans++; &#125; &#125; printf(\"%d\\n\",ans); &#125; else &#123; int pos=qval[i]; a[i][pos]=!a[i][pos]; &#125; &#125; return 0; &#125;&#125;int main()&#123; int n=read(),q=read(); scanf(\"%s\",s+1); ReadQuerys(q); if (n&lt;=100&amp;&amp;q&lt;=100) return BruteForce::Solve(n,q); if (flag2) return Special_2::Solve(n,q); if (flag3) return Special_3::Solve(n,q); puts(\"you are a alb!\"); return 0;&#125; $100pts$思路： 不妨考虑打一个巨大的表（误，其中表的第$i$行第$j$列表示询问$[i,j]$的答案。 如何维护这个表，延续我们subtask2的思路，考虑到一个灯的贡献，如果它在$t_1$时刻被点亮，而在$t_2$时刻被熄灭，发现它对答案的贡献是$t_2-t_1$，而这一个灯会对整个区间做出贡献，考虑加入一个灯，连成的全部被点亮的灯的区间是$[l,r]$，灯的下标为$x$，那么这个灯的加入会对左端点在$[l,x]$，右端点在$[x,r]$的询问造成贡献，熄灭也是同理。 关键问题来了，我们要对这个矩形加上多少，一个灯的贡献是它被点亮的所有时刻之和减去它被熄灭的所有时刻之和，所以亮起我们加上$-t$，熄灭加上$t$，如果询问时两点已经联通，那么加上$t$。 注意到我们很难处理区间修改，单点查询的问题，不妨做一次差分，变成区间查询，单点修改，可以CDQ分治或者树套树维护。 CDQ分治代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;#define MAXN 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void write(register int x)&#123; if (x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int m;namespace BIT&#123; int C[MAXN]; #define lowbit(x) (x&amp;(-x)) inline int Query(int k)&#123; int ans=0; for (register int i=k;i&gt;=1;i-=lowbit(i))&#123; ans+=C[i]; &#125; return ans; &#125; inline void Update(int k,int val)&#123; for (register int i=k;i&lt;MAXN;i+=lowbit(i))&#123; C[i]+=val; &#125; &#125;&#125;using namespace BIT;struct node&#123; int t,x,y,id; int type,val,ans;&#125;;node F[MAXN*4];int tot,n;inline void Add(int tim,int type,int x,int y,int val,int id)&#123; F[++tot].t=tim; F[tot].x=x; F[tot].y=y; F[tot].type=type; F[tot].val=val; F[tot].id=id; F[tot].ans=0;&#125;inline bool cmp1(const node &amp;A,const node &amp;B)&#123; if (A.t!=B.t) return A.t&lt;B.t; if (A.x!=B.x) return A.x&lt;B.x; return A.y&lt;B.y;&#125;inline bool cmp2(const node &amp;A,const node &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; return A.y&lt;B.y;&#125;inline bool cmp3(const node &amp;A,const node &amp;B)&#123; return A.y&lt;B.y;&#125;node tempF[MAXN*4];inline void Msort(int l,int r)&#123; int mid=(l+r)/2; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if ((k&gt;r)||(j&lt;=mid&amp;&amp;cmp2(F[j],F[k]))) tempF[i]=F[j++]; else tempF[i]=F[k++]; &#125; for (register int i=l;i&lt;=r;++i)&#123; F[i]=tempF[i]; &#125;&#125;//1 query 2 updatevoid CDQ(int l,int r)&#123; if (l==r) return ; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); int p=l-1; for (register int i=mid+1;i&lt;=r;++i)&#123; while (p&lt;mid&amp;&amp;F[p+1].x&lt;=F[i].x)&#123;++p;if (F[p].type==2) Update(F[p].y,F[p].val);&#125; if (F[i].type==1) F[i].ans+=Query(F[i].y); &#125; for (register int i=l;i&lt;=p;++i)&#123; if (F[i].type==2) Update(F[i].y,-F[i].val); &#125; Msort(l,r);&#125;inline void AddRec(int tim,int x1,int y1,int x2,int y2,int val)&#123; Add(tim,2,x1-1,y1-1,val,0); Add(tim,2,x1-1,y2,-val,0); Add(tim,2,x2,y1-1,-val,0); Add(tim,2,x2,y2,val,0);&#125;char s[MAXN];set&lt;int&gt;S;#define Iter set&lt;int&gt;::iteratorinline int GetPre(const int &amp;A)&#123; Iter it=S.lower_bound(A); return *--it;&#125;inline int GetNex(const int &amp;A)&#123; Iter it=S.upper_bound(A); return *it;&#125;int Ans[MAXN];int main()&#123; n=read(),m=read(); scanf(\"%s\",s+1); for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i); S.insert(0); S.insert(n+1); int cntq=0; char opr[10]; for (register int i=1;i&lt;=m;++i)&#123; scanf(\"%s\",opr); if (opr[0]=='q')&#123; int l=read(),r=read(); Add(i,1,l,r-1,0,++cntq); if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') Ans[cntq]+=i; &#125; else &#123; int pos=read(); s[pos]=s[pos]=='1'?'0':'1'; if (s[pos]=='1')&#123;//联通 int l=GetPre(pos)+1,r=GetNex(pos)-1; S.erase(pos); AddRec(i,l+1,pos+1,pos+1,r+1,-i); &#125; else &#123; int l=GetPre(pos)+1,r=GetNex(pos)-1; S.insert(pos); AddRec(i,l+1,pos+1,pos+1,r+1,i); &#125; &#125; &#125; sort(F+1,F+1+tot,cmp1); CDQ(1,tot); for (register int i=1;i&lt;=tot;++i)&#123; if (F[i].type==1)&#123; Ans[F[i].id]+=F[i].ans; &#125; &#125; for (register int i=1;i&lt;=cntq;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; 树套树代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define MAXN 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void write(register int x)&#123; if (x&gt;=10) write(x/10); putchar(x%10+'0');&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val; &#125;tree[MAXN*50]; int tot; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; void Update(int &amp;i,int pos,int val,int l,int r)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].val+=val; return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val,l,mid); else Update(rc,pos,val,mid+1,r); pushup(i); &#125; int Query(int i,int L,int R,int l,int r)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].val; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans+=Query(lc,L,R,l,mid); if (mid&lt;R) ans+=Query(rc,L,R,mid+1,r); return ans; &#125;&#125;using namespace SegmentTree;#define lowbit(x) (x&amp;-x)inline void Add(int x,int y,int val)&#123; for (register int i=x;i&lt;MAXN;i+=lowbit(i))&#123; Update(rt[i],y,val,1,MAXN-1); &#125;&#125;inline int Ask(int x,int y)&#123; int ans=0; for (register int i=x;i&gt;0;i-=lowbit(i))&#123; ans+=Query(rt[i],1,y,1,MAXN-1); &#125; return ans;&#125;int n,m;inline void AddRec(int x1,int y1,int x2,int y2,int val)&#123; Add(x1-1,y1-1,val); Add(x1-1,y2,-val); Add(x2,y1-1,-val); Add(x2,y2,val);&#125;char s[MAXN];set&lt;int&gt;S;#define Iter set&lt;int&gt;::iteratorinline int GetPre(const int &amp;A)&#123; Iter it=S.lower_bound(A); return *--it;&#125;inline int GetNex(const int &amp;A)&#123; Iter it=S.upper_bound(A); return *it;&#125;int Ans[MAXN];int main()&#123; n=read(),m=read(); scanf(\"%s\",s+1); for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i); S.insert(0); S.insert(n+1); int cntq=0; char opr[10]; for (register int i=1;i&lt;=m;++i)&#123; scanf(\"%s\",opr); if (opr[0]=='q')&#123; int l=read(),r=read(); int ans=Ask(l,r-1); if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') ans+=i; printf(\"%d\\n\",ans); &#125; else &#123; int pos=read(); s[pos]=s[pos]=='1'?'0':'1'; if (s[pos]=='1')&#123;//联通 int l=GetPre(pos)+1,r=GetNex(pos)-1; S.erase(pos); AddRec(l+1,pos+1,pos+1,r+1,-i); &#125; else &#123; int l=GetPre(pos)+1,r=GetNex(pos)-1; S.insert(pos); AddRec(l+1,pos+1,pos+1,r+1,i); &#125; &#125; &#125;&#125; 卡常代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include &lt;bits/stdc++.h&gt;#define MAXN 205#define MAX 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;void write(register int x)&#123; if (x&gt;=10) write(x/10); putchar(x%10+'0');&#125;inline void Print(int x)&#123; if (x==0) puts(\"0\"); else write(x),putchar('\\n');&#125;/*把询问离线下来 */int cmd[MAX],ql[MAX],qr[MAX],qval[MAX],vis[MAX];char opr[10],s[MAX];bool flag2,flag3;inline void ReadQuerys(int q)&#123; flag2=flag3=true; for (register int i=1;i&lt;=q;++i)&#123; scanf(\"%s\",opr); if (opr[0]=='q')&#123; cmd[i]=0; int l=read(),r=read(); if (r!=l+1) flag2=false; ql[i]=l,qr[i]=r; &#125; else &#123; cmd[i]=1; int pos=read(); if (vis[pos]==1) flag3=false; vis[pos]=1; qval[i]=pos; &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int maxn; &#125;tree[1000005*4]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].maxn=0x7fffffff; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int pos,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].maxn=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val); else Update(rc,pos,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;namespace Special_3&#123; inline int Solve(int n,int q)&#123; Build(1,1,n); for (register int i=1;i&lt;=n;++i)&#123; if ((s[i]-'0')==1) Update(1,i,0); &#125; for (register int t=1;t&lt;=q;++t) &#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; int ans=Query(1,l,r-1); if (ans==0x7fffffff) puts(\"0\");//这条路上面有灯从未被点亮 else Print(t-ans); &#125; else &#123; int i=qval[t]; Update(1,i,t); &#125; &#125; return 0; &#125;&#125;namespace Special_2&#123; int lst[MAX];//最后一次这个路灯被点亮的时刻 int ans[MAX],a[MAX]; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[i]=s[i]-'0'; for (register int i=1;i&lt;=n;++i) &#123; if (a[i]==1) lst[i]=0; else lst[i]=-1; &#125; for (register int t=1;t&lt;=q;++t)&#123; if (cmd[t]==0)&#123; int l=ql[t],r=qr[t]; Print(ans[l]+(t-lst[l])*a[l]); &#125; else &#123; int pos=qval[t]; a[pos]=!a[pos]; if (a[pos]==0)&#123; ans[pos]+=t-lst[pos]; &#125; lst[pos]=t; &#125; &#125; return 0; &#125;&#125;namespace BruteForce&#123; int a[MAXN][MAXN]; inline void Copy(int i,int j,int n)&#123;//Copy i to j for (register int k=1;k&lt;=n;++k)&#123; a[j][k]=a[i][k]; &#125; &#125; inline int Solve(int n,int q)&#123; for (register int i=1;i&lt;=n;++i) a[0][i]=s[i]-'0'; for (register int i=1;i&lt;=q;++i)&#123; Copy(i-1,i,n); if (cmd[i]==0)&#123; int l=ql[i],r=qr[i]; int ans=0; for (register int j=0;j&lt;i;++j)&#123; bool flag=false; for (register int k=l;k&lt;r;++k)&#123; if (a[j][k]==0) &#123; flag=true;break; &#125; &#125; if (flag==false)&#123; ans++; &#125; &#125; Print(ans); &#125; else &#123; int pos=qval[i]; a[i][pos]=!a[i][pos]; &#125; &#125; return 0; &#125;&#125;namespace Correct&#123; int Max; namespace BIT&#123; int C[MAX]; #define lowbit(x) (x&amp;(-x)) inline int Query(int k)&#123; int ans=0; for (register int i=k;i&gt;=1;i-=lowbit(i))&#123; ans+=C[i]; &#125; return ans; &#125; inline void Update(int k,int val)&#123; for (register int i=k;i&lt;=Max;i+=lowbit(i))&#123; C[i]+=val; &#125; &#125; &#125; using namespace BIT; struct node&#123; int t,x,y,id; int type,val,ans; &#125;; node F[MAX*4]; int tot; inline void Add(int tim,int type,int x,int y,int val,int id)&#123; F[++tot].t=tim; F[tot].x=x; F[tot].y=y; F[tot].type=type; F[tot].val=val; F[tot].id=id; F[tot].ans=0; &#125; inline bool cmp1(const node &amp;A,const node &amp;B)&#123; if (A.t!=B.t) return A.t&lt;B.t; if (A.x!=B.x) return A.x&lt;B.x; return A.y&lt;B.y; &#125; inline bool cmp2(const node &amp;A,const node &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; return A.y&lt;B.y; &#125; inline bool cmp3(const node &amp;A,const node &amp;B)&#123; return A.y&lt;B.y; &#125; node tempF[MAX*4]; inline void Msort(int l,int r)&#123; int mid=(l+r)/2; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if ((k&gt;r)||(j&lt;=mid&amp;&amp;cmp2(F[j],F[k]))) tempF[i]=F[j++]; else tempF[i]=F[k++]; &#125; for (register int i=l;i&lt;=r;++i)&#123; F[i]=tempF[i]; &#125; &#125; void CDQ(int l,int r)&#123; if (l==r) return ; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); int p=l-1; for (register int i=mid+1;i&lt;=r;++i)&#123; while (p&lt;mid&amp;&amp;F[p+1].x&lt;=F[i].x)&#123;++p;if (F[p].type==2) Update(F[p].y,F[p].val);&#125; if (F[i].type==1) F[i].ans+=Query(F[i].y); &#125; for (register int i=l;i&lt;=p;++i)&#123; if (F[i].type==2) Update(F[i].y,-F[i].val); &#125; Msort(l,r); &#125; inline void AddRec(int tim,int x1,int y1,int x2,int y2,int val)&#123; Add(tim,2,x1-1,y1-1,val,0); Add(tim,2,x1-1,y2,-val,0); Add(tim,2,x2,y1-1,-val,0); Add(tim,2,x2,y2,val,0); &#125; set&lt;int&gt;S; #define Iter set&lt;int&gt;::iterator inline int GetPre(const int &amp;A)&#123; Iter it=S.lower_bound(A); return *--it; &#125; inline int GetNex(const int &amp;A)&#123; Iter it=S.upper_bound(A); return *it; &#125; int Ans[MAX]; inline int Solve(int n,int q)&#123; Max=q; for (register int i=1;i&lt;=n;++i) if (s[i]=='0') S.insert(i); S.insert(0); S.insert(n+1); int cntq=0; for (register int i=1;i&lt;=q;++i)&#123; if (cmd[i]==0)&#123; int l=ql[i],r=qr[i]; //printf(\"l,r: %d %d\\n\",l,r); Add(i,1,l,r-1,0,++cntq); if (GetNex(l)&gt;r-1&amp;&amp;s[l]=='1'&amp;&amp;s[r-1]=='1') Ans[cntq]+=i; &#125; else &#123; int pos=qval[i]; //printf(\"%d\\n\",pos); s[pos]=s[pos]=='1'?'0':'1'; if (s[pos]=='1')&#123; int l=GetPre(pos)+1,r=GetNex(pos)-1; S.erase(pos); AddRec(i,l+1,pos+1,pos+1,r+1,-i); &#125; else &#123; int l=GetPre(pos)+1,r=GetNex(pos)-1; S.insert(pos); AddRec(i,l+1,pos+1,pos+1,r+1,i); &#125; &#125; &#125; sort(F+1,F+1+tot,cmp1); CDQ(1,tot); for (register int i=1;i&lt;=tot;++i)&#123; if (F[i].type==1)&#123; Ans[F[i].id]+=F[i].ans; &#125; &#125; for (register int i=1;i&lt;=cntq;++i)&#123; Print(Ans[i]); &#125; return 0; &#125;&#125; int main()&#123; int n=read(),q=read(); scanf(\"%s\",s+1); ReadQuerys(q); if (n&lt;=100&amp;&amp;q&lt;=100) return BruteForce::Solve(n,q); if (flag2) return Special_2::Solve(n,q); if ((n!=500||q!=300000)&amp;&amp;flag3) return Special_3::Solve(n,q); return Correct::Solve(n,q); return 0;&#125;","categories":[],"tags":[{"name":"APIO","slug":"APIO","permalink":"https://gaisaiyuno.github.io/tags/APIO/"}]},{"title":"BZOJ 4987 Tree","slug":"BZOJ-4987-Tree","date":"2019-08-25T07:39:12.000Z","updated":"2019-08-25T08:03:46.231Z","comments":true,"path":"archives/e7d175a4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e7d175a4.html","excerpt":"","text":"传送门 先上一个结论，所有$k$个节点应该构成一棵树，形状是原树的直径连着一堆子树，其中直径只经过一遍，子树的所有边经过两次，走法就是从直径的一段走到另一端，但是中途会离开直径，到某个和当前节点相连的子树逛一圈再回到这个节点。 所以子状态就有了，$dp[u][j][0/1/2]$表示$u$的子树里面选$j$个点，而且$u$的子树里面有多少直径的端点。 分六种情况考虑。 $dp[u][j+k][0]$只能从$dp[u][j][0]$，$dp[v][k][0]$转移而来，显然边$$不属于直径，所以要算两遍： 1chkmin(dp[u][j+k][0],dp[u][j][0]+dp[v][k][0]+len*2); $dp[u][j+k][1]$：转移有两种情况： $a.dp[u][j][1],dp[v][k][0]$转移而来，如图所示，直径一定穿过$u$，所以$$算两次。 1chkmin(dp[u][j+k][1],dp[u][j][1]+dp[v][k][0]+len*2); $b.dp[u][j][0],dp[v][k][1]$转移而来，如图所示，直径穿过$$，$$只算一次。 1chkmin(dp[u][j+k][1],dp[u][j][0]+dp[v][k][1]+len); $dp[u][j+k][2]$：转移有三种情况： $a.dp[u][j][0],dp[v][k][2]/dp[u][j][2],dp[v][k][0]$，转移而来，发现直径只可能整个缩在$u/v$的子树之中，所以算两次。 12chkmin(dp[u][j+k][2],dp[u][j][0]+dp[v][k][2]+len*2);chkmin(dp[u][j+k][2],dp[u][j][2]+dp[v][k][0]+len*2); $b.dp[u][j][1],dp[v][k][1]$转移而来，发现直径经过$$，所以算一次 1chkmin(dp[u][j+k][2],dp[u][j][1]+dp[v][k][1]+len); 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define MAXN 3005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int n,m;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;int dp[MAXN][MAXN][4],sz[MAXN];inline void chkmin(int &amp;a,int b)&#123; if (a&gt;b) a=b;&#125;void dfs(int u,int father)&#123; sz[u]=1; dp[u][1][0]=dp[u][1][1]=dp[u][1][2]=0; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,len=G[u][i].len; if (v==father) continue; dfs(v,u); for (register int j=min(m,sz[u]);j&gt;=1;--j)&#123; for (register int k=1;k&lt;=min(m,sz[v]);++k)&#123; if (j+k&gt;m) continue; chkmin(dp[u][j+k][0],dp[u][j][0]+dp[v][k][0]+len*2); chkmin(dp[u][j+k][1],dp[u][j][1]+dp[v][k][0]+len*2); chkmin(dp[u][j+k][1],dp[u][j][0]+dp[v][k][1]+len); chkmin(dp[u][j+k][2],dp[u][j][1]+dp[v][k][1]+len); chkmin(dp[u][j+k][2],dp[u][j][0]+dp[v][k][2]+len*2); chkmin(dp[u][j+k][2],dp[u][j][2]+dp[v][k][0]+len*2); &#125; &#125; sz[u]+=sz[v]; &#125;&#125;int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); &#125; memset(dp,0x3f,sizeof(dp)); dfs(1,1); int ans=0x7fffffff; for (register int i=1;i&lt;=n;++i) ans=min(ans,dp[i][m][2]); printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P4516 [JSOI2018]潜入行动","slug":"P4516-JSOI2018-潜入行动","date":"2019-08-25T07:05:15.000Z","updated":"2019-08-25T07:34:06.773Z","comments":true,"path":"archives/8c7351eb.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8c7351eb.html","excerpt":"","text":"传送门 考虑dp状态$dp[u][i][0/1][0/1]$表示dp到节点$u$，$u$的子树里面放了$i$个监听设备，$u$自己有没有被放，$u$自己有没有被监听。 注意到我们要满足题目的条件，所以只有u的子树内的其他点（不包含u）都被监听，才会算入dp方案数。 接下来是恶心的分类讨论： $1.dp[u][i][0][0]$，此时我们只能有一种选择，即使转移状态是$u$既不被支配，又没有放，$v$不能放，否则支配了$u$，但是$v$必须被支配（$u$无法支配$v$），要不然不符合上面我们的条件。 1Inc(dp[u][j+k][0][0],t[j][0][0]*dp[v][k][0][1]);//v一定要被支配，但是v不能放，否则支配了u $2.dp[u][i][0][1]$ 这里我们根据转移状态，再分两种情况： $a.转移状态是dp[u][j][0][0]$：此时$v$必须放，来支配$u$，而且$v$必须被支配，因为$u$无法支配$v$。 1Inc(dp[u][j+k][0][1],t[j][0][0]*dp[v][k][1][1]);//如果u只被支配，转移状态是u什么都不放，那么v可以既被支配又放，此时u什么都不放，也不被支配都可以 $b.转移状态是dp[u][j][0][1]$：此时$v$放不放无所谓，因为$u$已经被支配了，但是$v$必须被支配，因为$u$无法支配$v$ 1Inc(dp[u][j+k][0][1],t[j][0][1]*(dp[v][k][1][1]+dp[v][k][0][1]));//转移状态是u被支配，那么v只要被支配即可，注意到v放什么不会影响到u的状态 $3.dp[u][j][1][0]$此时转移状态只能是$u$只放而不被支配，后面$v$只要不放即可。 为什么能从$dp[v][k][0][0]$转移而来，是因为$u$放了，可以支配$v$，满足上面的条件。 1Inc(dp[u][j+k][1][0],t[j][1][0]*(dp[v][k][0][0]+dp[v][k][0][1]));//如果u只被放，转移状态只能是u只被放，所以v不能放，有两种情况 $4.dp[u][j][1][1]$ 这里我们根据转移状态，再分两种情况： $a.转移状态是dp[u][j][1][1]$此时随便乱搞，其他四种情况都是合法的。 1Inc(dp[u][j+k][1][1],t[j][1][1]*(dp[v][k][0][0]+dp[v][k][0][1]+dp[v][k][1][0]+dp[v][k][1][1]));//如果u既被支配又被放，转移状态是u既被支配又被放，那么剩下随便乱搞 $a.转移状态时dp[u][j][1][0]$此时$v$只要能够支配$u$即可，所以$v$要放。 1Inc(dp[u][j+k][1][1],t[j][1][0]*(dp[v][k][1][1]+dp[v][k][1][0]));//转移状态是u只被放，那v必须放，来支配u，注意到v可以不被支配，因为u放了 注意到$dp$过程无法改变$u$节点有没有放的事实，即$dp[][][0][0/1]$只能从$dp[][][0][0/1]$转移而来，同理$dp[][][1][0/1]$只能从$dp[][][1][0/1]$转移而来。 注意此题卡内存，以下代码会MLE。（防抄袭） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define MOD 1000000007#define MAXN 100005#define MAXK 105#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int dp[MAXN][MAXK][2][2],t[MAXK][2][2],sz[MAXN],m;#define Set(x,y) t[j][x][y]=dp[u][j][x][y];dp[u][j][x][y]=0inline void Inc(int &amp;a,int b)&#123; a=(a+b)%MOD;&#125;void dfs(int u,int father)&#123; sz[u]=1; dp[u][1][1][0]=dp[u][0][0][0]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v==father) continue; dfs(v,u); int Max1=min(m,sz[u]),Max2=min(m,sz[v]); for (register int j=0;j&lt;=Max1;++j)&#123; Set(0,0); Set(0,1); Set(1,0); Set(1,1); &#125; for (register int j=0;j&lt;=Max1;++j)&#123; for (register int k=0;k&lt;=Max2;++k)&#123; if (j+k&gt;m) continue; //printf(\"In\"); Inc(dp[u][j+k][0][0],t[j][0][0]*dp[v][k][0][1]);//v一定要被支配，但是v不能放，否则支配了u Inc(dp[u][j+k][0][1],t[j][0][0]*dp[v][k][1][1]);//如果u只被支配，转移状态是u什么都不放，那么v可以既被支配又放，此时u什么都不放，也不被支配都可以 Inc(dp[u][j+k][0][1],t[j][0][1]*(dp[v][k][1][1]+dp[v][k][0][1]));//转移状态是u被支配，那么v只要被支配即可，注意到v放什么不会影响到u的状态 Inc(dp[u][j+k][1][0],t[j][1][0]*(dp[v][k][0][0]+dp[v][k][0][1]));//如果u只被放，转移状态只能是u只被放，所以v不能放，有两种情况 Inc(dp[u][j+k][1][1],t[j][1][1]*(dp[v][k][0][0]+dp[v][k][0][1]+dp[v][k][1][0]+dp[v][k][1][1]));//如果u既被支配又被放，转移状态是u既被支配又被放，那么剩下随便乱搞 Inc(dp[u][j+k][1][1],t[j][1][0]*(dp[v][k][1][1]+dp[v][k][1][0]));//转移状态是u只被放，那v必须放，来支配u，注意到v可以不被支配，因为u放了 //注意到dp过程无法改变u节点有没有放的事实，即dp[][][0][0/1]只能从dp[][][0][0/1]转移而来，同理dp[][][1][0/1]只能从dp[][][1][0/1]转移而来 &#125; &#125; sz[u]+=sz[v]; &#125;&#125;#undef intint main()&#123;#define int long long int n=read();m=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; dfs(1,1); printf(\"%lld\\n\",(dp[1][m][0][1]+dp[1][m][1][1])%MOD);//1一定被支配&#125;","categories":[],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"容斥+背包学习笔记","slug":"容斥-背包学习笔记","date":"2019-08-25T03:10:44.000Z","updated":"2019-08-25T04:28:07.892Z","comments":true,"path":"archives/65213f8a.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/65213f8a.html","excerpt":"","text":"有时候，我们在做背包问题时会遇到如下情况，给你一大堆询问，要你求出满足某种限制，填满背包的方法数。 先来一道例题： 例题1：P1450 [HAOI2008]硬币购物 乍眼一看似乎是一个裸的完全背包，但是注意到询问组数较多，每次跑一遍完全背包绝对会炸掉，考虑预处理出不带限制的方法数，然后用容斥除去不满足限制的方法。 预处理，用题目的四种硬币凑出$x$元的钱共有$f(x)$种方法： 12345678inline void Init()&#123; dp[0]=1; for (register int i=1;i&lt;=4;++i)&#123; for (register int j=c[i];j&lt;MAXN;++j)&#123; dp[j]+=dp[j-c[i]]; &#125; &#125;&#125; 简单容斥： 12345678910for (register int i=0;i&lt;16;++i)&#123; int f=1,sum=0; for (register int j=1;j&lt;=4;++j)&#123; if (i&amp;(1&lt;&lt;(j-1))) &#123; f*=-1; sum+=(d[j]+1)*c[j]; &#125; &#125; if (s-sum&gt;=0) ans+=f*dp[s-sum];&#125; 为什么是$(d[j]+1)*c[j]$，不妨考虑先用$d[j]+1$个硬币$j$，这样肯定是不符合的，所以要减去。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int c[5],d[5];int dp[MAXN];inline void Init()&#123; dp[0]=1; for (register int i=1;i&lt;=4;++i)&#123; for (register int j=c[i];j&lt;MAXN;++j)&#123; dp[j]+=dp[j-c[i]]; &#125; &#125;&#125;#undef intint main()&#123;#define int long long for (register int i=1;i&lt;=4;++i) c[i]=read(); Init(); int tot=read(); while (tot--)&#123; for (register int i=1;i&lt;=4;++i) d[i]=read(); int s=read(); int ans=0; for (register int i=0;i&lt;16;++i)&#123; int f=1,sum=0; for (register int j=1;j&lt;=4;++j)&#123; if (i&amp;(1&lt;&lt;(j-1))) &#123; f*=-1; sum+=(d[j]+1)*c[j]; &#125; &#125; if (s-sum&gt;=0) ans+=f*dp[s-sum]; &#125; printf(\"%lld\\n\",ans); &#125;&#125; 例题2:P4141 消失之物 跟上面一样，先预处理出来没有任何限制的方法数，注意是01背包： 123456f[0]=1;for (register int i=1;i&lt;=n;++i)&#123; for (register int j=m;j&gt;=w[i];--j)&#123; f[j]=(f[j]+f[j-w[i]])%MOD; &#125;&#125; 这里的容斥就比较简单： 1234567ans[i][0]=1;for (register int j=1;j&lt;w[i];++j)&#123; ans[i][j]=f[j];&#125;for (register int j=w[i];j&lt;=m;++j)&#123; ans[i][j]=(f[j]-ans[i][j-w[i]]+MOD)%MOD;//容斥一下&#125; 对于$&lt;w[i]$的情况，一定里面合法方案没有$w[i]$这个物品，所以$ans[i][j]=f[j]$ 对于$\\geq w[i]$的情况，需要进行容斥，$ans[i][j]=f[j]-ans[i][j-w[i]]$，注意到是$ans[i][j-w[i]]$而不是$f[j-w[i]]$，原因是$f[j-w[i]]$的方案里面可能包含$w[i]$。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAXN 2005#define MOD 10using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;static int w[MAXN],f[MAXN],ans[MAXN][MAXN];int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i) w[i]=read(); f[0]=1; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=m;j&gt;=w[i];--j)&#123; f[j]=(f[j]+f[j-w[i]])%MOD; &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; ans[i][0]=1; for (register int j=1;j&lt;w[i];++j)&#123; ans[i][j]=f[j]; &#125; for (register int j=w[i];j&lt;=m;++j)&#123; ans[i][j]=(f[j]-ans[i][j-w[i]]+MOD)%MOD;//容斥一下 &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=m;++j)&#123; putchar(ans[i][j]+'0'); &#125; puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"背包","slug":"背包","permalink":"https://gaisaiyuno.github.io/tags/背包/"},{"name":"容斥","slug":"容斥","permalink":"https://gaisaiyuno.github.io/tags/容斥/"}]},{"title":"CDQ分治优化斜率优化","slug":"CDQ分治优化斜率优化","date":"2019-08-20T13:44:53.000Z","updated":"2019-08-25T04:27:48.979Z","comments":true,"path":"archives/b7a912cc.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b7a912cc.html","excerpt":"","text":"例题1：P2365 任务安排 我知道你们会$n^2$大暴力，也会$O(n)$普通斜率优化，但是不妨提高一下我们的姿势水平，假设$1 \\le N \\le 100000$，而且$T_i$和$C_i$不一定是正整数。 朴素$dp$方程：$dp[i]=dp[j]-(s+sumt[i]) \\times sumc[j]+sumt[i]\\times sumc[i]+s\\times sumc[n]$ $x=sumc[j],y=dp[j],k=s+sumt[i],b=sumt[i]\\times sumc[i]+s\\times sumc[n]$ 式子化成$dp[i]=y-kx+b$的形式。 注意到$sumt,sumc$不一定单调，于是我们需要动态地在凸壳上面插入和查询点，但是这样写太过naive了，考虑离线，使用CDQ分治计算答案，每次我们建出左半边的凸壳，查询右半边凸壳的答案，伪代码如下： 1234567891011121314151617181920procedure CDQ(l,r)&#123; if(l==r)&#123; 用a[l]对应的dp值来更新a的(x,y) return &#125; mid=(l+r)/2 把[l,r]内的元素按id分成两个区间，id&lt;=mid的分到[l,mid],否则分到[mid+1,r] CDQ(l,mid),先递归计算id值小的 把[l,mid]区间对应的点建出凸壳，用于下一步更新[mid+1,r]的dp值 for(k in [mid+1,r])&#123; 用单调队列更新a[k]对应的dp值，因为我们cdq之前按斜率排过序，所以不会出问题 注意到在这里面即使a[k]对应的dp值的最优决策不在[mid+1,r]中，那么回溯到一个更大的区间后，也会被更新到 &#125; CDQ(mid+1,r)，继续递归下去更新 按x,y归并排序[l,mid],[mid+1,r],这样回溯的时候x单调递增，才可以直接单调栈(队列)建凸壳&#125;int main()&#123; 输入 按照斜率对点排序&#125; 摘自巨佬ypy的博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define MAXN 300005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int N,S;int sumT[MAXN],sumC[MAXN];int ans[MAXN];struct Point&#123; double x,y; int id;&#125;p[MAXN],t[MAXN],q[MAXN];inline bool cmp1(const Point &amp;A,const Point &amp;B)&#123; return sumT[A.id]&lt;sumT[B.id];&#125;inline bool cmp2(const Point &amp;A,const Point &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; else return A.y&lt;B.y;&#125;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline double Slope(const Point &amp;A,const Point &amp;B)&#123; return (double)(A.y-B.y)/(double)(A.x-B.x);&#125;inline void Msort1(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (p[i].id&lt;=mid) t[j++]=p[i]; else t[k++]=p[i]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;inline void Msort2(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (j&lt;=mid&amp;&amp;(k&gt;r||cmp2(p[j],p[k]))) t[j++]=p[i];例题 else t[k++]=p[i]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; p[l].x=(double)sumC[p[l].id]; p[l].y=(double)ans[p[l].id]; return ; &#125; int mid=(l+r)&gt;&gt;1; Msort1(l,r); CDQ(l,mid); int head=1,rear=0; for (register int i=l;i&lt;=mid;++i)&#123; while (head&lt;rear&amp;&amp;((q[rear]-q[rear-1])*(p[i]-q[rear-1]))&lt;0) rear--; q[++rear]=p[i]; &#125; for (register int k=mid+1;k&lt;=r;++k)&#123; int i=p[k].id; while (head&lt;rear&amp;&amp;Slope(q[head+1],q[head])&lt;(S+sumT[i])) head++; int j=q[head].id; ans[i]=min(ans[i],ans[j]+sumT[i]*(sumC[i]-sumC[j])+S*(sumC[N]-sumC[j])); &#125; CDQ(mid+1,r); Msort2(l,r);&#125;#undef intint main()&#123;#define int long long N=read(),S=read(); for (register int i=1;i&lt;=N;++i)&#123; sumT[i]=sumT[i-1]+read(); sumC[i]=sumC[i-1]+read(); p[i].id=i; &#125; sort(p+1,p+1+N,cmp1); memset(ans,0x3f,sizeof(ans)); ans[0]=0; CDQ(0,N); printf(\"%lld\\n\",ans[N]);&#125; 例题2：P4655 [CEOI2017]Building Bridges 很容易得出dp方程： $dp[i]=min(dp[i],dp[j]+(h[i]-h[j])^2+w[i-1]-w[j])$其中$w[i]$是前缀和。 考虑斜率优化，化成$dp[i]=dp[j]+h[j]^2-w[j]-2h[i]h[j]+h[i]^2$的形式，设$y=dp[j]+h[j]^2-w[j]$的，$x=h[j]$，$k=2h[i]$，$b=h[i]^2$ 注意到$h[j]$不一定单调，所以需要CDQ分治。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Point&#123; double x,y; int i;&#125;p[MAXN],t[MAXN],q[MAXN];inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline bool cmp1(const Point &amp;A,const Point &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; return A.y&gt;B.y;&#125;int h[MAXN],sum[MAXN],dp[MAXN];inline bool cmp2(const Point &amp;A,const Point &amp;B)&#123; return h[A.i]&lt;h[B.i];&#125;inline void Merge1(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (p[i].i&lt;=mid) t[j++]=p[i]; else t[k++]=p[i]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;inline void Merge2(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (j&lt;=mid&amp;&amp;(k&gt;r||cmp1(p[j],p[k]))) t[i]=p[j++]; else t[i]=p[k++]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; p[l].x=(double)h[l]; p[l].y=(double)dp[l]-sum[l]+h[l]*h[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Merge1(l,r); CDQ(l,mid); int head=1,rear=0; for (register int i=l;i&lt;=mid;++i)&#123; while (head&lt;rear&amp;&amp;(q[rear]-q[rear-1])*(p[i]-q[rear-1])&lt;=0) rear--; q[++rear]=p[i]; &#125; for (register int k=mid+1;k&lt;=r;++k)&#123; int i=p[k].i; while (head&lt;rear&amp;&amp;(q[head+1]-q[head])*Point&#123;1,(double)2*h[i]&#125;&gt;=0) head++; int j=q[head].i; dp[i]=min(dp[i],dp[j]+(h[i]-h[j])*(h[i]-h[j])+sum[i-1]-sum[j]); &#125; CDQ(mid+1,r); Merge2(l,r);&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;=n;++i) h[i]=read(),p[i].i=i; for (register int i=1;i&lt;=n;++i) sum[i]=sum[i-1]+read(); memset(dp,0x3f,sizeof(dp)); dp[1]=0; sort(p+1,p+1+n,cmp2); CDQ(1,n); printf(\"%lld\\n\",dp[n]);&#125; 例题3：P4027 [NOI2007]货币兑换 注意到题目有这么一句话： 必然存在一种最优的买卖方案满足： 每次买进操作使用完所有的人民币； 每次卖出操作卖出所有的金券。 所以我们列出dp方程，$F[i]$表示第$i$天最多的钱数 $F[i]=max(F[i-1],F[j]/(A[j] \\times R[j]+B[j])\\times (A[i]\\times R[j]+B[i]))$ $F[i]=F[i-1]$表示第$i$天什么都不做， $F[i]=F[j]/(A[j] \\times R[j]+B[j]) \\times (A[i] \\times R[j]+B[i])$ 表示把第$j$天的钱全部按照$R[j]$的比例买进股票，然后在第$i$天按照$R[j]$的比例全部卖出。 考虑斜率优化，由于$F[j]/(A[j] \\times R[j]+B[j])$里面只有$j$，不妨考虑换元。 设$F[j]/(A[j] \\times R[j]+B[j])=T$，那么我们有$F[i]=T \\times (A[i] \\times R[j]+B[i])$ 拆开，得$F[i]=T \\times A[i] \\times R[j]+T \\times B[i]$ 令$y=T \\times R[j]$，$x=T$，$k=-B[i]/A[i]$ 直接套用CDQ分治模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define MAXN 300005#define int long long#define INF 1e12using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int N;double S,A[MAXN],B[MAXN],R[MAXN],ans[MAXN];struct Point&#123; double x,y; int id;&#125;p[MAXN],t[MAXN],q[MAXN];inline bool cmp1(const Point &amp;X,const Point &amp;Y)&#123; return -B[X.id]/A[X.id]&gt;-B[Y.id]/A[Y.id];&#125;inline bool cmp2(const Point &amp;A,const Point &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; else return A.y&gt;B.y;&#125;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return &#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return &#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double Slope(const Point &amp;A)&#123; if (A.x==0) return A.y&gt;0?INF:-INF; return A.y/A.x;&#125;inline void Msort1(int l,int r)&#123; int mid=(l+r)&gt;&gt;1ll; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (p[i].id&lt;=mid) t[j++]=p[i]; else t[k++]=p[i]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;inline void Msort2(int l,int r)&#123; int mid=(l+r)&gt;&gt;1ll; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (j&lt;=mid&amp;&amp;(k&gt;r||cmp2(p[j],p[k]))) t[i]=p[j++]; else t[i]=p[k++]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; if (l!=1) ans[l]=max(ans[l],ans[l-1]); p[l].x=ans[l]/(A[l]*R[l]+B[l]); p[l].y=p[l].x*R[l]; return ; &#125; int mid=(l+r)/2; Msort1(l,r); CDQ(l,mid); int head=1,rear=0; for (register int i=l;i&lt;=mid;++i)&#123; while (head&lt;rear&amp;&amp;Slope(q[rear]-q[rear-1])&lt;=Slope(p[i]-q[rear-1])) rear--; q[++rear]=p[i]; &#125; for (register int k=mid+1;k&lt;=r;++k)&#123; int i=p[k].id; while (head&lt;rear&amp;&amp;Slope(q[head+1]-q[head])&gt;=(-B[i]/A[i])) head++; int j=q[head].id; ans[i]=max(ans[i],(ans[j]/(A[j]*R[j]+B[j]))*(A[i]*R[j]+B[i])); &#125; CDQ(mid+1,r); Msort2(l,r);&#125;#undef intint main()&#123;#define int long long N=read(),S=(double)read(); for (register int i=1;i&lt;=N;++i)&#123; cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;R[i]; p[i].id=i; &#125; ans[1]=S; sort(p+1,p+1+N,cmp1); CDQ(1,N); printf(\"%.3f\\n\",ans[N]);&#125; 例题4：Machine Works 题意： 一个公司获得了一个厂房n(10^5)天的使用权和一笔启动资金C(10^9)，准备在n天里租借机器生产来获得收益可以租借的机器有M(10^5)个，每个机器有四个值，D,P,R,G (D&lt;=n, P,R,G都是10^9)表明你可以再第D天花费P费用（首先手里必须有那么多钱）租借这个机器，从D+1天开始该机器每天产生G的收益，在你不需要机器时可以卖掉这个机器，一次获得R的钱 显然可以列出dp方程：$f[i] = max(f[j] - P[i] + R[j] + G[j] * (D[i] - D[j] - 1)) $ 注意到$f[j]&gt;=0$才能转移。 代表你在第$j$天买进机器，然后后面$D[i]-D[j]-1$天使用机器，最后第$i$ 天卖出。 斜率优化比较好推，我就不推了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long long#define INF 1e15#define eps 1e-10using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Machine&#123; int d,p,r,g;&#125;m[MAXN];inline bool cmp(const Machine &amp;A,const Machine &amp;B)&#123; return A.d&lt;B.d;&#125;int n,c,d;int ans[MAXN];struct Point&#123; double x,y; int id;&#125;p[MAXN],t[MAXN],q[MAXN];inline bool cmp1(const Point &amp;A,const Point &amp;B)&#123; return m[A.id].d&lt;m[B.id].d;&#125;inline bool cmp2(const Point &amp;A,const Point &amp;B)&#123; if (A.x!=B.x) return A.x&lt;B.x; else return A.y&lt;B.y;&#125;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double Slope(const Point &amp;A,const Point &amp;B)&#123; return (double)(A.y-B.y)/(double)(A.x-B.x);&#125;inline void Msort1(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (p[i].id&lt;=mid) t[j++]=p[i]; else t[k++]=p[i]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;inline void Msort2(int l,int r)&#123; int mid=(l+r)&gt;&gt;1; int j=l,k=mid+1; for (register int i=l;i&lt;=r;++i)&#123; if (j&lt;=mid&amp;&amp;(k&gt;r||cmp2(p[j],p[k]))) t[i]=p[j++]; else t[i]=p[k++]; &#125; for (register int i=l;i&lt;=r;++i) p[i]=t[i];&#125;void CDQ(int l,int r)&#123; if (l==r)&#123; p[l].x=(double)m[l].g; p[l].y=(double)ans[l]+m[l].r-m[l].g*m[l].d-m[l].g; return ; &#125; int mid=(l+r)&gt;&gt;1; Msort1(l,r); CDQ(l,mid); int head=1,rear=0; for (register int i=l;i&lt;=mid;++i)&#123; if (ans[p[i].id]&lt;0) continue; while (head&lt;rear&amp;&amp;(q[rear]-q[rear-1])*(p[i]-q[rear-1])&gt;=0) rear--; q[++rear]=p[i]; &#125; for (register int k=mid+1;k&lt;=r;++k)&#123; int i=p[k].id; while (head&lt;rear&amp;&amp;(q[head+1]-q[head])*(Point&#123;1,-m[i].d,1926&#125;)&lt;=0) head++; int j=q[head].id; ans[i]=max(ans[i],ans[j]+m[j].r+m[j].g*(m[i].d-m[j].d-1)-m[i].p); &#125; CDQ(mid+1,r); Msort2(l,r);&#125;#undef intint main()&#123;#define int long long int Case=0; while (scanf(\"%lld%lld%lld\",&amp;n,&amp;c,&amp;d)!=EOF&amp;&amp;(n!=0&amp;&amp;c!=0&amp;&amp;d!=0))&#123; for (register int i=1;i&lt;=n;++i)&#123; m[i].d=read(),m[i].p=read(),m[i].r=read(),m[i].g=read(); p[i].id=i; &#125; sort(m+1,m+1+n,cmp); sort(p+1,p+1+n,cmp1); for (register int i=1;i&lt;=n;++i) ans[i]=-INF; ans[0]=c; CDQ(0,n); long long ret=c; for (register int i=1;i&lt;=n;++i)&#123; if (ans[i]&gt;=0) ret=max(ret,(long long)(ans[i]+m[i].r+(d-m[i].d)*m[i].g)); &#125; printf(\"Case %d: %lld\\n\",++Case,(long long)ret); &#125;&#125;","categories":[],"tags":[{"name":"斜率优化","slug":"斜率优化","permalink":"https://gaisaiyuno.github.io/tags/斜率优化/"},{"name":"CDQ分治","slug":"CDQ分治","permalink":"https://gaisaiyuno.github.io/tags/CDQ分治/"}]},{"title":"斜率优化学习笔记","slug":"斜率优化学习笔记","date":"2019-08-18T09:41:37.000Z","updated":"2019-08-20T13:48:49.364Z","comments":true,"path":"archives/30a615c6.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/30a615c6.html","excerpt":"","text":"首先上一道例题： HDU3507 给你一个序列，你可以把这个序列分成若干段，每段的花费是$(\\sum _{i=1} ^k C[i])^2 +M$ 考虑朴素的$n^2$方程，$dp[i]=\\min(dp[j]+M+(sum[i]-sum[j])^2)$ 其中$sum[i]$为$C[i]$的前缀和。 发现这个算法的瓶颈在寻找最优的$j$，如果我们可以$O(1)$的找到$j$，那么整个算法的时间复杂度为$O(n)$，可以AC。 考虑两个数$j_1,j_2$，$j_1&gt;j_2$，考虑$j_1$比$j_2$更优的条件： $dp[j_1]+M+(sum[i]-sum[j_1])^2&lt;dp[j_2]+M+(sum[i]-sum[j_2])^2$ 移项，此处省略1w字，得： $dp[j_1]-dp[j_2]+sum[j_1]^2-sum[j_2]^2&lt;2 \\times sum[i] \\times (sum[j_1]-sum[j_2])$ 不妨设$y(i)=dp[i]+sum[i]^2$，$x(i)=sum[i]$ 原式化为以下形式： $y(j_1)-y(j_2)&lt;2 \\times sum[i] \\times (x(j_1)-x(j_2))$ 发现这个其实类似于斜率： $\\frac{y(j_1)-y(j_2)}{x(j_1)-x(j_2)} &lt; 2 \\times sum[i]$ 其中我们能做这样的变换，有一个重要的先决条件，即$x(j_1)&gt;x(j_2),j_1&gt;j_2$ 将$x,y$表示在二维平面上面，如图： 用一个斜率为$2 \\times sum[i]$的直线去逼近，发现切点就是最佳决策，又发现$2 \\times sum[i]$随着$i$的增大而增大，所以之前舍弃的决策点不可能成为下一步的最佳决策点，于是我们可以用一个单调队列维护决策点集合。 1234inline double Slope(int i,int j)&#123; return (double)(dp[i]+sum[i]*sum[i]-dp[j]-sum[j]*sum[j])/(double)(sum[i]-sum[j]);&#125;while (head&lt;rear&amp;&amp;Slope(q[head+1],q[head])&lt;=(double)2.00*sum[i]) head++; 如何插入元素呢，我们像凸包一样插入和删除，如图： 12while (head&lt;rear&amp;&amp;Slope(q[rear],q[rear-1])&gt;=Slope(i,q[rear])) rear--;q[++rear]=i; 想学习凸包可以参考这篇博客 代码实现（还是很简短的）： 注意此代码精度有问题，你们可以把除法改成乘法试一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1ll; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3ll)+(x&lt;&lt;1ll)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int sum[MAXN];int dp[MAXN],q[MAXN],head,rear;inline double Slope(int i,int j)&#123; return (double)(dp[i]+sum[i]*sum[i]-dp[j]-sum[j]*sum[j])/(double)(sum[i]-sum[j]);&#125;#undef intint main()&#123;#define int long long int n,M; while (~scanf(\"%lld%lld\",&amp;n,&amp;M))&#123; memset(sum,0,sizeof(sum)); for (register int i=1;i&lt;=n;++i)&#123; int x; scanf(\"%lld\",&amp;x); sum[i]=sum[i-1]+x; &#125; memset(dp,0,sizeof(dp)); memset(q,0,sizeof(q)); head=1,rear=1; q[1]=0; for (register int i=1;i&lt;=n;++i)&#123; while (head&lt;rear&amp;&amp;Slope(q[head+1],q[head])&lt;=(double)2.00*sum[i]) head++; int j=q[head]; dp[i]=dp[j]+M+(sum[i]-sum[j])*(sum[i]-sum[j]); while (head&lt;rear&amp;&amp;Slope(q[rear],q[rear-1])&gt;=Slope(i,q[rear])) rear--; q[++rear]=i; &#125; printf(\"%lld\\n\",dp[n]); &#125;&#125; 图片转自csdn 注意到普通斜率优化的条件是斜率单调，$x$坐标单调，但是对于更一般的情况，就发现普通斜率优化会咕咕，这时候我们要使用CDQ分治优化斜率优化，可以参考这篇博客学习一下。","categories":[],"tags":[{"name":"斜率优化","slug":"斜率优化","permalink":"https://gaisaiyuno.github.io/tags/斜率优化/"}]},{"title":"凸包学习笔记","slug":"凸包学习笔记","date":"2019-08-18T01:54:53.000Z","updated":"2019-08-18T07:31:44.685Z","comments":true,"path":"archives/d2a55811.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d2a55811.html","excerpt":"","text":"首先介绍一下向量叉积的定义： 对于向量$\\vec a (x_1,y_1)$，$\\vec b (x_2,y_2)$ 向量的叉积$\\vec a \\times \\vec b$是一个标量，即$x_1 \\times y_2 - y_1 \\times x_2$ 代码如下： 123inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125; 考虑有什么几何意义 把$\\vec a$和$\\vec b$画到平面直角坐标系上面 考虑$S_{\\Delta OAB}$： 用初中的方法推一下： $S_{\\Delta OAB}=S_{OEFD}-S_{\\Delta ABF}-S_{\\Delta OAD}-S_{\\Delta OBE}$ $=(x_2 \\times y_1)-(x_2-x_1) \\times (y_1 -y_2)/2-x_2 \\times y_2 /2 -x_1 \\times y_1 /2$ $=(x_1 \\times y_2-y_1 \\times x_2)/2$ 对于其他$\\vec a$和$\\vec b$，观察到$x_1 \\times y_2-y_1 \\times x_2$可能小于$0$，于是取绝对值即可。 于是$S_{\\Delta OAB} = |\\vec a\\times \\vec b/2|$ 于是$S_{OABG}=|\\vec a \\times \\vec b|$ 其他方法如割补法也是可以得到这个结论的。 于是向量叉积的几何意义就是两个向量形成的平行四边形的面积 继续推一下，我们有三角函数公式$S_{\\Delta OAB}=\\sin α \\times OA \\times OB/2$ 所以$\\vec a \\times \\vec b = |\\vec a| \\times |\\vec b| \\times \\sin ∠AOB $ 其中$|\\vec a|$表示向量的模长，即$\\sqrt{a.x^2+a.y^2}$ 观察到$\\vec a$在$\\vec b$顺时针方向时$∠AOB$可能为负，此时$\\sin ∠AOB$就为负，而向量模长显然大于$0$，于是此时$\\vec a \\times \\vec b &lt;0$ 于是我们又有一个重要的结论，当$\\vec a$在$\\vec b$顺时针方向的时候$\\vec a \\times \\vec b&lt;0$ 好了，数学部分大部分推完了，讲一讲凸包的定义： 给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它能包含点集中所有的点 （对于图中$9$这个点，发现对于有些题目必须选，但是对于有些题目选了会出现玄学问题） 如何快速求出凸包，考虑一个重要的性质： 考虑以上图中的红色点为基准点，重新建立直角坐标系，发现凸包任意两个点中，编号较大的点对应的向量总是在编号较小的点对应的向量的逆时针方向，于是他们俩叉积大于$0$ 于是对于建立凸包，我们有一个重要的思路，考虑钦定一个点$a$为基准点（基准点一定在凸包上），这里我们选择$x$坐标和$y$坐标都最小的点，对于两个点$A,B$，把他们按照叉积正负排序，如果叉积$=0$，即共线，按照他们和基准点距离排序。（这一点在后面也会提到） 1234inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (((A-a)*(B-a))!=0) return ((A-a)*(B-a))&gt;0; else return dis(a,A)&lt;dis(a,B);&#125; 考虑现在已经建出的凸包（红色部分），我们用一个单调栈来存凸包上面的点，假设我们要加进一个点$i$，显然不能不能直接加进，否则就不是凸包了，考虑两条向量$\\vec a$和$\\vec b$，由于$\\vec a$在$\\vec b$的逆时针方向，所以$\\vec a \\times \\vec b &lt;0$，如果$i,top ,top-1$共线也得判掉，这两种情况，我们都得把单调栈的顶端弹掉，所以得到以下代码： 12345sort(p+2,p+1+n);for (register int i=1;i&lt;=n;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i];&#125; 为什么排序要加和基准点距离的特判，考虑如图的情况，如果$top$排在$i$的前面，你会发现$top$先加进了凸包，于是$i$也被加进了凸包，造成错误。 例题1：护城河的挖掘/P2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows 传送门 求凸包周长，很简单，只要把凸包里面相邻两点的距离算一下相加即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;struct Point&#123; double x,y;&#125;p[MAXN];Point a;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (((A-a)*(B-a))!=0) return ((A-a)*(B-a))&gt;0; else return dis(a,A)&lt;dis(a,B);&#125;Point stk[MAXN];int top;int main()&#123; int n; scanf(\"%d\",&amp;n); pos=1; for (register int i=1;i&lt;=n;++i)&#123; double x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); p[i].x=(double)(x),p[i].y=(double)(y); if (p[pos].y&gt;p[i].y||(p[pos].y==p[i].y&amp;&amp;p[pos].x&gt;p[i].x)) pos=i; &#125; a=p[pos]; swap(p[1],p[pos]); sort(p+2,p+1+n); for (register int i=1;i&lt;=n;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i]; &#125; double ans=0; for (register int i=1;i&lt;top;++i)&#123; ans+=dis(stk[i],stk[i+1]); &#125; ans+=dis(stk[top],stk[1]); printf(\"%.2f\\n\",ans);&#125; 例题2P3829 [SHOI2012]信用卡凸包 图是洛谷上面剽的。 考虑把每个信用卡的四个圆弧对应的圆心找出来跑凸包，凸包的周长加上一个整圆的周长即是答案，为什么？ 考虑把凸包上面的边平移进去，发现红色的几段圆弧刚好能拼成一个大圆，所以得证。 具体实现的时候，可以使用公式旋转向量： 123inline Point Rotate(Point a,double theta)&#123; return Point&#123;a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define MAXN 1000005#define eps 1e-10using namespace std;struct Point&#123; double x,y;&#125;p[MAXN];Point p0;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (abs((A-p0)*(B-p0))&gt;eps) return ((A-p0)*(B-p0))&gt;eps; else return dis(p0,A)&lt;dis(p0,B);&#125;Point stk[MAXN];int top,cnt;inline void Insert(Point a)&#123; p[++cnt]=a; if (p[pos].y&gt;p[cnt].y||(p[pos].y==p[cnt].y&amp;&amp;p[pos].x&gt;p[cnt].x)) pos=cnt;&#125;inline Point Rotate(Point a,double theta)&#123; return Point&#123;a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)&#125;;&#125;Point d[4];double fh[2]=&#123;1.00,-1.00&#125;;int main()&#123; int n; scanf(\"%d\",&amp;n); double a,b,R; cin&gt;&gt;a&gt;&gt;b&gt;&gt;R; swap(a,b); a-=2.00*R,b-=2.00*R; for (register int i=0;i&lt;2;++i)&#123; for (register int j=0;j&lt;2;++j)&#123; d[i*2+j]=Point&#123;fh[i]*a/2.00,fh[j]*b/2.00&#125;; &#125; &#125; pos=1; for (register int i=1;i&lt;=n;++i)&#123; double r,x,y; cin&gt;&gt;x&gt;&gt;y&gt;&gt;r; Point A=Point&#123;x,y&#125;; for (register int j=0;j&lt;4;++j)&#123; Insert(A+Rotate(d[j],r)); &#125; &#125; p0=p[pos]; swap(p[1],p[pos]); sort(p+2,p+1+cnt); for (register int i=1;i&lt;=cnt;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=-eps) top--; stk[++top]=p[i]; &#125; double ans=0; for (register int i=1;i&lt;top;++i)&#123; ans+=dis(stk[i],stk[i+1]); &#125; ans+=dis(stk[top],stk[1]); ans+=2.00*acos(-1)*R; printf(\"%.2lf\\n\",ans);&#125; 例题3:[HAOI2011]防线修建 首先，我们将删点变成加点，就是把删点的操作离线下来，反向操作。 于是题目就是要你动态维护一个上凸壳的周长。 考虑$set$维护，$set$按照$x,y$坐标排序，加进一个点，如果这个点在凸包里面，直接跳过： 1if ((*r-*l)*(x-*l)&lt;0) return ; 如果不在凸包里面，就得把不符合凸包性质的点一个一个删掉，由于总共的点数为$n$，所以这个操作均摊$O(\\log n)$ 1234567891011121314151617while (true)&#123;//搞掉右边的 t=r;r++; if (r==S.end()) break; if ((*r-x)*(*t-x)&gt;0) break; ans-=dis(*t,*r); S.erase(*t);&#125;while (l!=S.begin())&#123;//搞掉左边的 t=l;l--; if ((*t-x)*(*l-x)&gt;0) break; ans-=dis(*t,*l); S.erase(*t);&#125;S.insert(x);r=S.lower_bound(x),l=r;l--,r++;ans+=dis(x,*l)+dis(x,*r); 别忘了加上红色的两条边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define MAXN 1000005#define eps 1e-6using namespace std;struct Point&#123; double x,y;&#125;p[MAXN];Point p0;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;bool flag;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (flag)&#123; if (abs((A-p0)*(B-p0))&gt;eps) return ((A-p0)*(B-p0))&gt;eps; else return dis(p0,A)&lt;dis(p0,B); &#125; else &#123; if (A.x!=B.x) return A.x&lt;B.x; else return A.y&gt;B.y; &#125;&#125;Point stk[MAXN];int top,cnt;inline void Insert(Point a)&#123; p[++cnt]=a; if (p[pos].y&gt;p[cnt].y||(p[pos].y==p[cnt].y&amp;&amp;p[pos].x&gt;p[cnt].x)) pos=cnt;&#125;set&lt;Point&gt;S;int vis[MAXN],id[MAXN],tot;Point c[MAXN];double ans;//现在的答案 inline void Add(Point a)&#123; c[++tot]=a;&#125;inline void Init()&#123; pos=1; cnt=0; for (register int i=1;i&lt;=tot;++i)&#123; if (!vis[i]) Insert(c[i]); &#125; p0=p[pos]; swap(p[1],p[pos]); flag=true; sort(p+2,p+1+cnt); flag=false; for (register int i=1;i&lt;=cnt;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i]; &#125; ans=0; for (register int i=2;i&lt;top;++i)&#123; ans+=dis(stk[i],stk[i+1]); &#125; ans+=dis(stk[top],stk[1]); S.clear(); for (register int i=1;i&lt;=top;++i)&#123; S.insert(stk[i]); &#125;&#125;inline void Print()&#123; printf(\"Set Elements:\\n\"); for (set&lt;Point&gt;::iterator it=S.begin();it!=S.end();++it)&#123; printf(\"%f %f\\n\",(*it).x,(*it).y); &#125; printf(\"\\n\");&#125;inline void AddCity(Point x)&#123; set&lt;Point&gt;::iterator r=S.lower_bound(x),l=r,t; l--; if ((*r-*l)*(x-*l)&lt;0) return ; ans-=dis(*l,*r); S.insert(x); while (true)&#123;//搞掉右边的 t=r;r++; if (r==S.end()) break; if ((*r-x)*(*t-x)&gt;0) break; ans-=dis(*t,*r); S.erase(*t); &#125; while (l!=S.begin())&#123;//搞掉左边的 t=l;l--; if ((*t-x)*(*l-x)&gt;0) break; ans-=dis(*t,*l); S.erase(*t); &#125; S.insert(x); r=S.lower_bound(x),l=r; l--,r++; ans+=dis(x,*l)+dis(x,*r);&#125;double Ans[MAXN];int n,sx,sy,m;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;sx,&amp;sy); Add(Point&#123;(double)sx,(double)sy&#125;); scanf(\"%d\",&amp;m); for (register int i=1;i&lt;=m;++i)&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); Add(Point&#123;(double)x,(double)y&#125;); &#125; Add(Point&#123;0,0&#125;); Add(Point&#123;(double)n,0&#125;); int q; scanf(\"%d\",&amp;q); for (register int i=1;i&lt;=q;++i)&#123; int opr; scanf(\"%d\",&amp;opr); if (opr==1)&#123; int city; scanf(\"%d\",&amp;city); vis[city+1]=1;//因为首都编号为1所以+1 id[i]=city+1; &#125; else&#123; id[i]=0; &#125; &#125; Init();//建出上凸壳 for (register int i=q;i&gt;=1;--i)&#123; if (id[i]) AddCity(c[id[i]]); else Ans[i]=ans; &#125; for (register int i=1;i&lt;=q;++i)&#123; if (!id[i])&#123; printf(\"%.2f\\n\",Ans[i]); &#125; &#125;&#125; 例题4：P1452 Beauty Contest 让你求一个凸包的直径。 考虑到点数很多，但是凸包上面的点很少，所以可以用暴力水过： 123456double ans=0;for (register int i=1;i&lt;=top;++i)&#123; for (register int j=i+1;j&lt;=top;++j)&#123; ans=max(ans,dis(stk[i],stk[j])*dis(stk[i],stk[j])); &#125;&#125; 考虑如何做到$O(n)$ 我们使用旋转卡壳算法，放一个图直观感受一下： 定义对踵点为一条边和凸包上面其他点形成的三角形中面积最大的一个的顶点，如图中$BC$的对踵点为$A$ 考虑将$BC$顺时针旋转成$B’C’$，那么$A$必定顺时针旋转： 于是$A$的这种单调性，使得我们可以均摊$O(n)$地移动$A$，求得凸包直径： 123456789register int ptr=2;stk[top+1]=stk[1];for (register int i=1;i&lt;=top;++i)&#123; while (Height(stk[ptr]-stk[i],stk[ptr]-stk[i+1])&lt;Height(stk[ptr+1]-stk[i],stk[ptr+1]-stk[i+1]))&#123; ptr++; if (ptr==top+1) ptr=1; &#125; ans=max(ans,dis(stk[i],stk[ptr])*dis(stk[i],stk[ptr]));&#125; 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define MAXN 500005#define eps 1e-10using namespace std;struct Point&#123; double x,y;&#125;p[MAXN];Point p0;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (abs((A-p0)*(B-p0))&gt;eps) return ((A-p0)*(B-p0))&gt;eps; else return dis(p0,A)&lt;dis(p0,B);&#125;Point stk[MAXN];int top,cnt;inline void Insert(Point a)&#123; p[++cnt]=a; if (p[pos].y&gt;p[cnt].y||(p[pos].y==p[cnt].y&amp;&amp;p[pos].x&gt;p[cnt].x)) pos=cnt;&#125;inline double Height(Point a,Point b)&#123; return (a*b)/dis(a,b);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); pos=1; for (register int i=1;i&lt;=n;++i)&#123; double x,y; cin&gt;&gt;x&gt;&gt;y; Insert(Point&#123;x,y&#125;); &#125; p0=p[pos]; swap(p[1],p[pos]); sort(p+2,p+1+cnt); for (register int i=1;i&lt;=cnt;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i]; &#125; double ans=0; register int ptr=2; stk[top+1]=stk[1]; for (register int i=1;i&lt;=top;++i)&#123; while (Height(stk[ptr]-stk[i],stk[ptr]-stk[i+1])&lt;Height(stk[ptr+1]-stk[i],stk[ptr+1]-stk[i+1]))&#123; ptr++; if (ptr==top+1) ptr=1; &#125; ans=max(ans,dis(stk[i],stk[ptr])*dis(stk[i],stk[ptr])); &#125; printf(\"%.0f\\n\",ans);&#125; 例题5：P4166 [SCOI2007]最大土地面积 详情参考这篇 例题6：P3187 [HNOI2007]最小矩形覆盖 给定一些点的坐标，要求求能够覆盖所有点的最小面积的矩形，输出所求矩形的面积和四个顶点坐标。 首先考虑建出凸包，发现这个矩形的一条边一定在凸包上面，考虑枚举这条边，发现最小矩形的长为$MaxL+MaxR$，高为$MaxH$ 于是考虑旋转卡壳求出$MaxH$和$MaxL,MaxR$，$MaxH$用上面的方法很快就可以求出，但是$MaxL,MaxR$不好求。 再介绍向量的点积， 对于向量$\\vec a (x_1,y_1)$，$\\vec b (x_2,y_2)$ 向量的点积$\\vec a · \\vec b$是一个标量，即$x_1 \\times y_1 - x_2 \\times y_2$ 也可以表示为$|\\vec a| \\times |\\vec b| \\times \\cos \\alpha$ 注意到$|\\vec a| \\times \\cos \\alpha$的几何意义，就是$\\vec a$在$\\vec b$方向的投影，即标红的部分 所以我们有$CD=\\vec a · \\vec b / |\\vec b|$ 回到本题，发现$MaxL$和$MaxR$求起来就非常简单了，他们的本质其实是凸包的点之间的连线在某一条边上面的投影，直接套用公式即可。 12double L=abs((stk[l]-stk[i])^(stk[i]-stk[i+1]))/D;double R=abs((stk[r]-stk[i])^(stk[i]-stk[i+1]))/D; 求得$MaxL,MaxR,MaxH$后，如何去求矩形的四个角？ 我们知道向量$\\vec a$和$\\vec b$如何求$\\vec h$，这里用一种非常naive的思路，求出底边上面的两个线段的长度，于是套用向量公式计算即可。 1234Point a=stk[i]-stk[h],b=stk[i+1]-stk[h];double aa=mod(a),bb=mod(b);double x=sqrt(abs(aa-H*H)),y=sqrt(abs(bb-H*H));Point hh=(mul(a,y)+mul(b,x))/(x+y); 交上去被卡精度怎么办，发现数据都是整数，于是四舍五入到整数 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define MAXN 50005#define eps std::numeric_limits&lt;double&gt;::epsilon() * 10#define EPS 0.7using namespace std;inline void PrintDouble(double x)&#123; printf(\"%.5lf\",(double((int)(x+EPS)*100000)/100000));&#125;struct Point&#123; double x,y; void print()&#123; PrintDouble(x); printf(\" \"); PrintDouble(y); printf(\"\\n\"); &#125;&#125;p[MAXN];Point p0;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double operator ^ (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.x+A.y*B.y;&#125;inline Point operator / (const Point &amp;A,const double &amp;D)&#123; return Point&#123;A.x/D,A.y/D&#125;;&#125;inline Point mul(const Point &amp;A,const double &amp;D)&#123; return Point&#123;A.x*D,A.y*D&#125;;&#125;inline double mod(const Point &amp;A)&#123; return A.x*A.x+A.y*A.y;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (abs((A-p0)*(B-p0))&gt;eps) return ((A-p0)*(B-p0))&gt;eps; else return dis(p0,A)&lt;dis(p0,B);&#125;Point stk[MAXN];int top,cnt;inline void Insert(Point a)&#123; p[++cnt]=a; if (p[pos].y&gt;p[cnt].y||(p[pos].y==p[cnt].y&amp;&amp;p[pos].x&gt;p[cnt].x)) pos=cnt;&#125;inline int Next(int x)&#123; return (x&gt;=top?x-top+1:x+1);&#125;Point Ans[4];int main()&#123; int n; scanf(\"%d\",&amp;n); pos=1; for (register int i=1;i&lt;=n;++i)&#123; double x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); Insert(Point&#123;x,y&#125;); &#125; p0=p[pos]; swap(p[1],p[pos]); sort(p+2,p+1+cnt); for (register int i=1;i&lt;=cnt;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i]; &#125; double ans=1e20; stk[top+1]=stk[1]; int l=2,r=2,h=2; Point ansl1,ansr1,ansl2,ansr2; for (register int i=1;i&lt;=top;++i)&#123; while (((stk[h]-stk[i])*(stk[i]-stk[i+1]))&lt;((stk[Next(h)]-stk[i])*(stk[i]-stk[i+1]))+eps) h=Next(h); while (((stk[r]-stk[i])^(stk[i]-stk[i+1]))+eps&gt;((stk[Next(r)]-stk[i])^(stk[i]-stk[i+1]))) r=Next(r); if (i==1) l=r; while (((stk[l]-stk[i])^(stk[i]-stk[i+1]))&lt;((stk[Next(l)]-stk[i])^(stk[i]-stk[i+1]))+eps) l=Next(l); double D=dis(stk[i],stk[i+1]); double H=abs((stk[h]-stk[i])*(stk[i]-stk[i+1]))/D; double L=abs((stk[l]-stk[i])^(stk[i]-stk[i+1]))/D; double R=abs((stk[r]-stk[i])^(stk[i]-stk[i+1]))/D; if (ans&gt;H*(L+R))&#123; ans=H*(L+R); Point a=stk[i]-stk[h],b=stk[i+1]-stk[h]; double aa=mod(a),bb=mod(b); double x=sqrt(abs(aa-H*H)),y=sqrt(abs(bb-H*H)); Point hh=(mul(a,y)+mul(b,x))/(x+y); Point jzm=stk[i+1]-stk[i]; if (abs(D)&gt;=eps) ansl1=stk[i]+mul(jzm,-L/D); else ansl1=stk[i]; if (abs(D)&gt;=eps) ansr1=stk[i]+mul(jzm,R/D); else ansr1=stk[i]; ansl2=ansl1-hh; ansr2=ansr1-hh; &#125; &#125; PrintDouble(ans); printf(\"\\n\"); p0=Point&#123;0,0&#125;; Ans[0]=ansl1,Ans[1]=ansl2,Ans[2]=ansr1,Ans[3]=ansr2; sort(Ans,Ans+4); Ans[0].print(); Ans[1].print(); Ans[2].print(); Ans[3].print();&#125; 三维凸包：咕咕咕","categories":[],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://gaisaiyuno.github.io/tags/计算几何/"},{"name":"凸包","slug":"凸包","permalink":"https://gaisaiyuno.github.io/tags/凸包/"}]},{"title":"P4166 [SCOI2007]最大土地面积","slug":"P4166-SCOI2007-最大土地面积","date":"2019-08-12T12:14:21.000Z","updated":"2019-08-12T13:07:14.863Z","comments":true,"path":"archives/c8e0ca4d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c8e0ca4d.html","excerpt":"","text":"传送门 $Pro$在某块平面土地上有$N$个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。 $Sol$考虑把四边形分成两个三角形，显然这个四边形的四个顶点都在凸包上面，于是考虑枚举四边形的两个端点$i$，$j$，然后另外两个端点$a$，$b$可以通过单调性求出。 如图： 考虑按照顺时针（图中的正方向）枚举端点$i$，$j$，当$j$移动到下一个位置$j’$的时候，考虑$a$，$b$的移动，发现$a$，$b$都是沿着正方向移动，于是单调地移动$a$，$b$，直到面积不增加才停止。 12while (Next(a)!=j&amp;&amp;Area(stk[Next(a)]-stk[i],stk[Next(a)]-stk[j])&gt;Area(stk[a]-stk[i],stk[a]-stk[j])) a=Next(a);while (Next(b)!=i&amp;&amp;Area(stk[Next(b)]-stk[i],stk[Next(b)]-stk[j])&gt;Area(stk[b]-stk[i],stk[b]-stk[j])) b=Next(b); 其中$Area$函数算的是两个向量所夹的三角形的面积，直接叉积$/2$后面取绝对值即可。 几何意义可以看下图： 123inline double Area(const Point &amp;A,const Point &amp;B)&#123; return abs(A*B/2.00);&#125; 注意初始点的选择，图中用绿色箭头标出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#define MAXN 2005#define eps 1e-10using namespace std;struct Point&#123; double x,y;&#125;p[MAXN];Point p0;int pos;inline double operator * (const Point &amp;A,const Point &amp;B)&#123; return A.x*B.y-A.y*B.x;&#125;inline Point operator - (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x-B.x,A.y-B.y&#125;;&#125;inline Point operator + (const Point &amp;A,const Point &amp;B)&#123; return Point&#123;A.x+B.x,A.y+B.y&#125;;&#125;inline double pf(double x)&#123; return x*x;&#125;inline double dis(const Point &amp;A,const Point &amp;B)&#123; return sqrt(pf(A.x-B.x)+pf(A.y-B.y));&#125;inline bool operator &lt; (const Point &amp;A,const Point &amp;B)&#123; if (abs((A-p0)*(B-p0))&gt;eps) return ((A-p0)*(B-p0))&gt;eps; else return dis(p0,A)&lt;dis(p0,B);&#125;Point stk[MAXN];int top,cnt;inline void Insert(Point a)&#123; p[++cnt]=a; if (p[pos].y&gt;p[cnt].y||(p[pos].y==p[cnt].y&amp;&amp;p[pos].x&gt;p[cnt].x)) pos=cnt;&#125;inline int Next(int x)&#123; return (x&gt;=top?x-top+1:x+1);&#125;inline double Area(const Point &amp;A,const Point &amp;B)&#123; return abs(A*B/2.00);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); pos=1; for (register int i=1;i&lt;=n;++i)&#123; double x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); Insert(Point&#123;x,y&#125;); &#125; p0=p[pos]; swap(p[1],p[pos]); sort(p+2,p+1+cnt); for (register int i=1;i&lt;=cnt;++i)&#123; while (top&gt;1&amp;&amp;(stk[top]-stk[top-1])*(p[i]-stk[top-1])&lt;=0) top--; stk[++top]=p[i]; &#125; double ans=0; for (register int i=1;i&lt;=top;++i)&#123;//枚举凸包第一个端点 int a=Next(i),b=Next(Next(Next(i))); for (register int j=Next(Next(i));j&lt;=top;j++)&#123;//枚举第一个端点的对角线端点 while (Next(a)^j&amp;&amp;Area(stk[Next(a)]-stk[i],stk[Next(a)]-stk[j])&gt;Area(stk[a]-stk[i],stk[a]-stk[j])) a=Next(a); while (Next(b)^i&amp;&amp;Area(stk[Next(b)]-stk[i],stk[Next(b)]-stk[j])&gt;Area(stk[b]-stk[i],stk[b]-stk[j])) b=Next(b); ans=max(ans,Area(stk[a]-stk[i],stk[a]-stk[j])+Area(stk[b]-stk[i],stk[b]-stk[j])); &#125; &#125; printf(\"%.3f\\n\",ans);&#125;","categories":[],"tags":[]},{"title":"SP20644 ZQUERY - Zero Query","slug":"SP20644-ZQUERY-Zero-Query","date":"2019-08-11T07:40:48.000Z","updated":"2019-08-11T08:09:17.964Z","comments":true,"path":"archives/24d65f48.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/24d65f48.html","excerpt":"","text":"传送门 $Pro$长度为$n$的序列，序列中的值为$1$或$−1$有$m$个询问，询问在$[L,R]$中区间和为$0$的区间的最大长度 $Sol$考虑莫队 对于区间$[l,r]$，统计两个数组$Max[i]$和$Min[i]$，表示$\\max j (\\sum_{k=l}^j a[k] =i)$和$\\min j (\\sum_{k=l}^j a[k] =i)$，特别地$Max[0]=l-1$,$Min[0]=l-1$ 那么每来一个数$x$，$sum+=x$，然后更新$Max[sum]$和$Min[sum]$，答案和$Max[sum]-Min[sum]$取一个最大值。 但是这个删除操作比较不好搞，考虑只加不减的回滚莫队。 分别用上面的方法统计蓝色区域和红色区域的最大值，最后在算上绿色区域即可。 注意：多清零，最好专门开两个数组，专门跑暴力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define X 50000#define INF 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],pos[MAXN],n,m;struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];&#125;static int Ans[MAXN];int ans,Size;int tempMax[MAXN],tempMin[MAXN];int Max[MAXN],Min[MAXN];int Max1[MAXN],Min1[MAXN];int tempsum,tempans;inline int BruteForce(int l,int r)&#123; int s=0,ret=0; for (register int i=l;i&lt;=r;++i) Max1[s+X]=-INF,Min1[s+X]=INF,s+=a[i]; Max1[s+X]=-INF,Min1[s+X]=INF;//可能是负数，所以要加上一个很大的数 s=0; Max1[X]=max(Max1[X],l-1); Min1[X]=min(Min1[X],l-1); for (register int i=l;i&lt;=r;++i)&#123; s+=a[i]; Max1[s+X]=max(Max1[s+X],i); Min1[s+X]=min(Min1[s+X],i); ret=max(ret,Max1[s+X]-Min1[s+X]); &#125; s=0; for (register int i=l;i&lt;=r;++i) Max1[s+X]=-INF,Min1[s+X]=INF,s+=a[i]; Max1[s+X]=-INF,Min1[s+X]=INF; return ret;&#125;int sum;inline int MoQueue(int i,int id)&#123; int R=min(n,Size*id); int r=R; for (register int i=0;i&lt;MAXN;++i) Max[i]=-INF,tempMax[i]=-INF; for (register int i=0;i&lt;MAXN;++i) Min[i]=INF,tempMin[i]=INF; ans=0,sum=0; Max[X]=R; Min[X]=R; tempMax[X]=R+1; tempMin[X]=R+1; while (pos[q[i].l]==id)&#123; if (pos[q[i].l]==pos[q[i].r])&#123; Ans[q[i].id]=BruteForce(q[i].l,q[i].r); i++; continue; &#125; for (register int j=r+1;j&lt;=q[i].r;++j)&#123; sum+=a[j]; Max[sum+X]=max(Max[sum+X],j); Min[sum+X]=min(Min[sum+X],j); ans=max(ans,Max[sum+X]-Min[sum+X]);//蓝色区域 &#125; r=q[i].r; tempans=0,tempsum=0; tempMax[X]=R+1; tempMin[X]=R+1;//反向意义 for (register int j=R;j&gt;=q[i].l;--j)&#123; tempsum+=a[j]; tempMax[tempsum+X]=max(tempMax[tempsum+X],j); tempMin[tempsum+X]=min(tempMin[tempsum+X],j); tempans=max(tempans,tempMax[tempsum+X]-tempMin[tempsum+X]);//红色区域 tempans=max(tempans,Max[-tempsum+X]-tempMin[tempsum+X]+1);//绿色区域，注意+1 &#125; Ans[q[i].id]=max(tempans,ans); for (register int j=q[i].l;j&lt;=R;++j)&#123;//还原 tempMax[tempsum+X]=-INF; tempMin[tempsum+X]=INF; tempsum-=a[j]; &#125; i++; &#125; return i;&#125;int main()&#123; n=read(),m=read(); Size=(int)(n/sqrt(m)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int ptr=1; for (register int i=1;i&lt;=pos[n];++i)&#123; ptr=MoQueue(ptr,i); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"回滚莫队","slug":"回滚莫队","permalink":"https://gaisaiyuno.github.io/tags/回滚莫队/"}]},{"title":"P4168 [Violet]蒲公英","slug":"P4168-Violet-蒲公英","date":"2019-08-09T07:59:57.000Z","updated":"2019-08-09T08:42:53.714Z","comments":true,"path":"archives/5b95202e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5b95202e.html","excerpt":"","text":"传送门 $Pro$求区间最小众数，强制在线。 $Sol$因为强制在线，所以不能用优美的莫队。 考虑分块。 预处理三个数组$p[i][j],pcnt[i][j],s[i][j]$， $p[i][j]$代表第$i$块到第$j$块出现次数最多且次数最小的数，也就是最小众数，这个你暴力就可以求出来。 1234567891011121314151617inline void AddBlock(int lb,int rb)&#123;//暴♂力 for (register int i=lb;i&lt;=rb;++i)&#123; cnt[a[i]]++; if ((cnt[a[i]]&gt;cnt[ans])||((cnt[a[i]]==cnt[ans])&amp;&amp;(a[i]&lt;ans)))&#123; ans=a[i]; &#125; &#125;&#125;for (register int i=1;i&lt;=id[n];++i)&#123; memset(cnt,0,sizeof(cnt)); ans=0; for (register int j=i;j&lt;=id[n];++j)&#123; AddBlock((j-1)*Size+1,min(j*Size,n)); p[i][j]=ans; pcnt[i][j]=cnt[ans]; &#125;&#125; $pcnt[i][j]$代表在$i$到$j$的块里面最小众数出现次数。 求$p[i][j]$的时候可以顺便求出$pcnt[i][j]$，时间复杂度$O(n \\sqrt n)$ $s[i][j]$代表前$i$个块中，离散化过的值$j$出现过多少次，是一个类似于前缀和的东西，这个也是暴力求，时间复杂度$O(n \\sqrt n)$ 123456789for (register int i=1;i&lt;=id[n];++i)&#123; int lb=(i-1)*Size+1,rb=min(i*Size,n); for (register int j=1;j&lt;=n;++j)&#123; s[i][j]=s[i-1][j]; &#125; for (register int j=lb;j&lt;=rb;++j)&#123; s[i][a[j]]++; &#125;&#125; 现在求出$p[i][j],pcnt[i][j],s[i][j]$，考虑如何求出众数。 众数只有两种可能：属于红色区域或者属于蓝色区域（废话） $1.$众数属于蓝色区域，那么我们不妨把蓝色区域的每个数都枚举一遍，然后通过暴力求出这个数在蓝色区域出现次数，通过$s[i][j]$求出红色区域里面这个数出现次数。 1234567891011for (register int i=l;i&lt;=r;++i)&#123; cnt[a[i]]++;//蓝色区域里面贡献 if (cnt[a[i]]==1) cnt[a[i]]+=s[rid-1][a[i]]-s[lid][a[i]];//红色区域里面贡献 //注意判断是不是第一次出现 if (cnt[a[i]]&gt;cnt[ans]||((cnt[a[i]]==cnt[ans])&amp;&amp;(a[i]&lt;ans)))&#123; ans=a[i]; &#125;&#125;for (register int i=l;i&lt;=rb;++i) cnt[a[i]]=0;for (register int i=lb;i&lt;=r;++i) cnt[a[i]]=0;UpdateAns(l,rb,lid,rid),UpdateAns(lb,r,lid,rid); $2.$众数属于红色区域，注意此时我们不用考虑蓝色区域，如果众数属于蓝色区域，那么它肯定在上面算到了。 所以直接调用预处理的结果即可。 现在我们得到两个答案，但是我们不知道第二个答案的出现次数是怎么样的，于是$pcnt$就派上用场了。 123if (pcnt[lid+1][rid-1]&gt;cnt[ans]) return b[ans1];else if (pcnt[lid+1][rid-1]==cnt[ans]&amp;&amp;ans1&lt;ans) return b[ans1];else return b[ans]; 细节还是比较多的，注意多清零。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define MAXN 40005#define MAXM 205using namespace std;void write(int x) &#123; if(x&gt;9) write(x/10); putchar(x%10+'0');&#125;inline void Print(int x)&#123; if (x==0)&#123;putchar('0');return ;&#125; if (x&lt;0) x=-x,putchar('-'); write(x); putchar('\\n');&#125;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],id[MAXN],b[MAXN],Size,n,m;int p[MAXM][MAXM];//预处理i到j块的最小众数int pcnt[MAXM][MAXM];//i到j块的最小众数的出现次数int s[MAXM][MAXN];//类似于前缀和int cnt[MAXN],ans;inline void AddBlock(int lb,int rb)&#123;//暴♂力 for (register int i=lb;i&lt;=rb;++i)&#123; cnt[a[i]]++; if ((cnt[a[i]]&gt;cnt[ans])||((cnt[a[i]]==cnt[ans])&amp;&amp;(a[i]&lt;ans)))&#123; ans=a[i]; &#125; &#125;&#125;inline void Init()&#123; for (register int i=1;i&lt;=id[n];++i)&#123; memset(cnt,0,sizeof(cnt)); ans=0; for (register int j=i;j&lt;=id[n];++j)&#123; AddBlock((j-1)*Size+1,min(j*Size,n)); p[i][j]=ans; pcnt[i][j]=cnt[ans]; &#125; &#125; for (register int i=1;i&lt;=id[n];++i)&#123; int lb=(i-1)*Size+1,rb=min(i*Size,n); for (register int j=1;j&lt;=n;++j)&#123; s[i][j]=s[i-1][j]; &#125; for (register int j=lb;j&lt;=rb;++j)&#123; s[i][a[j]]++; &#125; &#125;&#125;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i)&#123; b[i]=a[i]; &#125; sort(b+1,b+1+n); int tot=unique(b+1,b+1+n)-b-1; for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+tot,a[i])-b; &#125;&#125;inline void UpdateAns(int l,int r,int lid,int rid)&#123; for (register int i=l;i&lt;=r;++i)&#123; cnt[a[i]]++; if (cnt[a[i]]==1) cnt[a[i]]+=s[rid-1][a[i]]-s[lid][a[i]];//绿线里面 //注意判断是不是第一次出现 if (cnt[a[i]]&gt;cnt[ans]||((cnt[a[i]]==cnt[ans])&amp;&amp;(a[i]&lt;ans)))&#123; ans=a[i]; &#125; &#125;&#125;inline int Query(int l,int r)&#123; int lid=id[l],rid=id[r]; if (lid==rid||lid+1==rid)&#123;//如果没有块相隔也会出锅 ans=0; for (register int i=l;i&lt;=r;++i) cnt[a[i]]=0; AddBlock(l,r); return b[ans]; &#125; int ans1=p[lid+1][rid-1]; int rb=min(lid*Size,n),lb=(rid-1)*Size+1; ans=0; for (register int i=l;i&lt;=rb;++i) cnt[a[i]]=0; for (register int i=lb;i&lt;=r;++i) cnt[a[i]]=0; UpdateAns(l,rb,lid,rid),UpdateAns(lb,r,lid,rid); if (pcnt[lid+1][rid-1]&gt;cnt[ans]) return b[ans1]; else if (pcnt[lid+1][rid-1]==cnt[ans]&amp;&amp;ans1&lt;ans) return b[ans1]; else return b[ans];&#125;int main()&#123; n=read(),m=read(); Size=(int)(sqrt(n)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(),id[i]=(i-1)/Size+1; &#125; discrete(); Init(); int x=0; while (m--)&#123; int l=(read()+x-1)%n+1,r=(read()+x-1)%n+1; if (l&gt;r) swap(l,r); Print(x=Query(l,r)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"分块","slug":"分块","permalink":"https://gaisaiyuno.github.io/tags/分块/"}]},{"title":"BZOJ离线题库乱搞记","slug":"BZOJ离线题库乱搞记","date":"2019-08-08T13:59:20.000Z","updated":"2019-08-08T14:08:46.409Z","comments":true,"path":"archives/a8911f80.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a8911f80.html","excerpt":"","text":"一开始看到别人的博客也有BZOJ离线题库，于是就想能不能自己搞一个，比如说这个就是别人的。 怎么办呢，一波wget走起（滑稽） 后来万万没想到它竟然是开源的 于是你们不用这么折腾，下载之后放到public文件夹即可，注意不要运行hexo clean命令。 可能会报错吧，你把有错的那几个文件删掉就可以了。 注意如果没有图标，你查看一下css文件里面的fonts字体库，把问号后面的一大坨删掉。 成果示意 不说了，写题去。","categories":[],"tags":[{"name":"乱搞","slug":"乱搞","permalink":"https://gaisaiyuno.github.io/tags/乱搞/"},{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]},{"title":"P4137 Rmq Problem / mex","slug":"P4137-Rmq-Problem-mex","date":"2019-08-08T13:26:27.000Z","updated":"2019-08-11T15:27:06.897Z","comments":true,"path":"archives/1e45153c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/1e45153c.html","excerpt":"","text":"传送门 首先建议看一下这篇博客，学习一下回滚莫队和撤销的奇巧淫技。 $0 \\le a_i \\le 10^9$，蜃是恐怖，但是发现如果答案$ans &gt; n+1$，说明$1 … n+1$所有数都出现过，但是我们只有$n$个数，所以矛盾，于是读入的时候这样处理即可。 1a[i]=min(n+1,read()); 加入一个数，如何维护$mex$值呢？ 按照上面的思路，维护一个$Max[i]$数组（其中$i$为连续$1$的端点时$Max[i]$才有意义）代表连续$1$的另一个端点的下标。 如果包含现在数字的连续$1$的左端点能到达$0$，说明现在的$mex$值为右端点$+1$ 1if (L==0) ans=R+1; 注意当加入的数为$0$的时候有一个小特判，为了防止$x-1$越界。 时间复杂度为$O(n \\sqrt n)$，但是它就是被卡了，交几次说不定能过呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],pos[MAXN],n,m;struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];&#125;static int Ans[MAXN];static int vis[MAXN];static int Max[MAXN];//最重要的数组，存的是这一段的另一个端点int ans,Size;struct node&#123; int pos,org;//位置，一开始的值&#125;stk[MAXN];int top,f;inline void Update(int pos,int val)&#123; if (f) stk[++top]=node&#123;pos,Max[pos]&#125;; Max[pos]=val;&#125;inline void Add(int x)&#123; vis[x]++; if (vis[x]&gt;1) return ; if (x==0) &#123;//特判 if (!vis[x+1]) ans=x+1; else ans=Max[x+1]+1; int R=Max[x+1]; Update(0,R);Update(R,0); return ; &#125; int L=vis[x-1]?Max[x-1]:x,R=vis[x+1]?Max[x+1]:x; if (L==0) ans=R+1; Update(L,R);Update(R,L);&#125;inline void Undo()&#123; for (register int i=top;i&gt;=1;--i)&#123; Max[stk[i].pos]=stk[i].org; &#125; top=0;&#125;inline int BruteForce(int l,int r)&#123; ans=0; f=false; for (register int i=l;i&lt;=r;++i)&#123; Add(a[i]); &#125; for (register int i=l;i&lt;=r;++i)&#123; Max[a[i]]=0,vis[a[i]]=0; &#125; int temp=ans; ans=0; return temp;&#125;inline int MoQueue(int i,int id)&#123; int R=min(n,Size*id); int l=R,r=R-1; ans=0; memset(vis,0,sizeof(vis)); memset(Max,0,sizeof(Max)); top=0; while (pos[q[i].l]==id)&#123; if (pos[q[i].l]==pos[q[i].r])&#123; Ans[q[i].id]=BruteForce(q[i].l,q[i].r); i++; continue; &#125; f=false; while (r&lt;q[i].r) Add(a[++r]); int temp=ans; f=true; while (l&gt;q[i].l) Add(a[--l]); Ans[q[i].id]=ans; while (l&lt;R) vis[a[l++]]--; Undo(); ans=temp; i++; &#125; return i;&#125;int main()&#123; n=read(),m=read(); Size=(int)(n/sqrt(m)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=min(n+1,read()); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int ptr=1; for (register int i=1;i&lt;=pos[n];++i)&#123; ptr=MoQueue(ptr,i); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; 8/11 upd 其实是我之前愚蠢了，其实不要用只插入的莫队，要用只删除的莫队 因为$mex$这个东西有很神奇的特性，你插入的时候不能$O(1)$得出$mex$，但是删除的时候，如果这个数的$cnt$被减至$0$，那么你的答案就和它取一个$\\min$即可。 于是使用只删除的莫队，以左端点所在的块编号为第一关键字升序排列，以右端点为第二关键字降序排列，然后预处理出$L$到$q[i].r$的$cnt$ 数组（$q[i].r$ 是这一段右端点的最大值），每次删除即可。 代码和思维上面都比较好想。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],pos[MAXN],n,m,Size;static int Ans[MAXN];struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]==pos[B.l]?A.r&gt;B.r:pos[A.l]&lt;pos[B.l];&#125;static int vis[MAXN],bf[MAXN];inline int BruteForce(int l,int r)&#123; for (register int i=l;i&lt;=r;++i)&#123; bf[a[i]]++; &#125; int pos=-1; while (bf[++pos]); for (register int i=l;i&lt;=r;++i)&#123; bf[a[i]]=0; &#125; return pos;&#125;inline int MoQueue(int i,int id)&#123; int L=(id-1)*Size+1,R=min(id*Size,n); memset(vis,0,sizeof(vis)); for (register int j=L;j&lt;=q[i].r;++j)&#123; vis[a[j]]++; &#125; int r=q[i].r; int ans=-1; while (vis[++ans]); for (;pos[q[i].l]==id;++i)&#123; if (pos[q[i].l]==pos[q[i].r])&#123; Ans[q[i].id]=BruteForce(q[i].l,q[i].r); continue; &#125; for (register int j=r;j&gt;q[i].r;--j)&#123; if (--vis[a[j]]==0) ans=min(ans,a[j]); &#125; r=q[i].r; int temp=ans; for (register int j=L;j&lt;q[i].l;++j)&#123; if (--vis[a[j]]==0) ans=min(ans,a[j]); &#125; Ans[q[i].id]=ans; for (register int j=L;j&lt;q[i].l;++j)&#123; ++vis[a[j]]; &#125; ans=temp; &#125; return i;&#125;int main()&#123; n=read(),m=read(); Size=(int)(n/sqrt(m)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=min(n+1,read()); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int ptr=1; for (register int i=1;i&lt;=pos[n];++i)&#123; ptr=MoQueue(ptr,i); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"回滚莫队","slug":"回滚莫队","permalink":"https://gaisaiyuno.github.io/tags/回滚莫队/"}]},{"title":"CF1202D Print a 1337-string...","slug":"CF1202D-Print-a-1337-string","date":"2019-08-07T15:55:38.000Z","updated":"2019-08-08T01:42:56.973Z","comments":true,"path":"archives/4813dbf2.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4813dbf2.html","excerpt":"","text":"传送门 加不了了，因为CF挂了。 $Pro$给你$n$，$n \\le 10^9$，要你输出一个字符串$s$，使得$s$有$n$个子串为$1337$，且$|s|\\le 10^5$ $Sol$1.$1337……7$，$n$个$7$？但是题目说$|s| \\le 10^5$，绝对会挂掉。 2.$1…….1337……7$？前面$a$个$1$，$b$个$7$，只要找到$a,b$，使得$a \\times b = n$即可，但是$n$为质数时就挂了。 $3.$考虑$1337$这样串的特性，发现$1$和$7$只能对答案造成$n$级别的贡献，但是$3$能对答案造成$n^2$级别的贡献。 构造一个这样的串$1….13….31…13….31….13…37$ 这样我们有足够多的$3$，可能对答案造成很多贡献。 继续yy，发现一个$1$对答案的贡献是$($它后面$3$的个数$)*($它后面$3$的个数$-1)/2$。 于是，我们要把$n$拆分成$\\sum \\frac{i \\times(i-1)}{2} \\times j$的形式。 第一眼看上去，我们预处理$\\frac {i \\times (i-1)}{2}$，这不就是裸的背包吗？ 但是仔细考虑之后，发现原来比背包还要简单，因为$2 \\times 1 /2 =1$，所以保证了有解，而且$\\frac {i \\times (i-1)}{2}$分布得比较紧密，完全可以用一个贪心算法求出解： 12345while (n&gt;0)&#123; int pos=upper_bound(Data+1,Data+MAXN,n)-Data-1; vis[pos]++; n-=Data[pos];&#125; 求出解后，我们得到了$vis$数组，代表你需要$vis[i]$个$1$，它的后面有$i$个$3$。 这不就好搞了吗，差分一下即可。 为什么串的长度能控制在$10^5$之内，感性理解一下，取数是贪心取的，串中$3$的数量大概就是$\\sqrt n$级别的，然而$\\sqrt {10^9} &lt; 10^5$，再算上$1$和$7$之类的边边角角大概不会超过。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int Data[MAXN];int vis[MAXN];inline void Put(char ch,int t)&#123; for (register int i=1;i&lt;=t;++i)&#123; putchar(ch); &#125;&#125;#undef intint main()&#123;#define int long long int t=read(); for (register int i=1;i&lt;MAXN;++i)&#123; Data[i]=i*(i+1)/2ll; &#125; while (t--)&#123; int n=read(); memset(vis,0,sizeof(vis)); while (n&gt;0)&#123; int pos=upper_bound(Data+1,Data+MAXN,n)-Data-1; vis[pos]++; n-=Data[pos]; &#125; int lst=-1; for (register int i=MAXN-1;i&gt;=0;--i)&#123; if (vis[i])&#123; if (lst!=-1) Put('3',lst-i); Put('1',vis[i]); lst=i; &#125; &#125; Put('3',lst+1); Put('7',1); printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"游戏「NOI2017」","slug":"游戏「NOI2017」","date":"2019-08-07T08:44:06.000Z","updated":"2019-08-07T13:36:07.057Z","comments":true,"path":"archives/bccff10.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/bccff10.html","excerpt":"","text":"洛谷 GDOI 发现$d \\le 8$，这仿佛在提示我们要暴力枚举$x$代表的是什么，注意到$b,c$和$a,c$就可以覆盖到$x$的所有情况，所以我们只要枚举$x$是$A$或$B$即可，时间复杂度$2^d$，我们把枚举出来的地图序列叫做$Map$ 考虑这样编号，$A$对应$[1,n]$，$B$对应$[n+1,2 \\times n]$，$C$对应$[2 \\times n +1 , 3*n]$ 但是这样太过愚蠢，我们知道$Map$是什么，所以一个位置不能放什么我们是知道的，不妨这样编号： $Map[i]==A$，不能放$A$，那么只能放$B,C$，$B -&gt; [1,n],C -&gt; [n+1,2 \\times n]$ $Map[i]==B$，不能放$B$，那么只能放$A,C$，$A -&gt; [1,n],C -&gt; [n+1,2 \\times n]$ $Map[i]==C$，不能放$C$，那么只能放$A,B$，$A -&gt; [1,n],B -&gt; [n+1,2 \\times n]$ 简单来说，就是按照字典序编号。 如图： 接下来分类讨论即可。 我们设$i$代表的序列为$a[i]$，$j$代表的序列为$a[j]$，$h_i=f1[i]，h_j=f2[j]$ 1.$f1[i]==Map[a[i]]$ 这就是告诉我们不能选$f1[i]$，否则选了就挂了，直接continue掉。 123if (f1[i]==Map[a[i]])&#123;//一旦选了就挂了 continue;&#125; 2.$f2[i]==Map[b[i]]$ 这也是告诉我们不能选$f1[i]$，但是我们可以选其他的，整理一下思路，发现$Map[a[i]]$不能选$f1[i]$不能选，根据上面我们的特判，发现$Map[a[i]]!=f1[i]$，所以只有一个字母能选。 如何建一个图，强制选剩下的那个字母，这里我们使用奇巧淫技，假设第一列选了$B$第三列就必须选$C$，现在我们知道第一列只能选$C$，就连一条$B-&gt;C$，这样你选了$B$就必须选$C$，造成矛盾，等于是强制选了$C$ 12345else if (f2[i]==Map[b[i]])&#123;//也是选了就挂了，但是有一种可以的选择 //eg. a[i]=='B' Map[f1[i]]=='A' so 只能选'C' int delta=GetDelta1(i); AddEdge(a[i]+delta,a[i]+n-delta);&#125; 3.$else$ 这是最普通的情况，假设第一列选了$B$第三列就必须选$B$，按照$2-SAT$的问题的套路，我们要寻找有依赖性关系的点对，显然，选了第一列的$B$，就必须选第三列的$B$，还有，选了第三列的$A$，就必须选第一列的$C$，否则会发生矛盾，于是他们两个点对连边： 123int delta1=GetDelta1(i),delta2=GetDelta2(i);AddEdge(a[i]+delta1,b[i]+delta2);AddEdge(b[i]+n-delta2,a[i]+n-delta1); 代码写的比较丑陋，其中一些细节模拟一下就知道了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int dfn[MAXN],low[MAXN],cnt;stack&lt;int&gt;stk;int scc,col[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk.push(u); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if (!col[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++scc; do&#123; col[u]=scc; u=stk.top(),stk.pop(); &#125;while (low[u]!=dfn[u]); &#125;&#125;inline char GetPre(char ch)&#123; if (ch=='A') return 'B'; if (ch=='B') return 'A'; if (ch=='C') return 'A';&#125;inline char GetNex(char ch)&#123; if (ch=='A') return 'C'; if (ch=='B') return 'C'; if (ch=='C') return 'B';&#125;inline char gc()&#123; char ch=getchar(); while (!isalpha(ch)) ch=getchar(); if (ch&gt;='a'&amp;&amp;ch&lt;='z') return ch-'a'+'A'; else return ch;&#125;char Map[MAXN],ans[MAXN];int a[MAXN],b[MAXN];char f1[MAXN],f2[MAXN];int pos[MAXN];//存的是x的下标int n,m,d;inline void Init()&#123; while (stk.size()) stk.pop(); memset(col,0,sizeof(col)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); scc=cnt=0; for (register int i=0;i&lt;MAXN;++i)&#123; G[i].clear(); &#125;&#125;inline void GetAns()&#123; bool flag=true; for (register int i=1;i&lt;=n*2;++i)&#123; if (!dfn[i]) tarjan(i); &#125; for (register int i=1;i&lt;=n;++i)&#123; if (col[i]==col[i+n])&#123; flag=false; break; &#125; if (col[i]&lt;col[i+n]) ans[i-1]=GetPre(Map[i]); else ans[i-1]=GetNex(Map[i]); &#125; if (flag==true)&#123; cout&lt;&lt;ans; exit(0); &#125;&#125;inline int GetDelta1(int pos)&#123; //写成注释里这样可能方便理解 // if (Map[a[pos]]=='A'&amp;&amp;f1[pos]=='B') return 0; // if (Map[a[pos]]=='A'&amp;&amp;f1[pos]=='C') return n; // if (Map[a[pos]]=='B'&amp;&amp;f1[pos]=='A') return 0; // if (Map[a[pos]]=='B'&amp;&amp;f1[pos]=='C') return n; // if (Map[a[pos]]=='C'&amp;&amp;f1[pos]=='A') return 0; // if (Map[a[pos]]=='C'&amp;&amp;f1[pos]=='B') return n; return (f1[pos]=='A'||(f1[pos]=='B'&amp;&amp;Map[a[pos]]=='A'))?0:n;&#125;inline int GetDelta2(int pos)&#123; // if (Map[b[pos]]=='A'&amp;&amp;f2[pos]=='B') return 0; // if (Map[b[pos]]=='A'&amp;&amp;f2[pos]=='C') return n; // if (Map[b[pos]]=='B'&amp;&amp;f2[pos]=='A') return 0; // if (Map[b[pos]]=='B'&amp;&amp;f2[pos]=='C') return n; // if (Map[b[pos]]=='C'&amp;&amp;f2[pos]=='A') return 0; // if (Map[b[pos]]=='C'&amp;&amp;f2[pos]=='B') return n; return (f2[pos]=='A'||(f2[pos]=='B'&amp;&amp;Map[b[pos]]=='A'))?0:n;&#125;int main()&#123; n=read(),d=read(); int c=0; scanf(\"%s\",Map+1); for (register int i=1;i&lt;=n;++i)&#123; Map[i]-='a',Map[i]+='A'; if (Map[i]=='X') pos[++c]=i; &#125; m=read(); for (register int i=1;i&lt;=m;++i)&#123; a[i]=read(),f1[i]=getchar(),b[i]=read(),f2[i]=getchar(); getchar(); &#125; for (register int v=0;v&lt;(1&lt;&lt;d);++v)&#123; Init(); for (register int i=1;i&lt;=d;++i)&#123; if (v&amp;(1&lt;&lt;(i-1))) Map[pos[i]]='A'; else Map[pos[i]]='B'; &#125; for (register int i=1;i&lt;=m;++i)&#123; if (f1[i]==Map[a[i]])&#123;//一旦选了就挂了 continue; &#125; else if (f2[i]==Map[b[i]])&#123;//也是选了就挂了，但是有一种可以的选择 //eg. a[i]=='A' Map[f1[i]]=='B' so 只能选'C' int delta=GetDelta1(i); AddEdge(a[i]+delta,a[i]+n-delta); &#125; else &#123; int delta1=GetDelta1(i),delta2=GetDelta2(i); AddEdge(a[i]+delta1,b[i]+delta2); AddEdge(b[i]+n-delta2,a[i]+n-delta1); &#125; &#125; GetAns(); &#125; puts(\"-1\");&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://gaisaiyuno.github.io/tags/2-SAT/"},{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"}]},{"title":"BZOJ 4358 permu","slug":"BZOJ-4358-permu","date":"2019-08-07T02:11:22.000Z","updated":"2019-08-08T13:44:27.865Z","comments":true,"path":"archives/f36dea03.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/f36dea03.html","excerpt":"","text":"BZOJ GDOI 首先，安利一下巨佬ypy的博客，我的思路是参照ypy博客的。 先说一下我的思路，首先，将问题抽象为往一个数轴上面放$1$，求最长连续$1$的值。 Sol1:线段树维护连续$1$的最大值，代码非常简单，维护区间连续$1$最大值$maxn$，从左边开始连续$1$最大值$lmax$，从右边开始连续$1$最大值$rmax$，区间$1$的和$val$。 时间复杂度$O(n \\sqrt n \\log n)$，在$BZOJ$上面$\\rm AC$，但是在$GDOI$上面$TLE$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r,val; int lmax,rmax,maxn; inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Change(int i)&#123; tree[i].lmax=1-tree[i].lmax; tree[i].rmax=1-tree[i].rmax; tree[i].maxn=1-tree[i].maxn; tree[i].val=1-tree[i].val; &#125; inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; tree[i].lmax=tree[lc].lmax; if (tree[lc].val==tree[lc].len()) tree[i].lmax=max(tree[i].lmax,tree[lc].len()+tree[rc].lmax); tree[i].rmax=tree[rc].rmax; if (tree[rc].val==tree[rc].len()) tree[i].rmax=max(tree[i].rmax,tree[rc].len()+tree[lc].rmax); tree[i].maxn=max(max(tree[lc].maxn,tree[rc].maxn),tree[lc].rmax+tree[rc].lmax); &#125; void Update(int i,int l,int r,int pos)&#123; if (l==r)&#123; Change(i); return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,l,mid,pos); else Update(rc,mid+1,r,pos); pushup(i); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125;&#125;using namespace SegmentTree;int a[MAXN],pos[MAXN];struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int Ans[MAXN];int main()&#123; int n=read(),m=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int l=1,r=0; Build(1,1,n); for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Update(1,1,n,a[l++]); while (l&gt;q[i].l) Update(1,1,n,a[--l]); while (r&lt;q[i].r) Update(1,1,n,a[++r]); while (r&gt;q[i].r) Update(1,1,n,a[r--]); Ans[q[i].id]=tree[1].maxn; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; Sol2:线段树不行，怎么搞？ 注意到题目说的是$1$到$n$的排列，所以每个数都是不同的。 首先，发现一个性质，只有往连续$1$的端点左/右侧放$1$，才能增加答案长♂度。 我们画图理解一下： 其中标红代表原来就有$1$。 考虑加进一个数，用蓝色代表。 显然，加进这样一个蓝色对答案没有影响，因为答案至少是$1$。 但是这样加一个蓝色对答案就有影响了。 考虑维护这样一个$Max[i]$数组，其中当$i$为端点时， $Max[i]$代表连续$1$的另一端的下标。 对于这个图来说： $Max[2]=4,Max[4]=2,Max[6]=6$ 考虑如何维护这个$Max$数组。 加进一个$1$之后，计算加进这个$1$后包含这个$1$的最长连续$1$的左右端点，用$L$，$R$表示。 那么我们更新的时候直接$Max[L]=R,Max[R]=L$即可。 考虑如何撤销，发现这个撤销并不好搞，因为从中间断开的时候，无法知道左右端点在哪里。 于是我们使用回滚莫队，具体可以参见这篇博客。 加入的时候，我们搞一个栈，每来一个更新操作，把修改的位置和原来的值记上，然后还原就直接从栈里面一个一个还原即可，不用所谓的撤销操作。 特别特别注意一点，暴力搞完以后要把$ans$设成$1$，因为这个调了一个晚上。 时间复杂度$O(n \\sqrt n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],pos[MAXN],n,m;struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];&#125;static int Ans[MAXN];static int vis[MAXN];static int Max[MAXN];//最重要的数组，存的是这一段的另一个端点int ans,Size;struct node&#123; int pos,org;//位置，一开始的值&#125;stk[MAXN];int top,f;inline void Update(int pos,int val)&#123; if (f) stk[++top]=node&#123;pos,Max[pos]&#125;; Max[pos]=val;&#125;inline void Add(int x)&#123; vis[x]=1; int L=vis[x-1]?Max[x-1]:x,R=vis[x+1]?Max[x+1]:x; ans=max(ans,R-L+1); Update(L,R);Update(R,L);&#125;inline void Undo()&#123; for (register int i=top;i&gt;=1;--i)&#123; Max[stk[i].pos]=stk[i].org; &#125; top=0;&#125;inline int BruteForce(int l,int r)&#123; ans=1; f=false; for (register int i=l;i&lt;=r;++i)&#123; Add(a[i]); &#125; for (register int i=l;i&lt;=r;++i)&#123; Max[a[i]]=0,vis[a[i]]=0; &#125; int temp=ans; ans=1; return temp;&#125;inline int MoQueue(int i,int id)&#123; int R=min(n,Size*id); int l=R,r=R-1; ans=1; memset(vis,0,sizeof(vis)); memset(Max,0,sizeof(Max)); top=0; while (pos[q[i].l]==id)&#123; if (pos[q[i].l]==pos[q[i].r])&#123; Ans[q[i].id]=BruteForce(q[i].l,q[i].r); i++; continue; &#125; f=false; while (r&lt;q[i].r) Add(a[++r]); int temp=ans; f=true; while (l&gt;q[i].l) Add(a[--l]); Ans[q[i].id]=ans; while (l&lt;R) vis[a[l++]]=0; Undo(); ans=temp; i++; &#125; return i;&#125;int main()&#123; n=read(),m=read(); Size=(int)(n/sqrt(m)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int ptr=1; for (register int i=1;i&lt;=pos[n];++i)&#123; ptr=MoQueue(ptr,i); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"回滚莫队","slug":"回滚莫队","permalink":"https://gaisaiyuno.github.io/tags/回滚莫队/"}]},{"title":"AT1219 歴史の研究","slug":"AT1219-歴史の研究","date":"2019-08-06T09:35:56.000Z","updated":"2019-08-06T10:24:34.564Z","comments":true,"path":"archives/e8e86fd2.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e8e86fd2.html","excerpt":"","text":"传送门 首先，如果这道题用的是普通的莫队，那么删除元素的时候，可能出现次数最大的那个元素的出现次数被减少至小于出现次数第二大的那个元素的出现次数，此时，你就没法知道出现次数第二大的元素的值，就咕咕了。 当然你也可以用一个$\\rm set$搞，但是估计会$\\rm TLE$ 这里要介绍一种莫队，叫做回滚莫队。 先考虑莫队的排序方式，我们把整个序列分块，以左端点所在的块的编号为第一关键字，右端点所在的块的编号为第二关键字来排序。 不妨分块考虑，我们钦定左端点，让它就在其中一个块里面，当然右端点我们管不着。 如图，左端点$l$在蓝色区域，右端点$r$在红色区域。 根据排序的方式，发现右端点一直递增。 设蓝色区域左端点是$L$，右端点是$R$ 分情况讨论： 1.$r \\le R$ 这时我们查询的就是类似于绿色区域的东东，暴力搞就可以了，时间复杂度为$O(\\sqrt n)$ 2.$r&gt;R$ 这时我们查询的就是类似于绿色区域的东东，不妨把绿色区域分成两块： 分成了$[l,R],[R+1,r]$两块，发现$[R+1,r]$非常好搞，因为$r$ 是递增的，所以移动$r$过程中统计即可。 但是$[l,R]$不好搞，$l$没有单调性。 别忘了我们钦定了$l$在同一块，所以暴力移动$l$，时间复杂度$O (\\sqrt n)$，最后别忘了还原$l$。 所以，钦定$l$ 这种思路非常巧妙，不知道高到哪里去了。 形象一点来说，$l$的移动非常繁忙，每来一个$r$都要在块内移动一个来回，但是$r$非常轻松，只要一直往右移动就行了。 代码如下，注意开$\\text{long long}$ 我感觉写起来不怎么优美。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN],org[MAXN],pos[MAXN],n,m;struct Query&#123; int l,r; int id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]==pos[B.l]?A.r&lt;B.r:pos[A.l]&lt;pos[B.l];&#125;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i) b[i]=a[i]; sort(b+1,b+1+n); int s=unique(b+1,b+1+n)-b-1; for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+s,a[i])-b; &#125;&#125;int Size,cnt[MAXN],Ans[MAXN];inline int BruteForce(int l,int r)&#123; //这里不能直接memset不然就不是O(sqrt(n))的了 for (register int i=l;i&lt;=r;++i) cnt[a[i]]=0; int ret=0; for (register int i=l;i&lt;=r;++i) &#123; ret=max(ret,org[i]*(++cnt[a[i]])); &#125; return ret;&#125;int c[MAXN],ans;inline void Add(int x)&#123; ans=max(ans,org[x]*(++c[a[x]]));&#125;inline void Del(int x)&#123; --c[a[x]];&#125;inline int MoQueue(int i,int id)&#123;//返回下一个块的第一个询问的编号 int R=min(n,Size*id); int l=R,r=R-1; ans=0; memset(c,0,sizeof(c)); while (pos[q[i].l]==id)&#123; if (pos[q[i].l]==pos[q[i].r]) &#123; Ans[q[i].id]=BruteForce(q[i].l,q[i].r); i++; continue; &#125; while (r&lt;q[i].r) Add(++r); int temp=ans;//记录的是[R+1,r]的答案 while (l&gt;q[i].l) Add(--l); Ans[q[i].id]=ans; while (l&lt;R) Del(l++); ans=temp; i++; &#125; return i;&#125;#undef intint main()&#123;#define int long long n=read(),m=read(); Size=(int)(sqrt(n)); for (register int i=1;i&lt;=n;++i)&#123; org[i]=a[i]=read(); pos[i]=(i-1)/Size+1; &#125; discrete(); for (register int i=1;i&lt;=m;++i)&#123; int l=read(),r=read(); q[i]=Query&#123;l,r,i&#125;; &#125; sort(q+1,q+1+m); int ptr=1; for (register int i=1;i&lt;=pos[n];++i)&#123; ptr=MoQueue(ptr,i); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%lld\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"回滚莫队","slug":"回滚莫队","permalink":"https://gaisaiyuno.github.io/tags/回滚莫队/"}]},{"title":"梦幻布丁「HNOI2009」","slug":"梦幻布丁「HNOI2009」","date":"2019-08-06T08:06:31.000Z","updated":"2019-08-06T08:25:29.587Z","comments":true,"path":"archives/870db3db.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/870db3db.html","excerpt":"","text":"BZOJ GDOI 对于每种颜色开一棵线段树，比如说对于颜色序列$\\text {1 2 2 3 3 2}$，它的线段树开出来是这样的： 因为两种颜色搞在一起后，没有任何操作能把他们分开，不妨把替换视为合并。 比如把$3$替换成$2$，就是把$3$合并到$2$。 考虑如何$\\rm pushup$，只要维护区间左右端点值$(0/1)$，和区间$1$的段数即可，如果左区间的右端点和右区间的左端点都是$1$，那么他们拼起来形成一大段，所以段数$-1$。 合并也非常简单，发现把$y$合并到$x$，就相当于把$y$所代表的线段树合并到$x$，并且删除$y$所代表的线段树。 还有一些要分类讨论的小细节：如果两种颜色相同或者没有$x$这种颜色，那么什么都不用搞，如果有$x$而没有$y$，那么相当于把$x$替换成$y$，换一下根即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val;//1或者0 int lval,rval,sum;//左边为0/1，右边为0/1，总的段数 &#125;tree[MAXN*30]; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i,int x,int y)&#123; tree[i].lval=tree[x].lval; tree[i].rval=tree[y].rval; tree[i].sum=tree[x].sum+tree[y].sum; if (tree[x].rval==1&amp;&amp;tree[y].lval==1) tree[i].sum--; &#125; int tot; void Update(int &amp;i,int l,int r,int pos)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].lval=tree[i].rval=tree[i].sum=1; return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,l,mid,pos); else Update(rc,mid+1,r,pos); pushup(i,lc,rc); &#125; void Merge(int &amp;x,int &amp;y)&#123; if (!x||!y)&#123; x=x+y; return ; &#125; Merge(tree[x].l,tree[y].l); Merge(tree[x].r,tree[y].r); pushup(x,tree[x].l,tree[x].r); y=0;//非常重要，要删除y这棵树 &#125;&#125;using namespace SegmentTree;map&lt;int,int&gt;rt;int main()&#123; #define SUM(c) tree[rt[c]].sum int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; int color=read(); Update(rt[color],1,n,i); &#125; int ans=0; for (const auto&amp; it:rt)&#123; ans+=SUM(it.first); &#125; for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1)&#123; int x=read(),y=read(); if (x==y||!rt[x]) continue;//如果两种颜色相同或者没有x这种颜色 if (!rt[y])&#123;//相当于是替换 rt[y]=rt[x]; rt[x]=0; continue; &#125; ans-=SUM(x),ans-=SUM(y); Merge(rt[y],rt[x]); ans+=SUM(y); &#125; else &#123; printf(\"%d\\n\",ans); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://gaisaiyuno.github.io/tags/线段树合并/"}]},{"title":"BZOJ 3757 苹果树","slug":"BZOJ-3757-苹果树","date":"2019-08-06T02:35:01.000Z","updated":"2019-08-06T03:14:28.761Z","comments":true,"path":"archives/246744bc.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/246744bc.html","excerpt":"","text":"BZOJ GDOI 首先，看见不同颜色之类的话就要想到莫队，但是这次问题出在了树上，所以是树上莫队? 没错！ 普通莫队是在一个一个地移动指针，树上莫队是一个一个爬节点——SXYZ巨佬 图片引自洛谷 首先，假设你知道了欧拉序是什么东西，不知道出门右拐百度。 这棵树的欧拉序就是$1,2,4,6,6,7,7,5,5,4,2,3,3,1$ 有什么性质，仔细观察，每个数都出现了两次，而且左边的那个数和右边的那个数夹着的正好是它的子树。 我们设$L[u]$为$u$第一次出现在欧拉序中它的编号，$R[u]$为$u$最后一次出现在欧拉序中它的编号。 如$L[4]=3,R[4]=10$。 树上莫队其实上就是在欧拉序上面爬来爬去。 假设现在我们要查询$(u,v)$这条链，首先我们要调教一下这条链，假设$L[u]&gt;L[v]$，要交换一下$u,v$，这其实就是保证了查询的区间左端点小于右端点。 我们分情况讨论： 1.$LCA(u,v)==u$，即$v \\in subtree(u)$ 查询的即是$[L[u],L[v]]$这段区间 1if (u==lca) q[i]=make_q(L[u],L[v],0,i,a,b);//u为这条链的顶点 2.$LCA(u,v)!=u$，即$v \\notin subtree(u)$ 这种情况查询的就不是$[L[u],L[v]]$，考虑一下刚才说的性质：$[L[u]+1,R[u]-1]$之间是$u$的子树，如果你还是按照这样算的话，$u$的子树也会统计进去。 于是查询的区间变成$[R[u],L[v]]$ 1else q[i]=make_q(R[u],L[v],lca,i,a,b); 对了，还有一个细节，发现对于第一种情况$LCA(u,v)==u$，所以$LCA(u,v)$会被统计到，不用管，但是第二种情况就会出锅，于是我们再记录一个$lca$ 就可以了。 回到本题，如果没有色盲这道题就是裸题，但是加入色盲怎么搞？ 考虑分类讨论，假设没有$a$这种颜色，那么什么都不用考虑，如果有$a$，但是没有$b$，就是把$a$替换成$b$，答案不变，于是只用考虑有$a$，也有$b$的情况，答案减1 注意$a==b$的特判。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MAXM 17using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int c[MAXN];//每个点的颜色int anc[MAXN][MAXM],dep[MAXN];int euler[MAXN];//欧拉序(出栈入栈都要记录)int L[MAXN],R[MAXN];//左右端点int tot;void dfs(int u,int father)&#123; dep[u]=dep[father]+1; anc[u][0]=father; euler[L[u]=++tot]=u; for (register int i=1;i&lt;MAXM;++i) anc[u][i]=anc[anc[u][i-1]][i-1]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father) dfs(v,u); &#125; euler[R[u]=++tot]=u;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i],v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;int n,m;int b[MAXN];//块编号struct Query&#123; int u,v,lca,id,a,b;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123;//莫队的玄学优化 return (b[A.u]^b[B.u])?b[A.u]&lt;b[B.u]:((b[A.u]&amp;1)?A.v&lt;B.v:A.v&gt;B.v);&#125;int inq[MAXN];//在不在莫队维护的范围内int ans,cnt[MAXN];inline void Update(int i)&#123;//相应地加上/减去元素 if (!inq[i])&#123;//加上 cnt[c[i]]++; if (cnt[c[i]]==1) ans++; inq[i]=true; &#125; else &#123; cnt[c[i]]--; if (cnt[c[i]]==0) ans--; inq[i]=false; &#125;&#125;int Ans[MAXN];inline Query make_q(int u,int v,int lca,int id,int a,int b)&#123; Query temp; temp.id=id; temp.u=u,temp.v=v; temp.lca=lca; temp.a=a,temp.b=b; return temp;&#125;int main()&#123; n=read(),m=read();int Size=sqrt(n);//块大小 for (register int i=0;i&lt;MAXN;++i)&#123; b[i]=i/Size+1; &#125; for (register int i=1;i&lt;=n;++i)&#123; c[i]=read(); &#125; int rt; for (register int i=1;i&lt;=n;++i)&#123; int u=read(),v=read(); if (u==0) rt=v; if (v==0) rt=u; AddEdge(u,v); AddEdge(v,u); &#125; dfs(rt,rt); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),a=read(),b=read(); if (L[u]&gt;L[v]) swap(u,v);//保证这条链是从左往右 int lca=LCA(u,v); if (u==lca) q[i]=make_q(L[u],L[v],0,i,a,b);//u为这条链的顶点 else q[i]=make_q(R[u],L[v],lca,i,a,b); &#125; sort(q+1,q+1+m); int l=1,r=0;//模仿STL队列 for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].u) Update(euler[l++]); while (l&gt;q[i].u) Update(euler[--l]); while (r&lt;q[i].v) Update(euler[++r]); while (r&gt;q[i].v) Update(euler[r--]); if (q[i].lca) Update(q[i].lca);//注意处理lca Ans[q[i].id]=ans; if (cnt[q[i].a]&amp;&amp;cnt[q[i].b]&amp;&amp;q[i].a!=q[i].b) Ans[q[i].id]--; if (q[i].lca) Update(q[i].lca); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树上莫队","slug":"树上莫队","permalink":"https://gaisaiyuno.github.io/tags/树上莫队/"}]},{"title":"P3007 [USACO11JAN]大陆议会The Continental Cowngress","slug":"P3007-USACO11JAN-大陆议会The-Continental-Cowngress","date":"2019-08-06T01:54:08.000Z","updated":"2019-08-06T02:01:21.939Z","comments":true,"path":"archives/9eef84b4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/9eef84b4.html","excerpt":"","text":"洛谷 GDOI 首先，按照$2-SAT$问题的套路，我们要把这个转化成依赖性问题 又发现一只奶牛刚好投两次票，所以只要不满足奶牛的其中一次投票，就要满足另一次，这样就转化成了依赖性问题。 但是，这道题还要输出$”?”$，怎么搞 再看一眼数据范围$1 \\le N \\le 1000$，这样小的数据范围，暴力都能过。 于是不妨从两个相对的节点$bfs$一遍，如果他们两个都没有矛盾，那么输出$?$，如果一个有矛盾，那么输出$Y/N$，如果都有矛盾，那么输出$IMPOSSIBLE$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define MAXN 4005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int vis[MAXN],n,m;inline int Other(int u)&#123; if (u&lt;=n) return u+n; else return u-n;&#125;inline bool bfs(int s)&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(s); while (Q.size())&#123; int u=Q.front();Q.pop(); vis[u]=true; if (vis[Other(u)]) return false; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (!vis[v]) Q.push(v); &#125; &#125; return true;&#125;inline char gc()&#123; char ch=getchar(); while (ch!='Y'&amp;&amp;ch!='N') ch=getchar(); return ch=='Y';&#125;int main()&#123; n=read(),m=read(); //1 ... n赞成票 //n+1 ... 2*n反对票 for (register int i=1;i&lt;=m;++i)&#123; int u=read(),f1=gc(),v=read(),f2=gc(); AddEdge(u+(!f1)*n,v+f2*n); AddEdge(v+(!f2)*n,u+f1*n); &#125; string Ans=\"\"; for (register int i=1;i&lt;=n;++i)&#123; bool True=bfs(i),False=bfs(Other(i)); if (!True&amp;&amp;!False)&#123; puts(\"IMPOSSIBLE\"); return 0; &#125; else if (True&amp;&amp;!False)&#123; Ans+='N'; &#125; else if (False&amp;&amp;!True)&#123; Ans+='Y'; &#125; else &#123; Ans+='?'; &#125; &#125; cout&lt;&lt;Ans&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://gaisaiyuno.github.io/tags/2-SAT/"},{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"}]},{"title":"LOJ #10097. 「一本通 3.5 练习 5」和平委员会","slug":"LOJ-10097-「一本通-3-5-练习-5」和平委员会","date":"2019-08-05T15:01:25.000Z","updated":"2019-08-05T15:09:37.617Z","comments":true,"path":"archives/c7bc6e92.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c7bc6e92.html","excerpt":"","text":"传送门 GDOI 根据$2-SAT$套路，我们要把这个问题转换成依赖性问题，即选择$u$，就必须选$v$。 这个也是非常好转化的，假设$i$，$j$互相憎恶，因为每个党派都必须有一个代表，所以选择了$i$就必须选择$j$所在的党派的另一人，同理，选择了$j$就必须选择$i$所在党派的另一人。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int dfn[MAXN],low[MAXN],cnt;stack&lt;int&gt;stk;int scc,col[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk.push(u); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if (!col[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++scc; do&#123; col[u]=scc; u=stk.top(),stk.pop(); &#125;while (low[u]!=dfn[u]); &#125;&#125;inline int Other(int x)&#123;//返回x的党派的另一人 if (x%2==0) return x-1; else return x+1;&#125;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); AddEdge(u,Other(v)); AddEdge(v,Other(u)); &#125; for (register int i=1;i&lt;=(n&lt;&lt;1);++i)&#123; if (!dfn[i]) tarjan(i); &#125; for (register int i=1;i&lt;=n;++i)&#123; if (col[i*2-1]==col[i*2])&#123; puts(\"NIE\"); return 0; &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; int u=i*2-1,v=i*2; if (col[u]&lt;col[v]) printf(\"%d\\n\",u); else printf(\"%d\\n\",v); &#125;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://gaisaiyuno.github.io/tags/2-SAT/"},{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"tarjan","slug":"tarjan","permalink":"https://gaisaiyuno.github.io/tags/tarjan/"}]},{"title":"P4305 [JLOI2011]不重复数字","slug":"P4305-JLOI2011-不重复数字","date":"2019-08-05T13:36:57.000Z","updated":"2019-08-05T13:51:03.229Z","comments":true,"path":"archives/753c5dd7.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/753c5dd7.html","excerpt":"","text":"传送门 为什么要用平衡树呢，这道题不是蛤希裸题吗？ 对于加进来的每个数，你暴力蛤希一下，加进一个$vector$里面，查找的时候也是暴力在$vector$里面查找。 经过试验，在模数为$223$时表现较好，为了避免毒瘤出题者卡你之类的，尽量避免用那些比较常见的模数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define MAXN 224#define MOD 223using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline int id(int x)&#123; return (x%MOD+MOD)%MOD;&#125;inline void Insert(int x)&#123; G[id(x)].push_back(x);&#125;inline bool Check(int x)&#123; int pos=id(x); for (register int i=0;i&lt;G[pos].size();++i)&#123; if (G[pos][i]==x) return true; &#125; return false;&#125;int main()&#123; int t=read(); while (t--)&#123; for (register int i=0;i&lt;MAXN;++i)&#123; G[i].clear(); &#125; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(); if (!Check(x))&#123; Insert(x); printf(\"%d \",x); &#125; &#125; printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"哈希","slug":"哈希","permalink":"https://gaisaiyuno.github.io/tags/哈希/"}]},{"title":"P3168 [CQOI2015]任务查询系统","slug":"P3168-CQOI2015-任务查询系统","date":"2019-08-05T13:13:31.000Z","updated":"2019-08-05T13:30:29.800Z","comments":true,"path":"archives/79e886c3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/79e886c3.html","excerpt":"","text":"传送门 先考虑一下暴力怎么打，对于每个时间，我们开一个$vector$，对于每一个任务，我们在$[S_i,E_i]$的$vector$里面都$pushback$一遍$P_i$即可。 但是这样的暴力是愚蠢的暴力，考虑优化，我们在$S_i$和$E_i+1$的位置分别打上加入和删除标记，到某一个时间，我们先复制上一个时间的$vector$，然后按照标记加入和删除$P_i$，事实上，这起了差分的作用。 这样会有什么不好的地方，首先，每次复制上一次的$vector$，绝对会爆空间，其次，查询不好搞。 如何减少空间，我们使用jzm主席树，每次加入或者删除$P_i$最多只需要$\\log n$的空间，在主席树上面查询也比较好搞，只要在每个节点维护任务的总数，任务的优先级之和即可。 如果你想偷懒（像我一样），预处理的时候不用一个一个合并过去，而是每个节点先插入$P_i$，然后一个一个线段树合并过去，代码量能减少不少。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define LOG 105using namespace std;int S[MAXN],E[MAXN],P[MAXN];int org[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int cnt;//任务的总数 int val;//任务的优先级之和 &#125;tree[MAXN*LOG]; int tot; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i,int x,int y)&#123; tree[i].cnt=tree[x].cnt+tree[y].cnt; tree[i].val=tree[x].val+tree[y].val; &#125; void Update(int &amp;i,int l,int r,int pos,int val)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].cnt+=val; tree[i].val+=val*P[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,l,mid,pos,val); else Update(rc,mid+1,r,pos,val); pushup(i,lc,rc); &#125; int Query(int i,int l,int r,int k)&#123; if (l==r)&#123; return P[l]*min(k,tree[i].cnt);//特别注意，因为查询的可能大于任务总数 &#125; int mid=(l+r)&gt;&gt;1; if (tree[lc].cnt&gt;=k) return Query(lc,l,mid,k); else return tree[lc].val+Query(rc,mid+1,r,k-tree[lc].cnt); &#125; void Merge(int &amp;x,int y)&#123;//y-&gt;x if (!x||!y)&#123; x=x+y; return ; &#125; pushup(x,x,y); Merge(tree[x].l,tree[y].l); Merge(tree[x].r,tree[y].r); &#125;&#125;using namespace SegmentTree;int main()&#123; int m=read(),n=read(); for (register int i=1;i&lt;=m;++i)&#123; S[i]=read(),E[i]=read(),org[i]=P[i]=read(); &#125; sort(P+1,P+1+m); int M=unique(P+1,P+1+m)-P-1; for (register int i=1;i&lt;=m;++i)&#123; int rk=lower_bound(P+1,P+1+M,org[i])-P; Update(rt[S[i]],1,M,rk,1); Update(rt[E[i]+1],1,M,rk,-1); &#125; for (register int i=1;i&lt;=n;++i)&#123; Merge(rt[i],rt[i-1]); &#125; int pre=1; for (register int i=1;i&lt;=n;++i)&#123; int x=read(),a=read(),b=read(),c=read(); int k=(1+((long long)a*pre+b)%c); printf(\"%d\\n\",pre=Query(rt[x],1,M,k)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"}]},{"title":"P4396 [AHOI2013]作业","slug":"P4396-AHOI2013-作业","date":"2019-08-05T13:07:14.000Z","updated":"2019-08-05T13:12:08.784Z","comments":true,"path":"archives/24fa11cb.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/24fa11cb.html","excerpt":"","text":"洛谷 GDOI 本质和这道题P4867是一样的，先看一看这篇博客的代码，魔改一下就可以$A$了。 魔改也非常简单，只要再开一个分块，有数加进来就加进分块的数组里面，不用判重。 然后，更加简单的是，这题竟然不用离散化也能$A$，数据过水。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MAXM 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],Size;static int pos[MAXN],cnt[MAXN],val1[MAXN];//块内所有数之和static int val2[MAXN];//只要出现过就加上namespace Divide_Into_Blocks&#123; inline int Calc1(int l,int r)&#123; int ans=0; for (register int i=l;i&lt;=r;++i) ans+=cnt[i]&gt;0; return ans; &#125; inline int GetAns1(int a,int b)&#123; int L=pos[a],R=pos[b]; if (L==R) return Calc1(a,b); int ans=0; for (register int i=L+1;i&lt;=R-1;++i) ans+=val1[i]; return ans+Calc1(a,L*Size)+Calc1((R-1)*Size+1,b); &#125; inline int Calc2(int l,int r)&#123; int ans=0; for (register int i=l;i&lt;=r;++i) ans+=cnt[i];//只要来一个就加上 return ans; &#125; inline int GetAns2(int a,int b)&#123; int L=pos[a],R=pos[b]; if (L==R) return Calc2(a,b); int ans=0; for (register int i=L+1;i&lt;=R-1;++i) ans+=val2[i]; return ans+Calc2(a,L*Size)+Calc2((R-1)*Size+1,b); &#125;&#125;using namespace Divide_Into_Blocks;struct Query&#123; int l,r,a,b,id;&#125;q[MAXM];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int ans;inline void Add(int x)&#123; ++val2[pos[x]];//不进行判重 if (++cnt[x]==1) ++val1[pos[x]];&#125;inline void Del(int x)&#123; --val2[pos[x]]; if (--cnt[x]==0) --val1[pos[x]];&#125;int Ans1[MAXM],Ans2[MAXN];int main()&#123; int n=read(),m=read(); Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].a=read(),q[i].b=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(a[l++]); while (l&gt;q[i].l) Add(a[--l]); while (r&lt;q[i].r) Add(a[++r]); while (r&gt;q[i].r) Del(a[r--]); Ans1[q[i].id]=GetAns1(q[i].a,q[i].b); Ans2[q[i].id]=GetAns2(q[i].a,q[i].b); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d %d\\n\",Ans2[i],Ans1[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"分块","slug":"分块","permalink":"https://gaisaiyuno.github.io/tags/分块/"}]},{"title":"「BZOJ3289」Mato的文件管理","slug":"「BZOJ3289」Mato的文件管理","date":"2019-08-05T09:48:39.000Z","updated":"2019-08-05T10:05:08.589Z","comments":true,"path":"archives/13dd710.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/13dd710.html","excerpt":"","text":"BZOJ GDOI 一句话题意：给你$l,r$，求$a[l],a[l+1]…a[r]$逆序对个数。 按照套路，我们先离散化。 然后考虑加入一个数会对逆序对做出多少贡献，先考虑我们从左边加入一个数，如图： 显然，只有严格小于他的数才会对答案产生贡献。 再考虑在右边加入一个数，如图： 显然，只有严格大于他的数才会对答案产生贡献。 删除也是类似的贡献法考虑。 所以，我们用树状数组维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN],n;namespace BIT&#123; int c[MAXN]; #define lowbit(x) (x&amp;-x) inline void Update(int pos,int val)&#123; for (register int i=pos;i&lt;MAXN;i+=lowbit(i))&#123; c[i]+=val; &#125; &#125; inline int GetSmaller(int pos)&#123; pos--; int ans=0; for (register int i=pos;i&gt;0;i-=lowbit(i))&#123; ans+=c[i]; &#125; return ans; &#125; inline int GetBigger(int num)&#123; return GetSmaller(MAXN-1)-GetSmaller(num+1); &#125;&#125;using namespace BIT;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i)&#123; b[i]=a[i]; &#125; sort(b+1,b+1+n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b; &#125;&#125;int pos[MAXN];struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int Ans[MAXN];int main()&#123; n=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; discrete(); int m=read(); for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int l=1,r=0,ans=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l)&#123; Update(a[l],-1); ans-=GetSmaller(a[l++]); &#125; while (l&gt;q[i].l)&#123; Update(a[--l],1); ans+=GetSmaller(a[l]); &#125; while (r&lt;q[i].r)&#123; Update(a[++r],1); ans+=GetBigger(a[r]); &#125; while (r&gt;q[i].r)&#123; Update(a[r],-1); ans-=GetBigger(a[r--]); &#125; Ans[q[i].id]=ans; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"树状数组","slug":"树状数组","permalink":"https://gaisaiyuno.github.io/tags/树状数组/"}]},{"title":"暑假集训作业","slug":"暑假集训作业","date":"2019-08-05T09:42:42.000Z","updated":"2019-08-07T09:14:21.869Z","comments":true,"path":"archives/8ba20b51.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8ba20b51.html","excerpt":"","text":"按顺序做？不存在的。 8月5日.持久化线段树和持久化并查集 T1 T3 8月6日.莫队和树上莫队 T1 T3 T4 T5 8月7日.平衡树 T1 T3 T4 T5 8月8日.分块 T2 T3 T4 8月9日.2-sat T1 T2 T3","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"}]},{"title":"P4867 Gty的二逼妹子序列","slug":"P4867-Gty的二逼妹子序列","date":"2019-08-05T09:17:32.000Z","updated":"2019-08-05T09:39:32.006Z","comments":true,"path":"archives/dd54d29d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/dd54d29d.html","excerpt":"","text":"洛古 GDOI 首先，看见$“权值\\in [a,b]的权值的种类数。”$这样的话就要想到莫队。 我们有一个比较显然的树状数组做法，每次加进一个数，如果没有出现，那么加进树状数组，删除也是类似，最后前缀和相减统计一下即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],cnt[MAXN];namespace BIT&#123; int c[MAXN]; #define lowbit(x) (x&amp;-x) inline void upd(int pos,int val)&#123; for (register int i=pos;i&lt;MAXN;i+=lowbit(i))&#123; c[i]+=val; &#125; &#125; inline int qry(int pos)&#123; int ans=0; for (register int i=pos;i&gt;0;i-=lowbit(i))&#123; ans+=c[i]; &#125; return ans; &#125;&#125;using namespace BIT;int pos[MAXN];struct Query&#123; int l,r,a,b,id;&#125;q[MAXM];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int Ans[MAXM];int main()&#123; int n=read(),m=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].a=read(),q[i].b=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l)&#123; if (--cnt[a[l]]==0) upd(a[l],-1); ++l; &#125; while (l&gt;q[i].l)&#123; --l; if (++cnt[a[l]]==1) upd(a[l],1); &#125; while (r&lt;q[i].r)&#123; ++r; if (++cnt[a[r]]==1) upd(a[r],1); &#125; while (r&gt;q[i].r)&#123; if (--cnt[a[r]]==0) upd(a[r],-1); --r; &#125; Ans[q[i].id]=qry(q[i].b)-qry(q[i].a-1); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; 这样的做法在洛古上面能过，但是$\\rm GDOI$上面过不了，为什么呢？ 时间复杂度太高了，为$O(n \\sqrt n\\log n)$ 考虑我们莫队算法的特性。 1234567891011121314151617while (l&lt;q[i].l)&#123; if (--cnt[a[l]]==0) upd(a[l],-1); ++l;&#125;while (l&gt;q[i].l)&#123; --l; if (++cnt[a[l]]==1) upd(a[l],1);&#125;while (r&lt;q[i].r)&#123; ++r; if (++cnt[a[r]]==1) upd(a[r],1);&#125;while (r&gt;q[i].r)&#123; if (--cnt[a[r]]==0) upd(a[r],-1); --r;&#125;Ans[q[i].id]=qry(q[i].b)-qry(q[i].a-1); 直观感受一下，一个循环里面，修改操作改了这么多次，但是查询只有一次。 所以我们适当降低修改操作的时间复杂度，提高查询操作的时间复杂度，可能可以达到提高程序效率的功能。 所以，我们使用分块，修改复杂度$O(1)$，查询复杂度$O(\\sqrt n)$，就可以提高程序效率。 再仔细考虑一下，莫队整个算法也和分块密切相关，它的时间复杂度为$O(n \\sqrt n)$，说明一次循环里面，$l,r$指针移动的次数是$O(\\sqrt n)$级别，所以使用分块，前面修改复杂度为$O(1 \\times \\sqrt n)$，后面修改复杂度为$O(\\sqrt n \\times 1)$，合起来算一下，时间复杂度为$O(n \\sqrt n)$，少了一个$\\log $，是正确的。 总结：莫队和分块取长补短，可以达到降低时间复杂度的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],Size;static int pos[MAXN],cnt[MAXN],val[MAXN];//块内所有数之和namespace Divide_Into_Blocks&#123; inline int Calc(int l,int r)&#123; int ans=0; for (register int i=l;i&lt;=r;++i) ans+=cnt[i]&gt;0; return ans; &#125; inline int GetAns(int a,int b)&#123; int L=pos[a],R=pos[b]; if (L==R) return Calc(a,b); int ans=0; for (register int i=L+1;i&lt;=R-1;++i) ans+=val[i]; return ans+Calc(a,L*Size)+Calc((R-1)*Size+1,b); &#125;&#125;using namespace Divide_Into_Blocks;struct Query&#123; int l,r,a,b,id;&#125;q[MAXM];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;inline void Add(int x)&#123; if (++cnt[x]==1) ++val[pos[x]];&#125;inline void Del(int x)&#123; if (--cnt[x]==0) --val[pos[x]];&#125;int Ans[MAXM];int main()&#123; int n=read(),m=read(); Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i].l=read(),q[i].r=read(),q[i].a=read(),q[i].b=read(),q[i].id=i; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(a[l++]); while (l&gt;q[i].l) Add(a[--l]); while (r&lt;q[i].r) Add(a[++r]); while (r&gt;q[i].r) Del(a[r--]); Ans[q[i].id]=GetAns(q[i].a,q[i].b); &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"树状数组","slug":"树状数组","permalink":"https://gaisaiyuno.github.io/tags/树状数组/"},{"name":"分块","slug":"分块","permalink":"https://gaisaiyuno.github.io/tags/分块/"}]},{"title":"LOJ #2402. 「THUPC 2017」天天爱射击 / Shooting","slug":"LOJ-2402-「THUPC-2017」天天爱射击-Shooting","date":"2019-08-05T04:21:19.000Z","updated":"2019-08-05T10:20:14.535Z","comments":true,"path":"archives/50db0ada.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/50db0ada.html","excerpt":"","text":"传送门 一开始看到这道题，非常懵逼，不知道怎么做。 然后发现子弹是按照顺序发射的，于是转化一下题目条件，木板$[L_i,R_i]$会在接触到第$S_i$个子弹时破掉，于是就转换成求$[L_i,R_i]$第$S_i$大的子弹编号是多少。 这就是主席树模板嘛！ p.s.如果你懒（像我一样），不想把操作离线下来搞，就可以搞一下线段树合并，反正没几行。 注意： 要特判如果打到木板$i$上面的子弹不足$S_i$，这样显然木板不能被打碎，要continue掉。 注意$Update(rt[pos],1,MAXN,i);$这里的$MAXN$不能写成小的$maxn$，可能会出一些玄学问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;#define MAXN 300005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int cnt; &#125;tree[MAXN*200]; #define lc tree[i].l #define rc tree[i].r int tot; inline void pushup(int i,int x,int y)&#123; tree[i].cnt=tree[x].cnt+tree[y].cnt; &#125; void Update(int &amp;i,int l,int r,int pos)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].cnt++; return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,l,mid,pos); else Update(rc,mid+1,r,pos); pushup(i,lc,rc); &#125; int Query(int rt1,int rt2,int l,int r,int k)&#123; if (l==r) return l; int mid=(l+r)&gt;&gt;1,cnt=tree[tree[rt2].l].cnt-tree[tree[rt1].l].cnt; if (k&lt;=cnt) return Query(tree[rt1].l,tree[rt2].l,l,mid,k); else return Query(tree[rt1].r,tree[rt2].r,mid+1,r,k-cnt); &#125; void Merge(int &amp;x,int y)&#123; if (!x||!y)&#123; x=x+y; return ; &#125; pushup(x,x,y); Merge(tree[x].l,tree[y].l); Merge(tree[x].r,tree[y].r); &#125;&#125;using namespace SegmentTree;struct Board&#123; int l,r,s;&#125;b[MAXN];int Ans[MAXN];int main()&#123; int n=read(),m=read(); int maxn=0; for (register int i=1;i&lt;=n;++i)&#123; b[i].l=read(),b[i].r=read(),b[i].s=read(); maxn=max(maxn,b[i].l); maxn=max(maxn,b[i].r); &#125; for (register int i=1;i&lt;=m;++i)&#123; int pos=read(); maxn=max(maxn,pos); Update(rt[pos],1,MAXN,i); &#125; for (register int i=1;i&lt;=maxn;++i)&#123; Merge(rt[i],rt[i-1]); &#125; for (register int i=1;i&lt;=n;++i)&#123; int l=b[i].l,r=b[i].r,s=b[i].s; if (tree[rt[r]].cnt-tree[rt[l-1]].cnt&lt;s) &#123;//特判这种情况 continue; &#125; else &#123; Ans[Query(rt[l-1],rt[r],1,MAXN,s)]++; &#125; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"}]},{"title":"U81395 换根の树","slug":"U81395-换根の树","date":"2019-08-04T15:02:52.000Z","updated":"2019-09-01T04:54:55.218Z","comments":true,"path":"archives/4b58a367.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4b58a367.html","excerpt":"","text":"首先，乖♂乖♂交♂出数据生成器： 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;inline int gen()&#123; return (rand()&lt;&lt;15)|(rand());&#125;int main()&#123; srand(time(NULL)); int n=1000,m=1000; printf(\"%d %d\\n\",n,m); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",gen()%10+1); &#125; printf(\"\\n\"); for (register int i=2;i&lt;=n;++i)&#123; printf(\"%d %d\\n\",i,gen()%(i-1)+1); &#125; printf(\"\\n\"); for (register int i=1;i&lt;=m;++i)&#123; int opr=(rand()%10==0)?1:2; printf(\"%d %d\\n\",opr,gen()%n+1); &#125;&#125; 使用printf(“%d “,gen()%10+1);是因为如果$val[i]$的范围太大，数据基本上全是$0$。 所以这题的数据范围是假的，当然最后一个点是真·数据范围。 为什么int opr=(rand()%10==0)?1:2;呢？，是因为换♂根太多也不好啊。 $30pts$真·大暴力，每次求出颜色总数，根据组合数算一下就可以了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;int col[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int nowu;int val[MAXN];void dfs(int u,int father,bool in)&#123; if (u==nowu) in=true; if (in) col[val[u]]++; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dfs(v,u,in); &#125; &#125;&#125;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i) val[i]=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; int rt=1; for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1) rt=read(); else &#123; nowu=read(); memset(col,0,sizeof(col)); dfs(rt,rt,0); int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (col[i]&gt;1) ans+=col[i]*(col[i]-1)/2; &#125; printf(\"%d\\n\",ans); &#125; &#125;&#125; 100pts考虑莫队，首先，参考这篇题解，你就会发现这个换根是假的。 前两种情况，就是查询$[1,n]$和$[L[u],R[u]]$直接放进一个莫队里面搞就可以了，但是别忘了还要查询$[1,L[v]-1]$，$[R[v]+1,n]$，如果$i$，$j$都在$[1,L[v]-1]$，或者都在$[R[v]+1,n]$还是可以套用上面的方法，如果$i$在$[1,L[v]-1]$，$j$在$[R[v]+1,n]$的话，怎么搞呢？ 我想了一个笨办法，再开一个莫队就可以了，询问$i \\in[1,l],j \\in [r,n]$之间数对的个数，最后加起来就可以了。 123456789101112if (u==rt)&#123; AddQuery1(1,n,qu);&#125;else if (LCA(u,rt)==u)&#123; int v=Hop(rt,u); if (L[v]&gt;1) AddQuery1(1,L[v]-1,qu); if (R[v]&lt;n) AddQuery1(R[v]+1,n,qu); AddQuery2(L[v]-1,R[v]+1,qu);&#125;else &#123; AddQuery1(L[u],R[u],qu);&#125; 献上写得很丑的标算，注意要开$\\text{long long}$，我应该刻意卡了$\\text {int}$： 时间复杂度$O(n \\sqrt n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MAXM 19#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int L[MAXN],R[MAXN],dfn,seq[MAXN];int anc[MAXN][MAXM],dep[MAXN];int val[MAXN],n,m;void dfs(int u,int father)&#123; seq[L[u]=++dfn]=val[u]; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i) anc[u][i]=anc[anc[u][i-1]][i-1]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs(v,u); &#125; &#125; R[u]=dfn;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i]) u=anc[u][i],v=anc[v][i]; &#125; return anc[u][0];&#125;inline int Hop(int u,int v)&#123;//h♂p to v's son for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;dep[v])&#123; u=anc[u][i]; &#125; &#125; return u;&#125;int pos[MAXN],rt;struct Query1&#123; int l,r;//表示询问[l,r]内相同的数对个数 int id;&#125;q1[MAXN];inline bool operator &lt; (const Query1 &amp;a,const Query1 &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;struct Query2&#123; int l,r;//表示询问[1,l][r,n]之间相同数对的个数 int id;&#125;q2[MAXN];inline bool operator &lt; (const Query2 &amp;a,const Query2 &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int c1,c2;inline void AddQuery1(int l,int r,int id)&#123;q1[++c1]=Query1&#123;l,r,id&#125;;&#125;inline void AddQuery2(int l,int r,int id)&#123;q2[++c2]=Query2&#123;l,r,id&#125;;&#125;int cnt[MAXN];int cnt1[MAXN],cnt2[MAXN];long long Ans[MAXN],ans;inline void Add(int x)&#123; ++cnt[x],ans+=(cnt[x]-1);//除去自己&#125;inline void Del(int x)&#123; ans-=(cnt[x]-1),--cnt[x];&#125;#undef intint main()&#123;#define int long long n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; val[i]=read(); &#125; int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; dfs(1,1); rt=1; int qu=0; for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1)&#123; rt=read(); &#125; else &#123; qu++; int u=read(); if (u==rt)&#123; AddQuery1(1,n,qu); &#125; else if (LCA(u,rt)==u)&#123; int v=Hop(rt,u); if (L[v]&gt;1) AddQuery1(1,L[v]-1,qu); if (R[v]&lt;n) AddQuery1(R[v]+1,n,qu); AddQuery2(L[v]-1,R[v]+1,qu); &#125; else &#123; AddQuery1(L[u],R[u],qu); &#125; &#125; &#125; //to compelete Query1 sort(q1+1,q1+1+c1); int l=1,r=0; ans=0; for (register int i=1;i&lt;=c1;++i)&#123; while (l&lt;q1[i].l) Del(seq[l++]); while (l&gt;q1[i].l) Add(seq[--l]); while (r&lt;q1[i].r) Add(seq[++r]); while (r&gt;q1[i].r) Del(seq[r--]); Ans[q1[i].id]+=ans; &#125; //to compelete Query2 sort(q2+1,q2+1+c2); l=0,r=n+1; ans=0; for (register int i=1;i&lt;=c2;++i)&#123; while (l&lt;q2[i].l)&#123; ++cnt1[seq[++l]]; ans+=cnt2[seq[l]]; &#125; while (l&gt;q2[i].l)&#123; --cnt1[seq[l]]; ans-=cnt2[seq[l--]]; &#125; while (r&lt;q2[i].r)&#123; --cnt2[seq[r]]; ans-=cnt1[seq[r++]]; &#125; while (r&gt;q2[i].r)&#123; ++cnt2[seq[--r]]; ans+=cnt1[seq[r]]; &#125; Ans[q2[i].id]+=ans; &#125; for (register int i=1;i&lt;=qu;++i)&#123; printf(\"%lld\\n\",Ans[i]); &#125;&#125; 这道题$O(n \\log n)$预处理$O(1)$查询的方法应该也有，但是我太菜了，不想写。 你们写出来就可以爆碾标算了。 最后一个点出锅了，正在修复","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"}]},{"title":"BZOJ3262 陌上花开","slug":"BZOJ3262-陌上花开","date":"2019-08-04T09:38:44.000Z","updated":"2019-08-04T12:49:20.741Z","comments":true,"path":"archives/15401cdd.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/15401cdd.html","excerpt":"","text":"首先，以$a$为第一关键字排序，$b$为第二关键字排序，$c$为第三关键字排序，这样从左到右扫过去，发现$a_i$一定是递增的，所以只要考虑后面两维即可。 不妨考虑画一个图： 发现只有在蓝色框框里面的才是合法的解（如$(b_j,c_j)$，$(b_k,c_k)$） 。 Sol1我们用树套树（线段树套动态开点线段树，又称二维线段树）来维护这个二维前缀和。 第二维用动态开点是因为防爆空间。 但是发现线段树常数太大，会超时，我们可以把第一维的线段树改成树状数组。 注意：数组开大一点。 实现的细节：考虑到可能有多个相同的花，我们统计当前相同的花的个数，等到一个不同的花加入时一起统计，相同的花只能一起统计，如果分开统计，会导致他们的$f$值不一样。 时间复杂度为$O(n \\log^2 n)$代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int rt[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val; &#125;tree[MAXN*150]; int tot; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; void Update(int &amp;i,int pos,int val,int l,int r)&#123; if (!i) i=++tot; if (l==r)&#123; tree[i].val+=val; return ; &#125; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val,l,mid); else Update(rc,pos,val,mid+1,r); pushup(i); &#125; int Query(int i,int L,int R,int l,int r)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].val; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans+=Query(lc,L,R,l,mid); if (mid&lt;R) ans+=Query(rc,L,R,mid+1,r); return ans; &#125;&#125;using namespace SegmentTree;struct Flower&#123; int a,b,c;&#125;f[MAXN];inline bool operator &lt; (const Flower &amp;A,const Flower &amp;B)&#123; if (A.a!=B.a) return A.a&lt;B.a; else if (A.b!=B.b) return A.b&lt;B.b; return A.c&lt;B.c;&#125;#define lowbit(x) x&amp;(-x)int k;inline void upd(int x,int y,int val)&#123; for (register int i=x;i&lt;=k;i+=lowbit(i))&#123; Update(rt[i],y,val,1,k); &#125;&#125;inline int qry(int x,int y)&#123; int ans=0; for (register int i=x;i&gt;0;i-=lowbit(i))&#123; ans+=Query(rt[i],1,y,1,k); &#125; return ans;&#125;int Ans[MAXN];int main()&#123; int n=read();k=read(); for (register int i=1;i&lt;=n;++i)&#123; f[i].a=read(),f[i].b=read(),f[i].c=read(); &#125; sort(f+1,f+1+n); int same=1;//副本 for (register int i=1;i&lt;=n;++i)&#123; if (f[i+1].a==f[i].a&amp;&amp;f[i+1].b==f[i].b&amp;&amp;f[i+1].c==f[i].c)&#123;//注意相同的时候会出锅，所以要统计副本个数 same++; &#125; else &#123;//来了一个不同的，大力统计 upd(f[i].b,f[i].c,same); Ans[qry(f[i].b,f[i].c)]+=same; same=1;//重置副本为1 &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; Sol2刚才我们用的是动态开点线段树，发现动态开点便于理解，但是大材小用了。 观察下面两句： 12Update(rt[i],y,val,1,k);ans+=Query(rt[i],1,y,1,k); 实现的是什么功能呢？插入一个数，询问比小于等于这个数的数的总数。 这不就是平衡树吗？ 在刚才的代码的基础上魔改，得到以下： （相同的数暴♂力插♂入，我实在是太懒了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int rt[MAXN*150];namespace FHQTreap&#123; struct node&#123; int l,r; int val,pri,sz; &#125;tree[MAXN*150]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(const int &amp;x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; return tot; &#125; #define Rson rc(x),y #define Lson x,lc(y) int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(Rson),Update(x); return x; &#125; else &#123; lc(y)=Merge(Lson),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k) x=i,Split(rc(i),k,Rson); else y=i,Split(lc(i),k,Lson); Update(i); &#125; &#125; inline void Insert(int &amp;rt,int val,int num)&#123; for (register int i=1;i&lt;=num;++i)&#123;//懒。。。 int x=0,y=0; Split(rt,val,x,y); rt=Merge(Merge(x,New(val)),y); &#125; &#125; inline int GetRank(int rt,int val)&#123; int x=0,y=0; Split(rt,val,x,y); int ans=tree[x].sz; rt=Merge(x,y); return ans; &#125;&#125;using namespace FHQTreap;struct Flower&#123; int a,b,c;&#125;f[MAXN];inline bool operator &lt; (const Flower &amp;A,const Flower &amp;B)&#123; if (A.a!=B.a) return A.a&lt;B.a; else if (A.b!=B.b) return A.b&lt;B.b; return A.c&lt;B.c;&#125;#define lowbit(x) x&amp;(-x)int k;inline void upd(int x,int y,int val)&#123; for (register int i=x;i&lt;=k;i+=lowbit(i))&#123; Insert(rt[i],y,val); &#125;&#125;inline int qry(int x,int y)&#123; int ans=0; for (register int i=x;i&gt;0;i-=lowbit(i))&#123; ans+=GetRank(rt[i],y); &#125; return ans;&#125;int Ans[MAXN];int main()&#123; int n=read();k=read(); for (register int i=1;i&lt;=n;++i)&#123; f[i].a=read(),f[i].b=read(),f[i].c=read(); &#125; sort(f+1,f+1+n); int same=1;//副本 for (register int i=1;i&lt;=n;++i)&#123; if (f[i+1].a==f[i].a&amp;&amp;f[i+1].b==f[i].b&amp;&amp;f[i+1].c==f[i].c)&#123;//注意相同的时候会出锅，所以要统计副本个数 same++; &#125; else &#123;//来了一个不同的，大力统计 upd(f[i].b,f[i].c,same); Ans[qry(f[i].b,f[i].c)]+=same; same=1;//重置副本为1 &#125; &#125; for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125; 结果，时间竟然变成3s。 所以，还是建议敲动态开点线段树吧，不仅好写好想，而且常数小。 Sol3cdq分治，暂时咕咕","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"权值线段树","slug":"权值线段树","permalink":"https://gaisaiyuno.github.io/tags/权值线段树/"},{"name":"树状数组","slug":"树状数组","permalink":"https://gaisaiyuno.github.io/tags/树状数组/"}]},{"title":"P2221 [HAOI2012]高速公路","slug":"P2221-HAOI2012-高速公路","date":"2019-08-04T07:57:17.000Z","updated":"2019-08-04T08:58:32.191Z","comments":true,"path":"archives/bba5bde4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/bba5bde4.html","excerpt":"","text":"传送门 首先，看到区间修改，区间查询就要想到线段树。 把链上面的操作转化到点上面的的操作，我们像这样编号，点编号为$1…n$，边编号为$1…n-1$ 于是修改和查询都对应到了边$[l,r-1]$ 考虑如何算期望值，下面的分母很简单，就是$C_{r-l+1}^2$，从$r-l+1$个点中选出$2$个。 上面的分子是$\\sum _{i=l}^r \\sum _{j=l}^r dis(i,j)$，比较难算。 不妨从每条边的贡献的角度考虑： 假设现在查询的区间是$[2,7]$，现在算的是编号为$4$的边的贡献，考虑哪些路径会包含这条边。 发现只有左端点是红色箭头，右端点是蓝色箭头的路径会包含这条边。 所以，得出公式$\\sum _{i=l}^r a[i] \\times (i-l+1) \\times (r-i+1)$ 开始大力拆式子，拆成： $\\sum_{i=l}^r a[i] \\times (-i^2 + i (l+r) +r-l+1-lr)$ 发现这个式子并不复杂，仔细观察，只有$i$是变量，所以很多东西都可以提出来，变成： $-\\sum_{i=l}^r a[i] \\times i^2 + (l+r) \\sum_{i=l}^r a[i] \\times i + (r-l+1-lr) \\sum _{i=l}^r a[i]$ 所以我们在线段树上面维护以下的东西： $\\sum a[i] \\times i^2$ $\\sum a[i] \\times i$ $\\sum a[i]$ 而考虑修改，发现$\\sum (a[i]+\\Delta) \\times i^2 - \\sum a[i] \\times i^2 = \\sum \\Delta \\times i^2=\\Delta \\sum i^2$ 所以我们通过公式算出$\\sum i^2$就可以了。 剩下两种也比较简单。 总结：贡献法是$\\rm OI$中经常使用的一种方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline int F1(int x)&#123; return x*(x+1)/2;&#125;inline int F(int l,int r)&#123; return F1(r)-F1(l-1);&#125;inline int G1(int x)&#123; return x*(x+1ll)/2ll*(2ll*x+1ll)/3ll;&#125;inline int G(int l,int r)&#123; return G1(r)-G1(l-1);&#125;int sum1,sum2,sum3;namespace SegmentTree&#123; #define ARG tree[i].l,tree[i].r struct node&#123; int l,r; int val1,val2,val3; int tag; //val1 a[i]*i^2 //val2 a[i]*i //val3 a[i] inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Change(int i,int val)&#123; tree[i].val1+=val*G(ARG); tree[i].val2+=val*F(ARG); tree[i].val3+=val*tree[i].len(); tree[i].tag+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; inline void pushup(int i)&#123; tree[i].val1=tree[lc].val1+tree[rc].val1; tree[i].val2=tree[lc].val2+tree[rc].val2; tree[i].val3=tree[lc].val3+tree[rc].val3; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; void Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; sum1+=tree[i].val1,sum2+=tree[i].val2,sum3+=tree[i].val3; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Query(lc,L,R); if (mid&lt;R) Query(rc,L,R); &#125;&#125;using namespace SegmentTree;int gcd(int a,int b)&#123; return a%b==0?b:gcd(b,a%b);&#125;#undef intint main()&#123;#define int long long int n=read(),m=read(); Build(1,1,n); char ch[2]; while (m--)&#123; scanf(\"%s\",ch); int l=read(),r=read()-1; if (ch[0]=='C')&#123; int val=read(); Update(1,l,r,val); &#125; else&#123; sum1=sum2=sum3=0; Query(1,l,r); int a=-sum1+(l+r)*sum2+(r-l+1-l*r)*sum3; int b=F1(r-l+1); int g=gcd(a,b); printf(\"%lld/%lld\\n\",a/g,b/g); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"期望","slug":"期望","permalink":"https://gaisaiyuno.github.io/tags/期望/"}]},{"title":"U77201 ZYD的排列 组合数","slug":"U77201 ZYD的排列","date":"2019-08-04T06:54:19.634Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/zydakioi.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/zydakioi.html","excerpt":"","text":"题目传送门 $10pt$输出$0$，出题人还是很良心的 $30pt$最简单的暴搜 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MOD 1000000007using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;//还有$BB$，$GG$，$BG$，$GB$的总数，分别为$a$，$b$，$c$，$d$int ans,n;int num[MAXN];void dfs(int i,int a,int b,int c,int d)&#123; if (a&lt;0||b&lt;0||c&lt;0||d&lt;0) return ; if (i==n+1&amp;&amp;a==0&amp;&amp;b==0&amp;&amp;c==0&amp;&amp;d==0) &#123; ans=(ans+1)%MOD; return ; &#125; if (num[i-1]==0)&#123; num[i]=0; dfs(i+1,a-1,b,c,d); num[i]=1; dfs(i+1,a,b,c-1,d); &#125; else &#123; num[i]=0; dfs(i+1,a,b,c,d-1); num[i]=1; dfs(i+1,a,b-1,c,d); &#125;&#125;int main()&#123; n=read(); int a=read(),b=read(),c=read(),d=read(); num[1]=0; dfs(2,a,b,c,d); num[1]=1; dfs(2,a,b,c,d); printf(\"%d\\n\",ans);&#125; $100pt$我们考虑$a,b,c,d$对$B$，$G$的贡献，发现贡献$sumb=2a+c+d$，$sumg=2b+c+d$其中中间部分的贡献算了两次，头和尾的贡献只算了一次，如果知道首尾的字母，就能知道整个序列中$B,G$的个数。 我们再把序列抽象成一段一段的$B$，$G$如$…..GB…..BG……GB……BG…..$我们发现$BG$，$GB$只出现在交界处。所以我们发现一个很简单的性质：$abs(c-d)&lt;=2$。再yy一下发现若$c==d$，那么序列首尾都为$G$或者都为$B$，若$c==d+1$，那么序列首部为$B$，尾部为$G$，若$c+1==d$，那么序列首部为$G$，尾部为$B$，根据这个性质，我们就可以求出$B,G$的数量，若总数$&gt;n$，则排列数为$0$ 剩下的部分组合数爆推一波就可以了：我们发现知道了头尾的字母，就知道了$B$区间和$G$区间的段数和位置。考虑插板法，将$A$个字母分成$s1$段，每段不为$0$，总方法数：$C^{s1-1}_{A-1}$把插入$B$的方法数和插入$G$的方法数相乘即可。 代码细节比较多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define MAXN 2000005#define MOD 1000000007#define int long longusing namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;inline int Abs(int a)&#123; return a&gt;0?a:-a;&#125;int fac[MAXN],inv[MAXN];inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(ans*b)%MOD; b=(b*b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;inline void Init()&#123; fac[0]=1; for (register int i=1;i&lt;MAXN;++i)&#123; fac[i]=(fac[i-1]*i)%MOD; &#125;&#125;inline int C(int n,int m)&#123; if (n==0) return 1; if (n==-1&amp;&amp;m==-1) return 1; return fac[m]*ksm(fac[n],MOD-2)%MOD*ksm(fac[m-n],MOD-2)%MOD;&#125;int n;inline int Solve(int A,int B,int s1,int s2)&#123;//s1段A个数 s2段B个数 if (A+B!=n) return 0; return C(s1-1,A-1)*C(s2-1,B-1)%MOD;&#125;//还有BB，GG，BG，GB的总数，分别为a，b，c，d#undef intint main()&#123;#define int long long Init(); n=read();int a=read(),b=read(),c=read(),d=read(); if (Abs(c-d)&gt;=2)&#123; puts(\"0\"); return 0; &#125; int sumb=a*2+c+d; int sumg=b*2+c+d; int ans=0; //算出汉子妹子总数（相邻的算重复） if (c==d)&#123;//两种情况：头尾为BB，或者GG if (sumb&amp;1||sumg&amp;1) &#123; puts(\"0\"); return 0; &#125; else &#123; ans+=Solve((sumb+2)/2,sumg/2,c+1,c); ans+=Solve(sumb/2,(sumg+2)/2,c,c+1); &#125; &#125; else&#123;//头尾一定为BG或GB if ((!(sumb&amp;1))||(!(sumg&amp;1)))&#123; puts(\"0\"); return 0; &#125; else &#123; ans+=Solve((sumb-1)/2+1,(sumg-1)/2+1,max(c,d),max(c,d));//两种情况合起来写 &#125; &#125; printf(\"%lld\\n\",ans);&#125; p.s.可以在介里下载数据点击下载","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"组合数","slug":"组合数","permalink":"https://gaisaiyuno.github.io/tags/组合数/"}]},{"title":"P3391 【模板】文艺平衡树（Splay）","slug":"P3391 【模板】文艺平衡树（Splay）","date":"2019-08-04T06:54:19.562Z","updated":"2019-09-01T03:12:49.175Z","comments":true,"path":"archives/174583e7.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/174583e7.html","excerpt":"","text":"平衡树模板题 Splay写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int fa[MAXN],ch[MAXN][2],size[MAXN],tag[MAXN];#define lc(i) ch[i][0]#define rc(i) ch[i][1]inline void pushup(int i)&#123; size[i]=size[lc(i)]+size[rc(i)]+1;&#125;inline void pushdown(int i)&#123; if (tag[i])&#123; tag[i]^=1; tag[lc(i)]^=1,tag[rc(i)]^=1; swap(lc(i),rc(i)); &#125;&#125;inline void rotate(int x,int &amp;k)&#123; int y=fa[x],z=fa[y]; bool p=(lc(y)==x); if (y==k) k=x; else &#123; if (lc(z)==y) lc(z)=x; else rc(z)=x; &#125; ch[y][!p]=ch[x][p]; fa[ch[y][!p]]=y,ch[x][p]=y; fa[y]=x,fa[x]=z; pushup(x),pushup(y);&#125;inline void splay(int x,int &amp;k)&#123; while (x!=k)&#123; int y=fa[x],z=fa[y]; if (y!=k)&#123; if ((lc(y)==x)^(lc(z)==y)) rotate(x,k); else rotate(y,k); &#125; rotate(x,k); &#125;&#125;void build(int l,int r,int f)&#123; if (l&gt;r) return ; int mid=(l+r)&gt;&gt;1; if (mid&lt;f) lc(f)=mid; else rc(f)=mid; fa[mid]=f;size[mid]=1; if (l==r) return ; build(l,mid-1,mid),build(mid+1,r,mid); pushup(mid);&#125;int Find(int x,int k)&#123; pushdown(x); if (k==size[lc(x)]+1) return x; else if (k&lt;=size[lc(x)]) return Find(lc(x),k); else return Find(rc(x),k-size[lc(x)]-1);&#125;int root;void Update(int l,int r)&#123; int x=Find(root,l),y=Find(root,r+2); splay(x,root),splay(y,rc(x)); tag[lc(y)]^=1;&#125;int main()&#123; int n=read(),m=read(); root=(n+3)/2,build(1,n+2,root); for (register int i=1;i&lt;=m;++i)&#123; int l=read(),r=read(); Update(l,r); &#125; for (register int i=2;i&lt;=n+1;++i)&#123; printf(\"%d \",Find(root,i)-1); &#125;&#125; FHQ Treap写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQTreap&#123; struct node&#123; int l,r; int pri,val,sz; bool tag; &#125;tree[MAXN]; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void pushup(int i)&#123; tree[i].sz=tree[lc(i)].sz+tree[rc(i)].sz+1; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; swap(lc(i),rc(i)); tree[lc(i)].tag^=1; tree[rc(i)].tag^=1; tree[i].tag=false; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; pushdown(i); if (i==0) return x=y=0,void(); if (tree[lc(i)].sz&gt;=k)&#123; y=i; Split(lc(i),k,x,lc(y)); pushup(y); &#125; else &#123; x=i; Split(rc(i),k-tree[lc(i)].sz-1,rc(x),y); pushup(x); &#125; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; pushdown(x),pushdown(y); if (tree[x].pri&gt;tree[y].pri)&#123; lc(y)=Merge(x,lc(y)); pushup(y); return y; &#125; else &#123; rc(x)=Merge(rc(x),y); pushup(x); return x; &#125; &#125; int root,tot; inline void Reverse(int l,int r)&#123; int x,y,z; Split(root,l-1,x,y); Split(y,r-l+1,y,z); tree[y].tag^=1; root=Merge(x,Merge(y,z)); &#125; void Print(int i)&#123; if (!i) return ; pushdown(i); Print(lc(i)); printf(\"%d \",tree[i].val); Print(rc(i)); &#125; int New(int val)&#123; tree[++tot].sz=1; tree[tot].pri=rand(); tree[tot].val=val; tree[tot].l=tree[tot].r=tree[tot].tag=0; return tot; &#125;&#125;using namespace FHQTreap;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i) root=Merge(root,New(i)); for (register int i=1;i&lt;=m;++i)&#123; int l=read(),r=read(); Reverse(l,r); &#125; Print(root);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"模板","slug":"模板","permalink":"https://gaisaiyuno.github.io/tags/模板/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"Splay","slug":"Splay","permalink":"https://gaisaiyuno.github.io/tags/Splay/"}]},{"title":"P3380 【模板】二逼平衡树（树套树）","slug":"P3380","date":"2019-08-04T06:54:19.560Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/48c38374.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/48c38374.html","excerpt":"","text":"传送门树套树模板题（线段树套$\\rm FHQ Treap$）一开始听说$\\rm FHQ Treap$常数大，会$\\rm TLE$，就没敢写，最后发现$\\rm FHQ Treap$还是能过的。 好了步入正题：考虑在线段树的每个节点开一棵$\\rm FHQ Treap$，维护的是线段树左右端点$[l,r]$所代表的区间$a_l…a_r$这样不会$\\rm MLE$，因为线段树最多有$\\log n$层，而每一层就算填满也只有$O(n)$的空间，所以总空间复杂度是$O(n \\log n)$，注意数组要开这么大 $1.$建树：对于节点$[l,r]$，暴力插入$a[l]…a[r]$，时间复杂度$O(n\\log^2n)$。$2.$替换$a[pos]$为$k$：对于包含$pos$的区间$[l,r]$，先删除$a[pos]$，再加入$k$，时间复杂度$O(\\log^2n)$。$3.$查询区间中$num$的排名：我们发现：$num$的排名为区间中小于$num$的数的数量$+1$，又发现线段树的区间查询操作其实将查询区间$[L,R]$分成许多不相交的小区间，根据这个，我们把$num$在小区间的排名$-1$，得到在小区间中小于$num$的数的数量，最后相加，发现小于$num$的数的数量不会重复计算，于是把和$+1$，得到$num$在区间$[L,R]$的排名，时间复杂度$O(\\log^2n)$这里很容易跳进的坑：不能把$num$在小区间中的排名相加，否则$num$会重复算很多次$4.$查询区间第$k$大的数：因为$\\rm FHQ Treap$只能查询$num$的排名，所以考虑二分$num$，时间复杂度$O(\\log^3n)$，查询$num$排名$O(\\log^2n)$，二分$O(\\log n)$。（当然按照子树大小$\\rm Split$，$\\rm FHQTreap$也阔以支持查询第$k$大，详情请戳这里）$5.$查询区间中，$num$的前驱：直接把小区间中$num$的所有前驱取个$max$。$6.$查询区间中，$num$的后继：类似$5.$ 注意要判断$num$的前驱后继是否存在，若不存在，相应地输出$\\rm INF/-INF$。还有修改操作做完后，要执行$a[pos]=k$，修改$a$数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;#define MAXN 50005#define MAXM 10000005#define INF 0x7fffffffusing namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz;&#125;tree[MAXM];int tot;struct FHQ_Treap&#123; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(int x)&#123;tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1;&#125; inline int New(int v)&#123; tree[++tot].val=v,tree[tot].pri=rand(),tree[tot].sz=1; return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else&#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i) x=y=0; else &#123; if (tree[i].val&lt;=k)&#123;x=i,Split(rc(i),k,rc(i),y);&#125; else&#123;y=i,Split(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; int root,x,y,z; inline void Add(int num)&#123; Split(root,num,x,y); root=Merge(x,Merge(New(num),y)); &#125; inline void Del(int num)&#123; Split(root,num,x,z); Split(x,num-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125; inline int Rank(int num)&#123;//获得num排名 Split(root,num-1,x,y); int temp=tree[x].sz+1; root=Merge(x,y); return temp; &#125; inline int Kth(int i,int rk)&#123; if (rk&lt;=tree[lc(i)].sz) return Kth(lc(i),rk); if (rk==tree[lc(i)].sz+1) return tree[i].val; return Kth(rc(i),rk-tree[lc(i)].sz-1); &#125; inline int Pre(int num)&#123; Split(root,num-1,x,y); int ans=tree[x].sz?Kth(x,tree[x].sz):-INF; root=Merge(x,y); return ans; &#125; inline int Nex(int num)&#123; Split(root,num,x,y); int ans=tree[y].sz?Kth(y,1):INF; root=Merge(x,y); return ans; &#125; inline void BuildTree(int l,int r)&#123; for (register int i=l;i&lt;=r;++i)&#123;Add(a[i]);&#125; &#125; #undef lc #undef rc&#125;T[MAXN&lt;&lt;2];int n;namespace SegmentTree&#123; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 void Build(int i,int l,int r)&#123; T[i].BuildTree(l,r); if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; int qrank(int i,int l,int r,int L,int R,int val)&#123; if (L&lt;=l&amp;&amp;r&lt;=R) &#123; return T[i].Rank(val)-1; &#125; int mid=(l+r)&gt;&gt;1; int ans=0; if (L&lt;=mid) ans+=qrank(lc,l,mid,L,R,val); if (mid&lt;R) ans+=qrank(rc,mid+1,r,L,R,val); return ans; &#125; inline int qval(int l,int r,int rk)&#123; int L=0,R=0x7fffffff; int ans=-1; while (L&lt;=R)&#123; int mid=(L+R)&gt;&gt;1; if (qrank(1,1,n,l,r,mid)&lt;rk) ans=mid,L=mid+1; else R=mid-1; &#125; return ans; &#125; void Update(int l,int r,int i,int k,int pos)&#123;//a[pos]=&gt;k T[i].Del(a[pos]),T[i].Add(k); if (l==r) return ; int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) Update(l,mid,lc,k,pos); else Update(mid+1,r,rc,k,pos); &#125; int qpre(int i,int l,int r,int L,int R,int val)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return T[i].Pre(val); &#125; int mid=(l+r)&gt;&gt;1; int ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,qpre(lc,l,mid,L,R,val)); if (mid&lt;R) ans=max(ans,qpre(rc,mid+1,r,L,R,val)); return ans; &#125; int qnex(int i,int l,int r,int L,int R,int val)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return T[i].Nex(val); &#125; int mid=(l+r)&gt;&gt;1; int ans=0x7fffffff; if (L&lt;=mid) ans=min(ans,qnex(lc,l,mid,L,R,val)); if (mid&lt;R) ans=min(ans,qnex(rc,mid+1,r,L,R,val)); return ans; &#125; #undef lc #undef rc&#125;using namespace SegmentTree;int main()&#123; n=read();int m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,1,n); while (m--)&#123; int opr=read(); if (opr==1)&#123; int l=read(),r=read(),k=read(); printf(\"%d\\n\",qrank(1,1,n,l,r,k)+1); &#125; else if (opr==2)&#123; int l=read(),r=read(),k=read(); printf(\"%d\\n\",qval(l,r,k)); &#125; else if (opr==3)&#123; int pos=read(),k=read(); Update(1,n,1,k,pos),a[pos]=k; &#125; else if (opr==4)&#123; int l=read(),r=read(),k=read(); printf(\"%d\\n\",qpre(1,1,n,l,r,k)); &#125; else if (opr==5)&#123; int l=read(),r=read(),k=read(); printf(\"%d\\n\",qnex(1,1,n,l,r,k)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"模板","slug":"模板","permalink":"https://gaisaiyuno.github.io/tags/模板/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"CF723E One-Way Reform 欧拉序","slug":"CF732E","date":"2019-08-04T06:54:19.479Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/d1881f97.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d1881f97.html","excerpt":"","text":"传送门 答案上界为该无向图中的偶点数量，考虑构造方案达到这个上界建一个虚点S向所有奇点连边，这样奇点都变成了偶点，而奇点的个数一定是偶数，故S也是个偶点于是新图存在欧拉回路，根据这个对边进行定向，则原图中所有偶点入度等于出度，达到上界 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAXN 205using namespace std;int G[MAXN][MAXN];inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int deg[MAXN];inline void AddEdge(int u,int v)&#123; G[u][v]=G[v][u]=1; deg[u]++,deg[v]++;&#125;inline void DelEdge(int u,int v)&#123; G[u][v]=G[v][u]=0; deg[u]--,deg[v]--;&#125;int n,m;void dfs(int u)&#123; for (register int i=1;i&lt;=n+1;++i)&#123; if (G[u][i])&#123; if (i!=n+1&amp;&amp;u!=n+1)&#123; printf(\"%d %d\\n\",u,i); &#125; DelEdge(i,u); dfs(i); &#125; &#125;&#125;int main()&#123; int t=read(); while (t--)&#123; n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); AddEdge(u,v); &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (deg[i]&amp;1)&#123;//奇点 AddEdge(i,n+1); &#125; else &#123; ans++; &#125; &#125; printf(\"%d\\n\",ans); for (register int i=1;i&lt;=n;++i) dfs(i);;; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"欧拉序","slug":"欧拉序","permalink":"https://gaisaiyuno.github.io/tags/欧拉序/"}]},{"title":"2-SAT学习笔记","slug":"2-SAT学习笔记","date":"2019-08-04T02:22:21.000Z","updated":"2019-08-04T03:32:40.552Z","comments":true,"path":"archives/c7c48d7b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c7c48d7b.html","excerpt":"","text":"对于$x_1 … x_n$，考虑如下的$m$条限制： $x_i$为true/false或者$x_j$为true/false 我们举个例子，如果要求的是$x_i$为true或者$x_j$为false 那么如果$x_i$为false，$x_j$就必须为true 反之，如果$x_j$为true，$x_i$就必须为true 这样，我们巧妙地将或问题转换成与问题 插句题外话，其实或运算可以转换成与运算，即$x \\text{ and } y = \\text{not }((\\text{not }x) \\text{ or } (\\text{not y}))$， 这个性质在红石里面很有用 好了，发现怎么转换以后，我们考虑将问题抽象化，不妨建一个有向图。 事实上，我们建的是两倍节点的图，前面的$n$个点代表$x_i==true$，后面$n$个点代表$x_i==false$ $$表示$u$的值为真的话，$v$的值就必须为真。 注意到我们建立的是有向图，所以刚才的边并不代表$v$的值为真，能推出$u$的值为真。 我们考虑如何判断矛盾，我们在求出这个图的强连通分量，同一强连通分量中的值一定相等，如果$x_i==true$代表的节点和$x_i==false$的节点在同一强连通分量，那么不合法。 如果没有这种矛盾，是可以证明一定有一个合法的解的。（然鹅我不会证） 考虑把所有强连通分量缩成一个点，变成一个拓扑图（当然在代码里面不用写）。 注意这里每个点代表的是原图的一个强连通分量。 假设我们现在选了一个拓扑序比较靠前的节点$u$，钦定它的值为true​（标成红色） 那么拓扑序大于它的节点都必须为true。 这样标成true的节点太多了，可能造成很多矛盾，不符合基本法。 考虑一个更优的方法： 我们选一个拓扑序靠后的节点$v$，钦定它的值为true，这样只要把较少点标成true。 不知道高到哪里去了。 所以，根据贪心的原则我们优先选择拓扑序靠后的节点设成true 再举个例子：在这种情况下设u=false，因为它的拓扑序比较靠后，如果设u=true显然会造成矛盾。 注意到$tarjan$的拓扑序是从大到小的，所以输出时是这个样子的： 123for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",col[i]&gt;col[i+n]);&#125; 好了，算法讲解好了，我们做一道练习题（做之前先把算法理解透彻）： P4782 【模板】2-SAT 问题 这里我们设$x_i ==true$的节点在$1 \\text{ ~ } n$，$x_i==false$的节点在$n+1 \\text{ ~ } 2n$ 加边的时候这样加，避免讨论： 12AddEdge(u+(!a)*n,v+b*n);AddEdge(v+(!b)*n,u+a*n); 注意数组开两倍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int dfn[MAXN],low[MAXN],cnt;stack&lt;int&gt;stk;int scc,col[MAXN];void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stk.push(u); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]); else if (!col[v]) low[u]=min(low[u],dfn[v]); &#125; if (low[u]==dfn[u])&#123; ++scc; do&#123; col[u]=scc; u=stk.top(),stk.pop(); &#125;while (low[u]!=dfn[u]); &#125;&#125;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),a=read(),v=read(),b=read(); AddEdge(u+(!a)*n,v+b*n); AddEdge(v+(!b)*n,u+a*n); &#125; for (register int i=1;i&lt;=(n&lt;&lt;1);++i)&#123; if (!dfn[i]) tarjan(i); &#125; for (register int i=1;i&lt;=n;++i)&#123; if (col[i]==col[i+n])&#123; puts(\"IMPOSSIBLE\"); return 0; &#125; &#125; puts(\"POSSIBLE\"); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",col[i]&gt;col[i+n]); &#125;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://gaisaiyuno.github.io/tags/2-SAT/"}]},{"title":"P4180 【模板】严格次小生成树[BJWC2010]","slug":"P4180-【模板】严格次小生成树-BJWC2010","date":"2019-08-03T13:39:28.000Z","updated":"2019-08-03T15:23:12.546Z","comments":true,"path":"archives/bf23f83d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/bf23f83d.html","excerpt":"","text":"传送门 可以考虑先做这道题：CF609E Minimum spanning tree for each edge 这道题和上面本质是相同的。 考虑先把这张图的最小生成树建出来，然后改动一条边，形成次小生成树。 $Q.$怎么证明次小生成树是最小生成树改动一条边形成的？ $A.$先考虑一下我们$Kruskal$建最小生成树的做法，我们把所有边按照边权排序，然后从小到大依次取，如果出现环则放弃。 首先，还是按照$Kruskal$的做法，把边排序（标成蓝色的代表选择，灰色代表原来的）。 考虑反证法（口胡版证明）： 既然我们要证明次小生成树是最小生成树改动一条边形成的，那么我们就要证明改动两条边的情况总是可以少改动一条边，而形成一个边权小于等于改动两条边情况下生成树的生成树。 引理：一条边往前跳，补上前面的空是不行的。 按照$Kruskal$算法，我们发现前面留空是有它的理由的，因为前面加边的话会形成环，破坏树的性质，而$Kruscal$是从左到右依次加边的，所以后面位置的变动并不会影响它变成一个环。 再考虑移动两条边的情况： 移动两条边，只有一起向前移动，一起向后移动，一条向前，一条向后的情况。 假设你把两条边向前移动，根据上面的引理，容易证明不行。 假设你就是想把前面留出空来，让后面的边可以插进去，也就是一条向前，一条向后的情况，也就是这样： 发现没有，其实这样是更优的： 可以这么理解：前面标红色部分和后面的边是独立存在的，就是说，红色部分的形态不管怎么变，后面连边和前面形成一个环，就是形成了环，后面连边不形成环，就是不形成环。 假设我们的次小生成树是把两条边往后跳 根据刚才我们的说法，我们把一条前面的边插入前面的空，而不是插进末尾绝对不是最优的，如图： （注意这是特别指移动两条边的情况，如果只移动一条边这还是要考虑的） 所以，我们只能把两条边都移动到末尾（否则只要有一条边插进前面的空，都可以构造出更优解），如图： 等等！为什么要移动两条边，移动一条边不是更优吗？ 所以，证毕！ $Q.$ 怎么实现呢？ $A.$考虑到题目要求的是严格次小生成树，根据刚才的引理，我们只需要改动一条边，就可以得到次大生成树。 不妨不从改动的角度想，而是从加入一条边，删掉一条边的角度考虑。 在最小生成树上面加入一条边，路径上面一定存在一个环，那么我们要把环上的一条边删掉，根据贪心的想法，我们要删掉环上面边权最大的一条边。 但是这时，严格两字有出来烦人了，如果你删掉的最大值就是你加进的那条边的权值，那么得到的生成树大小就和最小生成树相等了。 于是，我们退而求其次，如果最大值就是加进的边，那么我们使用严格次大值。 我们记录$anc[u][i]$，表示$u$的$2^i$辈祖先，$Max1[u][i]$，表示$u$到它的$2^i$辈祖先的路径上面最大值，$Max2[u][i]$，表示$u$到它的$2^i$辈祖先路径上面严格次大值。 转移十分简单 $Max1[u][i-1]==Max1[anc[u][i-1]][i-1]$时，我们只能在两个次大值里面选，即$Max2[u][i]=max(Max2[u][i-1],Max2[anc[u][i-1]][i-1])$ $Max1[u][i-1]&gt;Max1[anc[u][i-1]][i-1]$时，说明$Max1[anc[u][i-1]][i-1]$有成为次大值的可能，即，$Max2[u][i]=max(Max2[u][i-1],Max1[anc[u][i-1]][i-1])$ 剩下一种情况也是类似，不再赘述。 注意：要开$\\text{long long}$，最大值$\\rm INF$开大一点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 23#define EDGE 300005#define int long long#define INF 0x3f3f3f3f3f3f3f3fusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int anc[MAXN][MAXM],Max1[MAXN][MAXM],Max2[MAXN][MAXM];//最大值和严格次大值//Max1[u][i]表示u到u的2^i辈祖先之间边的最大值//Max2[u][i]表示.....的严格次大值int n,m;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;//--------------------Kruscalstruct Edge1&#123; int u,v,w;&#125;e[EDGE];inline bool operator &lt; (const Edge1 &amp;A,const Edge1 &amp;B)&#123; return A.w&lt;B.w;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init_BCJ()&#123; for (register int i=0;i&lt;MAXN;++i) fa[i]=i; &#125; int Fa(int i)&#123; return fa[i]==i?i:fa[i]=Fa(fa[i]); &#125;&#125;using namespace BCJ;int MST[EDGE];//是否出现在最小生成树中inline int Kruscal()&#123; Init_BCJ(); sort(e+1,e+1+m); int mst=0; for (register int i=1;i&lt;=m;++i)&#123; int u=e[i].u,v=e[i].v,w=e[i].w; int fau=Fa(u),fav=Fa(v); if (fau!=fav)&#123; fa[fau]=fav; mst+=w; MST[i]=true; AddEdge(u,v,w); AddEdge(v,u,w); &#125; &#125; return mst;&#125;//----------------------------int dep[MAXN];void dfs(int u,int father)&#123; anc[u][0]=father; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father)&#123; Max1[v][0]=w; Max2[v][0]=-INF;//不存在次大值 dep[v]=dep[u]+1; dfs(v,u); &#125; &#125;&#125;inline void Merge(int &amp;max1,int &amp;max2,int max1d,int max1u,int max2d,int max2u)&#123; max1=max(max1d,max1u); if (max1d&gt;max1u) max2=max(max2d,max1u); else if (max1d==max1u) max2=max(max2d,max2u); else max2=max(max1d,max2u);&#125;inline void Init()&#123; for (register int i=1;i&lt;MAXM;++i)&#123; for (register int u=1;u&lt;=n;++u)&#123; anc[u][i]=anc[anc[u][i-1]][i-1]; Merge(Max1[u][i],Max2[u][i],Max1[u][i-1],Max1[anc[u][i-1]][i-1],Max2[u][i-1],Max2[anc[u][i-1]][i-1]); &#125; &#125;&#125;inline int LCA(int u,int v)&#123; if (u==1||v==1) return 1; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i],v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;inline int Hop(int u,int lca,int val)&#123; int maxn=-INF;//次大值!=val for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[lca])&#123;//I can H♂p if (Max1[u][i]!=val) maxn=max(maxn,Max1[u][i]);//这样可以采用最大值 else maxn=max(maxn,Max2[u][i]);//不能采用最大值，要不然就不是严格次大生成树了，所以只能采用严格次大值 u=anc[u][i]; &#125; &#125; return maxn;&#125;#undef intint main()&#123;#define int long long n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; e[i].u=read();e[i].v=read();e[i].w=read(); &#125; int mst=Kruscal(); dfs(1,1); Init(); int ans=INF; for (register int i=1;i&lt;=m;++i)&#123; if (!MST[i])&#123; int u=e[i].u,v=e[i].v,w=e[i].w; int lca=LCA(u,v); int len=max(Hop(u,lca,w),Hop(v,lca,w)); ans=min(ans,mst+w-len);//减去len这条边，加上w这条边 &#125; &#125; printf(\"%lld\\n\",ans);&#125; 这道题应该树剖也能做，但是大材小用了，而且不好调试。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树上倍增","slug":"树上倍增","permalink":"https://gaisaiyuno.github.io/tags/树上倍增/"}]},{"title":"P2898 [USACO08JAN]haybale猜测Haybale Guessing","slug":"P2898-USACO08JAN-haybale猜测Haybale-Guessing","date":"2019-08-02T14:56:38.000Z","updated":"2019-08-02T15:16:55.597Z","comments":true,"path":"archives/8a9a3c57.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8a9a3c57.html","excerpt":"","text":"传送门 这道题思路还是比较巧妙的，考虑如何判断矛盾。 首先，发现题目中说 每个位置上的数都不同的序列a[1..n] 所以任意两个不相交的区间中，最小值一定是不同的（性质$1$），因为如果最小值相同，那么最小值对应到的那个数是相同的，说明两段区间都包含那个数，即两段区间相交。 再继续考虑，我们考虑二分答案，现在二分到一个位置$pos$，我们首先把位置$\\le pos$的操作按照$RMQ$值从大到小排序，然后依次分层操作，也就是说，（举个栗子）我们先把$RMQ$值为$6$的操作操作完，再操作$RMQ$值为$5$的操作操作完…… 在操作相同的层时，可以根据刚才说的性质$1$判断。 但是只根据这一个性质是远远不够的，还有没有更多的性质？ 从特殊情况考虑，如果出现这样的情况，那么肯定不行： 但是出现这样的情况，那么可以接受： 因为最小值$5$可以在边边上面出现。 这样的情况可以推广，用一句话总结： 性质$2$，假设现在我们要判断$RMQ$值为$x$的一个操作合不合法，我们在数轴上面把$RMQ$值$&gt;x$代表的区间全部染色，如果现在的操作的区间全部被染色，则不合法（现在的$[l,r]$包含于大区间） 那么程序就很好实现了，只要一棵支持区间赋值成$1$，区间求和的线段树即可。 每次二分重建线段树，时间复杂度$O(n\\log^2 n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int tag,val; inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Cover(int i)&#123; tree[i].tag=1,tree[i].val=tree[i].len(); &#125; inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Cover(lc),Cover(rc); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].val=tree[i].tag=0; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Cover(i); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R); if (mid&lt;R) Update(rc,L,R); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; pushdown(i); if (L&lt;=mid) ans+=Query(lc,L,R); if (mid&lt;R) ans+=Query(rc,L,R); return ans; &#125;&#125;using namespace SegmentTree;struct query&#123; int l,r; int val;&#125;Q[MAXN],A[MAXN];inline bool operator &lt; (const query &amp;A,const query &amp;B)&#123; return A.val&gt;B.val;&#125;inline bool Covered(int l,int r)&#123;//判断是否全部被染色 return (r-l+1)==Query(1,l,r);&#125;int n,q;inline bool Check(int pos)&#123; Build(1,1,n); for (register int i=1;i&lt;=pos;++i)&#123; A[i]=Q[i]; &#125; sort(A+1,A+1+pos); int lmin,lmax,rmin,rmax; lmin=lmax=A[1].l; rmin=rmax=A[1].r; for (register int i=2;i&lt;=pos;++i)&#123; if (A[i].val==A[i-1].val)&#123;//继续扩展 lmin=min(lmin,A[i].l); lmax=max(lmax,A[i].l); rmin=min(rmin,A[i].r); rmax=max(rmax,A[i].r); if (lmax&gt;rmin) return 1; &#125; else &#123; if (Covered(lmax,rmin)) return 1; Update(1,lmin,rmax); lmin=lmax=A[i].l; rmin=rmax=A[i].r; &#125; &#125; if (Covered(lmax,rmin)) return 1; return 0;&#125;int main()&#123; n=read(),q=read(); for (register int i=1;i&lt;=q;++i)&#123; Q[i]=query&#123;read(),read(),read()&#125;; &#125; int l=1,r=q; int ans=0; while (l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if (Check(mid)) ans=mid,r=mid-1; else l=mid+1; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"二分","slug":"二分","permalink":"https://gaisaiyuno.github.io/tags/二分/"}]},{"title":"P3901 数列找不同","slug":"P3901-数列找不同","date":"2019-08-02T14:52:56.000Z","updated":"2019-08-02T14:55:40.528Z","comments":true,"path":"archives/b1ed5573.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b1ed5573.html","excerpt":"","text":"传送门 莫队是一种多么优美的算法，肿么能不用莫队呢？ 只要记录区间出现次数超过$2$的数就可以搞定了（代码中是$cnt2$）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Query&#123; int l,r,id;&#125;q[MAXN];int pos[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.l]&lt;pos[b.l]||(pos[a.l]==pos[b.l]&amp;&amp;((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r));&#125;int a[MAXN],cnt[MAXN],cnt2;inline void Add(int x)&#123; ++cnt[x]; if (cnt[x]==2) cnt2++;&#125;inline void Del(int x)&#123; --cnt[x]; if (cnt[x]==1) cnt2--;&#125;int Ans[MAXN];int main()&#123; int n=read(),m=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i]=Query&#123;read(),read(),i&#125;; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&gt;q[i].l) Add(a[--l]); while (r&lt;q[i].r) Add(a[++r]); while (r&gt;q[i].r) Del(a[r--]); while (l&lt;q[i].l) Del(a[l++]); Ans[q[i].id]=(cnt2==0); &#125; for (register int i=1;i&lt;=m;++i)&#123; puts(Ans[i]?\"Yes\":\"No\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"}]},{"title":"P3979 遥远的国度","slug":"P3979-遥远的国度","date":"2019-08-02T14:43:58.000Z","updated":"2019-08-02T14:51:38.548Z","comments":true,"path":"archives/b3e97295.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b3e97295.html","excerpt":"","text":"传送门 本质一样的一道YNOI 首先明确一件事情，这个换根其实是吓你的， $1.$只有最近的一次换根才会对答案有影响（显然） $2.$分情况讨论，我们始终以$1$节点为根，设现在查询的节点为$u$，上一次换根的根为$rt$（$rt$是一个假的根） ，我们画出$3$个图： 若$u==rt$，显然现在查询的是整棵树，对应到区间$[1,n]$： 若$LCA(u,rt)==u$（或者说$rt$在$u$的子树中）， 我们想象一下，把$rt$从底下提上来，查询的就是红色圈圈起来的部分 再把这个红色圈圈起来的部分对应回去 原来就是整棵树去掉$v$的子树的部分，其中$v$为$u$的孩子，$rt$的祖先（可以树上倍增搞一下） 这个可以对应到两个区间$[1,L[v]-1]$，$[R[v]+1,n]$ 最后一种情况，若$LCA(u,rt)!=u$，那么我们再画一个图： 发现这个换根和没换一样，所以就是查询区间$[L[u],R[u]]$ 所以这道题我们就解决。。。。了吗？ 首先，为了准确求出$dfn$ 序，我们要把$dfs2$魔改成这个样子 12345678910111213void dfs2(int u,int t)&#123; if (!u) return ; seq[L[u]=++cnt]=u; top[u]=t; dfs2(son[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=son[u]&amp;&amp;v!=fa[u])&#123; dfs2(v,v); &#125; &#125; R[u]=cnt;&#125; 然后，这道题还要有一个很孙的特判，如果$u==1||v==1$则返回根节点： 12345678910111213141516inline int LCA(int u,int v)&#123; if (u==1||v==1) return 1; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i],v=anc[v][i]; &#125; &#125; return anc[u][0];&#125; 献上$WA$无数次的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MAXM 25using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int a[MAXN];int fa[MAXN],dep[MAXN],top[MAXN],sz[MAXN],tofa[MAXN],son[MAXN];int anc[MAXN][MAXM];void dfs1(int u,int father)&#123; sz[u]=1; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i)&#123; anc[u][i]=anc[anc[u][i-1]][i-1]; &#125; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); sz[u]+=sz[v]; if (sz[son[u]]&lt;sz[v]) son[u]=v; &#125; &#125;&#125;int L[MAXN],R[MAXN],seq[MAXN],cnt;void dfs2(int u,int t)&#123; if (!u) return ; seq[L[u]=++cnt]=u; top[u]=t; dfs2(son[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=son[u]&amp;&amp;v!=fa[u])&#123; dfs2(v,v); &#125; &#125; R[u]=cnt;&#125;inline int LCA(int u,int v)&#123; if (u==1||v==1) return 1; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i],v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;inline int Hop(int u,int lca)&#123; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;dep[lca]) &#123; u=anc[u][i]; &#125; &#125; return u;&#125;int val[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int mino,tag; &#125;tree[MAXN&lt;&lt;1]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Cover(int i,int val)&#123; tree[i].mino=tree[i].tag=val; &#125; inline void pushup(int i)&#123; tree[i].mino=min(tree[lc].mino,tree[rc].mino); &#125; inline void pushdown(int i)&#123; if (tree[i].tag!=-1)&#123; Cover(lc,tree[i].tag); Cover(rc,tree[i].tag); tree[i].tag=-1; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].tag=-1; if (l==r)&#123; tree[i].mino=a[seq[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Cover(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].mino; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0x7fffffff; pushdown(i); if (L&lt;=mid) ans=min(ans,Query(lc,L,R)); if (mid&lt;R) ans=min(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;inline void UpdateChain(int u,int v,int val)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); Update(1,L[top[u]],L[u],val); u=anc[top[u]][0]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); Update(1,L[u],L[v],val);&#125;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; dfs1(1,0); dfs2(1,1); Build(1,1,n); int rt=read(); while (m--)&#123; int opr=read(); if (opr==1)&#123; rt=read(); &#125; else if (opr==2)&#123; int u=read(),v=read(),val=read(); UpdateChain(u,v,val); &#125; else if (opr==3)&#123; int u=read(); if (u==rt)&#123; printf(\"%d\\n\",Query(1,1,n)); &#125; else if (LCA(u,rt)==u)&#123; int v=Hop(rt,u); printf(\"%d\\n\",min(Query(1,1,L[v]-1),Query(1,R[v]+1,n))); &#125; else &#123; printf(\"%d\\n\",Query(1,L[u],R[u])); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"}]},{"title":"P3792 由乃与大母神原型和偶像崇拜","slug":"P3792-由乃与大母神原型和偶像崇拜","date":"2019-08-02T02:44:40.000Z","updated":"2019-08-02T03:05:43.517Z","comments":true,"path":"archives/a301c9f5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a301c9f5.html","excerpt":"","text":"传送门 我首先是这么想的，记录每个元素前一次出现的位置$pre$（判断是否重复），再维护一个最大值和最小值 后面发现这题原来还带修改，就放弃了这种想法。 考虑一个正确率较高的做法，维护区间每个数的平方和$sum$，最大值$max$和最小值$min$，若查询区间长度不等于$max-min+1$，那么肯定不行，再算一下$\\sum _{i=min}^{max}a_i^2$，若不等于$sum$，那么肯定也不行，剩下就认为它行。 是不是很草率，但是它就是$A$了。 具体实现的时候，利用$\\text{long long}$自然溢出取模。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; long long sum; int mino,maxn; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].sum=tree[lc].sum+tree[rc].sum; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); tree[i].mino=min(tree[lc].mino,tree[rc].mino); &#125; inline void Set(int i,int val)&#123; tree[i].sum=val*val; tree[i].mino=tree[i].maxn=val; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; Set(i,a[l]); return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int pos,int val)&#123; if (tree[i].l==tree[i].r)&#123; Set(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (pos&lt;=mid) Update(lc,pos,val); else Update(rc,pos,val); pushup(i); &#125; int QueryMax(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,QueryMax(lc,L,R)); if (mid&lt;R) ans=max(ans,QueryMax(rc,L,R)); return ans; &#125; int QueryMin(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].mino; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0x7fffffff; if (L&lt;=mid) ans=min(ans,QueryMin(lc,L,R)); if (mid&lt;R) ans=min(ans,QueryMin(rc,L,R)); return ans; &#125; long long QuerySum(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].sum; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; long long ans=0; if (L&lt;=mid) ans+=QuerySum(lc,L,R); if (mid&lt;R) ans+=QuerySum(rc,L,R); return ans; &#125;&#125;using namespace SegmentTree;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,1,n); while (m--)&#123; int opr=read(); if (opr==1)&#123; int x=read(),y=read(); Update(1,x,y); &#125; else &#123; int l=read(),r=read(); int fi=QueryMin(1,l,r),ed=QueryMax(1,l,r); if (r-l!=ed-fi)&#123;puts(\"yuanxing\");continue;&#125; long long ans=0; for (register int i=fi;i&lt;=ed;++i) ans+=(long long)(i*i); if (ans==QuerySum(1,l,r)) puts(\"damushen\"); else puts(\"yuanxing\"); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"U80812 相同颜色对","slug":"U80812-相同颜色对","date":"2019-08-02T02:20:54.000Z","updated":"2019-08-02T03:10:17.072Z","comments":true,"path":"archives/7f9132a3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/7f9132a3.html","excerpt":"","text":"传送门 给你一个序列${a_i}$，和四个数$l1,r1,l2,r2$，求区间$[l1,r1]，[l2,r2]$中相同的数有多少对。 当然你不能维护四个指针，考虑容斥原理，我们不妨设$f(x,y)$为下标为$[1,x]$和下标为$[1,y]$中相同的$a_i$有多少对，这样我们可以开心地容斥$Query(l1,r1,l2,r2)=f(l2,r2)-f(l1-1,r2)-f(r1,l2-1)+f(l1-1,l2-1)$。 具体实现的时候，$Query$结构体里面存一个$f$代表符号即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],Ans[MAXN],cnt1[MAXN],cnt2[MAXN],qcnt,pos[MAXN];struct Query&#123; int pos1,pos2;//代表的是[1,pos1]，[1,pos2] int id,f;//容斥的符号&#125;Q[MAXN*4];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.pos1]&lt;pos[b.pos1]||(pos[a.pos1]==pos[b.pos1]&amp;&amp;((pos[a.pos1]&amp;1)?a.pos2&lt;b.pos2:a.pos2&gt;b.pos2));&#125;inline void AddQuery(int pos1,int pos2,int id,int f)&#123; Q[++qcnt].f=f,Q[qcnt].id=id,Q[qcnt].pos1=pos1,Q[qcnt].pos2=pos2;&#125;int main()&#123; int n=read(),m=read(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; int l1=read(),r1=read(),l2=read(),r2=read(); AddQuery(r1,r2,i,1); AddQuery(l1-1,r2,i,-1); AddQuery(r1,l2-1,i,-1); AddQuery(l1-1,l2-1,i,1); &#125; sort(Q+1,Q+1+qcnt); int r1=0,r2=0,ans=0; for (register int i=1;i&lt;=qcnt;++i)&#123; while (r1&lt;Q[i].pos1)&#123; ++cnt1[a[++r1]]; ans+=cnt2[a[r1]]; &#125; while (r1&gt;Q[i].pos1)&#123; --cnt1[a[r1]]; ans-=cnt2[a[r1--]]; &#125; while (r2&lt;Q[i].pos2)&#123; ++cnt2[a[++r2]]; ans+=cnt1[a[r2]]; &#125; while (r2&gt;Q[i].pos2)&#123; --cnt2[a[r2]]; ans-=cnt1[a[r2--]]; &#125; Ans[Q[i].id]+=Q[i].f*ans; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"容斥","slug":"容斥","permalink":"https://gaisaiyuno.github.io/tags/容斥/"}]},{"title":"P5315 头像上传","slug":"P5315-头像上传","date":"2019-08-01T12:55:26.000Z","updated":"2019-08-01T12:56:48.292Z","comments":true,"path":"archives/d5e172f3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d5e172f3.html","excerpt":"","text":"传送门 你们搞的这个题目啊，$\\rm exciting$123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int main()&#123; int n=read(),L=read(),G=read(); while (n--)&#123; int w=read(),h=read(); while (w&gt;G||h&gt;G)&#123; w&gt;&gt;=1,h&gt;&gt;=1; &#125; if (w&lt;L||h&lt;L) puts(\"Too Young\"); else if (w!=h) puts(\"Too Simple\"); else puts(\"Sometimes Naive\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"},{"name":"模拟","slug":"模拟","permalink":"https://gaisaiyuno.github.io/tags/模拟/"}]},{"title":"P5071 [Ynoi2015]此时此刻的光辉","slug":"P5071-Ynoi2015-此时此刻的光辉","date":"2019-08-01T12:00:35.000Z","updated":"2019-08-01T12:43:42.546Z","comments":true,"path":"archives/ef48a1fd.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ef48a1fd.html","excerpt":"","text":"传送门 首先，附送本题数据生成器： 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;inline int gen()&#123; return (rand()&lt;&lt;15)|(rand());&#125;int main()&#123; srand(time(NULL)); freopen(\"yukideru.in\",\"w\",stdout); int n=100000,m=100000; printf(\"%d %d\\n\",n,m); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",gen()%1000000000); &#125; printf(\"\\n\"); for (register int i=1;i&lt;=m;++i)&#123; int l=gen()%n+1,r=gen()%n+1; if (l&gt;r) swap(l,r); printf(\"%d %d\\n\",l,r); &#125;&#125; $Pro$珂朵莉给你了一个长为$n$的序列，有$m$次查询，每次查询一段区间的乘积的约数个数$\\mod 19260817$的值 $n,m\\le 100000$$1 \\le a_i \\le 1000000000$ $Sol$首先，根据小学奥数（雾），设$D(x)$为$x$的约数个数，设$x=\\prod p_i^{k_i} (p_i \\in \\text{prime})$，我们有 $D(x)=\\prod (k_i+1)$。 于是，每次莫队转移的时候，我们把新加进的那个数（设为$A$）分解质因数，假设现在分解出了一个质数$p$，那么答案$\\times inv(cnt[p]+1)$，然后$cnt[p]++$，最后$\\times (cnt[p]+1)$，但是这样肯定会炸掉，因为质因数很多，考虑到$A$的质因数很多都是$1000$的质因数。 所以，方法就有了，考虑把$&lt;1000$的和$\\geq 1000$的质数分开考虑，因为$&lt;1000$的质数只有$169$个，所以每次重新算也没有关系，$\\geq 1000$的质数就按照上面方法维护就可以了。 再看怎么具体实现，首先预处理逆元和线性筛质数都是必须的 $1.$考虑维护$&lt;1000$的质数对答案的贡献，维护一个前缀和数组$sum$，其中$sum[i][p]$代表$\\prod_{j=1}^{i} a_j$中$p$出现的次数，求$\\prod_{j=l}^{r} a_j$中$p$出现的次数，就是前缀和做一下差，即$sum[r][p]-sum[l-1][p]$。 $2.$考虑维护$\\geq 1000$的质数对答案的贡献，由于$\\geq1000$的质数比较多，不好记录，又发现其实答案只和$k_i$有关，和$p_i$是没关的，所以只要统计不同的数的个数即可，我们这里用一种比较偷懒的办法，新来一个数，我们把它扔进一个$map$里面，如果他出现过，那么记录他在$map$里面的编号，否则新建一个编号，这样就起到去重和离散化的效果（这种办法太偷懒了，导致程序效率不高），最后像上面说的一样，莫队维护一下。 注意：中间量要开$\\text{long long}$，使劲卡常，此代码多交几次或许能$\\rm AC$ 时间复杂度$O(n \\sqrt{n}*169)$ 总结一下，质数在一段区间的稠密度是不同的，标程就是根据这个性质，分布稠密的小范围暴力搞，分布稀疏的大范围莫队搞，这是一种重要的思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)#define MOD 19260817#define MAXN 200005#define MAXP 32005#define CNT 169 //小于1000的质数个数#define ll long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;//思路：把&lt;1000的和&gt;=1000的分开考虑static int inv[MAXN];static int nprime[MAXN];static int cnt,prime[MAXN],pos[MAXN];//预处理逆元，筛质数，初始化莫队inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=((long long)ans*(long long)b)%MOD; b=((long long)b*(long long)b)%MOD; k&gt;&gt;=1; &#125; return ans;&#125;inline void Init(int n)&#123; for (register int i=0;i&lt;MAXN;++i)&#123; inv[i]=ksm(i,MOD-2)%MOD; &#125; for (register int i=2;i&lt;MAXP;++i)&#123; if (!nprime[i])&#123; for (register int j=i*2;j&lt;MAXP;j+=i)&#123; nprime[j]=true; &#125; &#125; &#125; for (register int i=2;i&lt;MAXP;++i)&#123; if (!nprime[i]) prime[++cnt]=i; &#125; int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/Size+1; &#125;&#125;static int sum[MAXN][CNT];static int v[MAXN][CNT],top[MAXN];static map&lt;int,int&gt;M;//暂时没有想到好的方法替代这个Mapinline void AddV(int i,int val)&#123; if (M.count(val)==0) v[i][++top[i]]=M[val]=M.size()+1;//新建一个编号 else v[i][++top[i]]=M[val];//沿用原来的编号&#125;struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;A,const Query &amp;B)&#123; return pos[A.l]&lt;pos[B.l]||(pos[A.l]==pos[B.l]&amp;&amp;((pos[A.l]&amp;1)?A.r&lt;B.r:A.r&gt;B.r));&#125;int ans;static int c[MAXN];inline void Add(int x)&#123; for (register int i=1;i&lt;=top[x];++i)&#123; ans=((long long)ans*inv[c[v[x][i]]+1])%MOD; ++c[v[x][i]],c[v[x][i]]%=MOD; ans=((long long)ans*(c[v[x][i]]+1))%MOD; &#125;&#125;inline void Del(int x)&#123; for (register int i=1;i&lt;=top[x];++i)&#123; ans=((long long)ans*(inv[c[v[x][i]]+1]))%MOD; --c[v[x][i]],(c[v[x][i]]+=MOD)%=MOD; ans=((long long)ans*(c[v[x][i]]+1))%MOD; &#125;&#125;static int Ans[MAXN];int main()&#123; // freopen(\"yukideru.in\",\"r\",stdin); // freopen(\"yukideru.out\",\"w\",stdout); int n=read(),m=read(); Init(n); for (register int i=1;i&lt;=n;++i)&#123; int a=read(); for (register int j=1;j&lt;CNT;++j)&#123;//分开搞 sum[i][j]=sum[i-1][j]; while (a%prime[j]==0)&#123; a/=prime[j],++sum[i][j]; &#125; &#125; if (a==1) continue; for (register int j=CNT;j&lt;=cnt;++j)&#123; if (a==1) break; while (a%prime[j]==0)&#123; a/=prime[j],AddV(i,prime[j]); &#125; &#125; if (a!=1) AddV(i,a); &#125; for (register int i=1;i&lt;=m;++i)&#123; int l=read(),r=read(); q[i].l=l,q[i].r=r,q[i].id=i; &#125; sort(q+1,q+1+m); register int l=1,r=0; ans=1ll; for (register int i=1;i&lt;=m;++i)&#123; while (l&gt;q[i].l) Add(--l); while (r&lt;q[i].r) Add(++r); while (l&lt;q[i].l) Del(l++); while (r&gt;q[i].r) Del(r--); Ans[q[i].id]=ans; for (register int j=1;j&lt;CNT;++j)&#123; Ans[q[i].id]=((long long)Ans[q[i].id]*(sum[r][j]-sum[l-1][j]+1))%MOD;//前缀和搞一下 &#125; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"},{"name":"卡常","slug":"卡常","permalink":"https://gaisaiyuno.github.io/tags/卡常/"}]},{"title":"P4689 [Ynoi2016]这是我自己的发明","slug":"P4689-Ynoi2016-这是我自己的发明","date":"2019-08-01T03:21:40.000Z","updated":"2019-08-02T14:45:17.302Z","comments":true,"path":"archives/220575f0.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/220575f0.html","excerpt":"","text":"洛谷 LOJ BZOJ 首先，考虑这样一个问题：给你一个序列${a_i}$，和四个数$l1,r1,l2,r2$，求区间$[l1,r1]，[l2,r2]$中相同的数有多少对。 这个可以参见我出的一道题：相同颜色对 当然你不能维护四个指针，考虑容斥原理，我们不妨设$f(x,y)$为下标为$[1,x]$和下标为$[1,y]$中相同的$a_i$有多少对，这样我们可以开心地容斥$Query(l1,r1,l2,r2)=f(l2,r2)-f(l1-1,r2)-f(r1,l2-1)+f(l1-1,l2-1)$。 具体实现的时候，$Query$结构体里面存一个$f$代表符号即可。 回到本题，首先明确一件事情，这个换根其实是吓你的， $1.$只有最近的一次换根才会对答案有影响（显然） $2.$分情况讨论，我们始终以$1$节点为根，设现在查询的节点为$u$，上一次换根的根为$rt$（$rt$是一个假的根） ，我们画出$3$个图： 若$u==rt$，显然现在查询的是整棵树，对应到区间$[1,n]$： 123if (u==rt)&#123;//整棵树 A[++top]=1,B[top]=n;&#125; 若$LCA(u,rt)==u$（或者说$rt$在$u$的子树中）， 我们想象一下，把$rt$从底下提上来，查询的就是红色圈圈起来的部分 再把这个红色圈圈起来的部分对应回去 原来就是整棵树去掉$v$的子树的部分，其中$v$为$u$的孩子，$rt$的祖先（可以树上倍增搞一下） 这个可以对应到两个区间$[1,L[v]-1]$，$[R[v]+1,n]$ 12345else if (LCA(u,rt)==u)&#123; int v=Hop(rt,u);//除去v的子树 if (L[v]&gt;1) A[++top]=1,B[top]=L[v]-1; if (R[v]&lt;n) A[++top]=R[v]+1,B[top]=n;&#125; 最后一种情况，若$LCA(u,rt)!=u$，那么我们再画一个图： 发现这个换根和没换一样，所以就是查询区间$[L[u],R[u]]$ 123else&#123;//换根相当于没换 A[++top]=L[u],B[top]=R[u];&#125; 好了，最重要的部分讲完了，剩下的都是细节，注意要离散化，开$\\text{long long}$，具体实现时，可以开两个栈，把区间存进去，然后互相搞一下，如下： 12345for (register int j=1;j&lt;=top1;++j)&#123; for (register int k=1;k&lt;=top2;++k)&#123; RC(A1[j],B1[j],A2[k],B2[k],qu); &#125;&#125; 注意边界。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MAXM 19using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int L[MAXN],R[MAXN],cnt,seq[MAXN];int anc[MAXN][MAXM],dep[MAXN];int val[MAXN],n,m,temp[MAXN];void dfs(int u,int father)&#123; seq[L[u]=++cnt]=val[u]; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i) anc[u][i]=anc[anc[u][i-1]][i-1]; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs(v,u); &#125; &#125; R[u]=cnt;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v]) u=anc[u][i]; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i]) u=anc[u][i],v=anc[v][i]; &#125; return anc[u][0];&#125;inline int Hop(int u,int v)&#123;//h♂p to v's son for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;dep[v])&#123; u=anc[u][i]; &#125; &#125; return u;&#125;inline void discrete()&#123; for (register int i=1;i&lt;=n;++i)&#123; temp[i]=val[i]; &#125; sort(temp+1,temp+1+n); for (register int i=1;i&lt;=n;++i)&#123; val[i]=lower_bound(temp+1,temp+1+n,val[i])-temp; &#125;&#125;//用容斥转换成只有一个指针的莫队int pos[MAXN],rt;inline void Add(int u,int &amp;top,int *A,int *B)&#123;//最核心的操作就在这里 if (u==rt)&#123;//整棵树 A[++top]=1,B[top]=n; &#125; else if (LCA(u,rt)==u)&#123; int v=Hop(rt,u);//除去v的子树 if (L[v]&gt;1) A[++top]=1,B[top]=L[v]-1; if (R[v]&lt;n) A[++top]=R[v]+1,B[top]=n; &#125; else&#123;//换根相当于没换 A[++top]=L[u],B[top]=R[u]; &#125;&#125;int A1[MAXN],B1[MAXN],A2[MAXN],B2[MAXN];int top1,top2;struct Query&#123; int pos1,pos2;//代表的是[1,pos1]，[1,pos2] int id,f;//容斥的符号&#125;Q[MAXN*16];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return pos[a.pos1]&lt;pos[b.pos1]||(pos[a.pos1]==pos[b.pos1]&amp;&amp;((pos[a.pos1]&amp;1)?a.pos2&lt;b.pos2:a.pos2&gt;b.pos2));&#125;int qcnt;inline void AddQuery(int pos1,int pos2,int id,int f)&#123; if (pos1&lt;=0||pos2&lt;=0) return ; if (pos1&gt;pos2) swap(pos1,pos2); Q[++qcnt].f=f,Q[qcnt].id=id,Q[qcnt].pos1=pos1,Q[qcnt].pos2=pos2;&#125;inline void RC(int l1,int r1,int l2,int r2,int i)&#123;//容斥 AddQuery(r1,r2,i,1); AddQuery(l1-1,r2,i,-1); AddQuery(r1,l2-1,i,-1); AddQuery(l1-1,l2-1,i,1);&#125;long long Ans[MAXN];int cnt1[MAXN],cnt2[MAXN];int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; val[i]=read(); &#125; discrete(); int Size=sqrt(n); for (register int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; dfs(1,1); rt=1;//因为只有每一次询问前最后一次换根才能起作用，所以只有记录一个rt int qu=0; for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1)&#123; rt=read(); &#125; else &#123; int u=read(),v=read(); qu++; top1=top2=0;//清空栈 Add(u,top1,A1,B1); Add(v,top2,A2,B2); for (register int j=1;j&lt;=top1;++j)&#123; for (register int k=1;k&lt;=top2;++k)&#123; RC(A1[j],B1[j],A2[k],B2[k],qu); &#125; &#125; &#125; &#125; sort(Q+1,Q+1+qcnt); int r1=0,r2=0; long long ans=0; for (register int i=1;i&lt;=qcnt;++i)&#123; while (r1&lt;Q[i].pos1)&#123; ++cnt1[seq[++r1]]; ans+=cnt2[seq[r1]]; &#125; while (r1&gt;Q[i].pos1)&#123; --cnt1[seq[r1]]; ans-=cnt2[seq[r1--]]; &#125; while (r2&lt;Q[i].pos2)&#123; ++cnt2[seq[++r2]]; ans+=cnt1[seq[r2]]; &#125; while (r2&gt;Q[i].pos2)&#123; --cnt2[seq[r2]]; ans-=cnt1[seq[r2--]]; &#125; Ans[Q[i].id]+=(long long)Q[i].f*ans; &#125; for (register int i=1;i&lt;=qu;++i)&#123; printf(\"%lld\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"树上莫队","slug":"树上莫队","permalink":"https://gaisaiyuno.github.io/tags/树上莫队/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"}]},{"title":"P4462 [CQOI2018]异或序列","slug":"P4462-CQOI2018-异或序列","date":"2019-07-31T14:44:42.000Z","updated":"2019-07-31T14:56:24.948Z","comments":true,"path":"archives/35e11643.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/35e11643.html","excerpt":"","text":"传送门 小清新莫队题，考虑两个相同的数异或起来会抵消，设$sum_i=a_1⨁a_2⨁….⨁a_i$我们有$a_x ⨁ a_{x+1} ⨁ …. ⨁ a_y=sum_y ⨁ sum_{x-1}$ 这样就好办了，设当前维护的区间为$[l,r]$，我们开一个桶$cnt[x]$，记录$sum[i] i \\in [l,r]$，出现了多少次。 考虑新加进一个下标为$p$的数，把$sum_y ⨁ sum_{x-1}=k$转换成$sum_y=k ⨁ sum_{x-1}$，于是$ans+=cnt[a[p] ⨁ k]$即可。 减掉也是相同的，不在赘述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],cnt[MAXN],pos[MAXN],k,ans;inline void Add(int x)&#123; ans+=cnt[x^k],++cnt[x];&#125;inline void Del(int x)&#123; --cnt[x],ans-=cnt[x^k];&#125;struct Query&#123; int l,r,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return (pos[a.l]^pos[b.l])?pos[a.l]&lt;pos[b.l]:((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r);&#125;int Ans[MAXN];int main()&#123; int n=read(),m=read();k=read(); int Size=(int)(sqrt(n)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=a[i-1]^read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; q[i]=Query&#123;read()-1,read(),i&#125;; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&gt;q[i].l) Add(a[--l]); while (r&lt;q[i].r) Add(a[++r]); while (l&lt;q[i].l) Del(a[l++]); while (r&gt;q[i].r) Del(a[r--]); Ans[q[i].id]=ans; &#125; for (register int i=1;i&lt;=m;++i)&#123; printf(\"%d\\n\",Ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"二进制","slug":"二进制","permalink":"https://gaisaiyuno.github.io/tags/二进制/"}]},{"title":"SP3978 DISQUERY - Distance Query","slug":"SP3978-DISQUERY-Distance-Query","date":"2019-07-31T13:43:21.000Z","updated":"2019-07-31T13:44:50.514Z","comments":true,"path":"archives/b3f6292d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b3f6292d.html","excerpt":"","text":"传送门 树链剖分裸题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123;int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; Edge temp; temp.to=v; temp.len=w; G[u].push_back(temp);&#125;int fa[MAXN],dep[MAXN],tofa[MAXN],dfn[MAXN],seq[MAXN],cnt,top[MAXN],sz[MAXN],son[MAXN];void dfs1(int u,int father)&#123; sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father)&#123; fa[v]=u,dep[v]=dep[u]+1; tofa[v]=w; dfs1(v,u); sz[u]+=sz[v]; if (sz[v]&gt;sz[son[u]]) son[u]=v; &#125; &#125;&#125;void dfs2(int u,int t)&#123; seq[dfn[u]=++cnt]=u; top[u]=t; if (son[u]) dfs2(son[u],t); else return ; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; if (v!=son[u]&amp;&amp;v!=fa[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int maxn,mino; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); tree[i].mino=min(tree[lc].mino,tree[rc].mino); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].maxn=tree[i].mino=tofa[seq[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; int QueryMax(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,QueryMax(lc,L,R)); if (mid&lt;R) ans=max(ans,QueryMax(rc,L,R)); return ans; &#125; int QueryMin(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].mino; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0x7fffffff; if (L&lt;=mid) ans=min(ans,QueryMin(lc,L,R)); if (mid&lt;R) ans=min(ans,QueryMin(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;inline int QueryChainMax(int u,int v)&#123; int ans=-0x7fffffff; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); ans=max(ans,QueryMax(1,dfn[top[u]],dfn[u])); u=fa[top[u]]; &#125; if (u==v) return ans; if (dep[u]&gt;dep[v]) swap(u,v); return max(ans,QueryMax(1,dfn[u]+1,dfn[v]));&#125;inline int QueryChainMin(int u,int v)&#123; int ans=0x7fffffff; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); ans=min(ans,QueryMin(1,dfn[top[u]],dfn[u])); u=fa[top[u]]; &#125; if (u==v) return ans; if (dep[u]&gt;dep[v]) swap(u,v); return min(ans,QueryMin(1,dfn[u]+1,dfn[v]));&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); &#125; dfs1(1,0); dfs2(1,1); Build(1,1,n); int q=read(); while (q--)&#123; int u=read(),v=read(); printf(\"%d %d\\n\",QueryChainMin(u,v),QueryChainMax(u,v)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P5002 专心OI - 找祖先","slug":"P5002-专心OI-找祖先","date":"2019-07-31T12:50:36.000Z","updated":"2019-07-31T13:02:15.391Z","comments":true,"path":"archives/89f3ff98.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/89f3ff98.html","excerpt":"","text":"传送门 不记得是哪场比赛切的题了，发现点$p$的两个不同子树中任选两个点作为$(u_i,v_i)$，他们的$LCA$ 都是$p_i$ 所以答案为$\\sum_{u,v \\in ch[p],u!=v} sz[u]*sz[v]$，剩下容斥乱搞一下就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAXN 10005#define MOD 1000000007using namespace std;struct Edge&#123; int u,v,nex;&#125; w[MAXN&lt;&lt;1];int ecnt,head[MAXN];inline void add_edge(int u,int v)&#123; w[++ecnt].u=u; w[ecnt].v=v; w[ecnt].nex=head[u]; head[u]=ecnt;&#125;int sz[MAXN],fa[MAXN];void dfs(int u,int father)&#123; sz[u]=1;fa[u]=father; for (register int i=head[u];i;i=w[i].nex)&#123; if (w[i].v!=father)&#123; dfs(w[i].v,u); sz[u]+=sz[w[i].v]; sz[u]%=MOD; &#125; &#125;&#125;long long Ans[MAXN];int main()&#123; int n,r,m; scanf(\"%d%d%d\",&amp;n,&amp;r,&amp;m); for (register int i=1;i&lt;n;++i)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); &#125; dfs(r,-1); for (register int i=0;i&lt;m;++i)&#123; int u; scanf(\"%d\",&amp;u); if (Ans[u])&#123; printf(\"%lld\\n\",Ans[u]); continue; &#125; long long sum1=0,sum2=0; for (register int i=head[u];i;i=w[i].nex)&#123; if (w[i].v==fa[u]) continue; sum1+=(long long)sz[w[i].v]; sum2+=((long long)sz[w[i].v]*sz[w[i].v])%MOD; sum1%=MOD; sum2%=MOD; &#125; long long ret=((sum1*sum1)%MOD-sum2+(long long)sz[u]*2ll%MOD-1ll)%MOD; printf(\"%lld\\n\",ret); Ans[u]=ret; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树形dp","slug":"树形dp","permalink":"https://gaisaiyuno.github.io/tags/树形dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"比赛","slug":"比赛","permalink":"https://gaisaiyuno.github.io/tags/比赛/"}]},{"title":"圆方树学习笔记","slug":"圆方树学习笔记","date":"2019-07-31T08:35:15.000Z","updated":"2019-07-31T12:25:16.109Z","comments":true,"path":"archives/218474d4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/218474d4.html","excerpt":"","text":"圆方树这个东西咕了好久都没学，今天一看还是比较简单的 先讲一下仙人掌的定义：任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。 放几张图： え、 放错了，不过还是比较形象的（估计就是仙人掌名字的又来吧）： 放一个真·仙人掌： $\\rm from BZOJ 1023$ 我自己画的仙人掌图： 考虑解决仙人掌上面问题，上面的环很讨厌，我们要想一种办法把环缩掉。 当然不能直接上$\\rm tarjan$缩环，因为$\\rm tarjan$会把很多性质破坏掉，比如两点之间距离之类。 考虑把环缩成菊花图： 我们叫原来仙人掌上面的点圆点，新加进的菊花图的中心节点为方点，这样形成一棵圆方树。 （其实圆方树就是这样一个简单的东西，把环萎♂进去形成一个菊花图，网上的很多题解都写复杂了） 为什么不是仙人掌不能建立圆方树？考虑这样一个图： 把它的（伪）圆方树建出来，变成介个样子： 发现这并不是一棵树，因为有环。造成这个环的本质是有一条边在两个环上面都出现了一次。 专业一点来说，对于一条边$$，设它同时存在两个环建立出的两个菊花图的中心节点为$s_1,s_2$，那么必有$u-s_1-v-s_2$这个环。 按照边数排个序：非联通图$&lt;$树（其实是仙人掌）$&lt;$基环树（其实也是仙人掌）$\\le$仙人掌$\\le$非仙人掌的连通图 讲完定义之后，我们来看怎么实现： 静态仙人掌P5236 【模板】静态仙人掌 仙人掌图上面求节点$u$，$v$之间最短路$d$。 先建好一棵圆方树（$\\rm tarjan$实现）： 考虑第一件事，上面标红的那些边边权怎么弄，才不能破坏最短路的性质，也就是说，从红色边上面走相当于从环上面走。 考虑先钦定一个环上面的点$alb$，我们强制经过$alb$，所以从$u$到$v$相当于$u-alb-v$ 具体实现的时候，记录一个$sum$代表边权的前缀和。 考虑第二件事，如何查询两个节点之间最短路？ 设$lca$为$LCA(u,v)$ $1.$$lca$为圆点：$d$为树上$u$，$v$之间距离，即$d=dis(u,v)$ $2.$$lca$为方点：较为复杂，因为方点连出的边不存在，所以不能直接像上面一样搞，设$lca$的儿子中为$u$，$v$两个节点的祖先的两个节点为$a$，$b$，这样说有些复杂，不妨画图理解。 如图，$lca$往$a$，$b$连的两条边是不存在的，所以不能经过，所以只能从$u$向上跳到$a$，然后在环上面走一段路程到$b$，最后从$b$往下跳到$v$，所以$d=dis(u,a)+dis(a,b)+dis(b,v)$ 注意：在环上面走有两种走法，不能忘记 实现起来还是有点细节的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;#define MAXN 40005#define MAXM 23using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G1[MAXN],G2[MAXN];//G1为原图，G2为圆方树inline void _AddEdge1(int u,int v,int w)&#123; G1[u].push_back(Edge&#123;v,w&#125;);&#125;inline void AddEdge1(int u,int v,int w)&#123; _AddEdge1(u,v,w),_AddEdge1(v,u,w);&#125;inline void _AddEdge2(int u,int v,int w)&#123; G2[u].push_back(Edge&#123;v,w&#125;);&#125;inline void AddEdge2(int u,int v,int w)&#123; _AddEdge2(u,v,w),_AddEdge2(v,u,w);&#125;namespace Lca&#123; int anc[MAXN][MAXM],dis[MAXN],dep[MAXN]; void dfs(int u,int father)&#123; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i)&#123; anc[u][i]=anc[anc[u][i-1]][i-1]; &#125; for (register int i=0;i&lt;G2[u].size();++i)&#123; int v=G2[u][i].to,w=G2[u][i].len; if (v!=father)&#123; dep[v]=dep[u]+1; dis[v]=dis[u]+w; dfs(v,u); &#125; &#125; &#125; inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v)&#123; return v; &#125; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i]; v=anc[v][i]; &#125; &#125; return anc[u][0]; &#125; inline int Jump(int u,int lca)&#123;//H♂p for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;dep[lca])&#123; u=anc[u][i]; &#125; &#125; return u; &#125; inline int Dis(int u,int v)&#123; return dis[u]+dis[v]-dis[LCA(u,v)]*2; &#125;&#125;using namespace Lca;int square;//方点int sum[MAXN];//一个类似于前缀和的东西，求环上边权的时候可以方便地相减得出答案namespace RS_Tree&#123;//Round Square Tree ??? int dfn[MAXN],low[MAXN],cnt,fa[MAXN],tofa[MAXN]; void tarjan(int u,int father)&#123; dfn[u]=low[u]=++cnt; for (register int i=0;i&lt;G1[u].size();++i)&#123; int v=G1[u][i].to,w=G1[u][i].len; if (v!=father)&#123; if (!dfn[v])&#123;fa[v]=u;tofa[v]=w;tarjan(v,u);low[u]=min(low[u],low[v]);&#125; else&#123;low[u]=min(low[u],dfn[v]);&#125; if (low[v]&lt;=dfn[u]) continue; AddEdge2(u,v,w);//原来的仙人掌上面边不在环里面的边要保留 &#125; &#125; for (register int i=0;i&lt;G1[u].size();++i)&#123; int v=G1[u][i].to; if (fa[v]==u||dfn[v]&lt;=dfn[u]) continue; //找到非树边 ++square;//新建方点 int s=G1[u][i].len,t=v; while (t!=fa[u])&#123;//在环上面绕圈圈 sum[t]=s; s+=tofa[t]; t=fa[t]; &#125; sum[square]=sum[u];sum[u]=0; //求出整个圈上面边权之和，u多算了，所以设成0 //为什么记录sum[square]哪？往下看 t=v; while (t!=fa[u])&#123; AddEdge2(t,square,min(sum[t],sum[square]-sum[t]));//加上不存在的边 //其实就是把环上走的一大堆路程压到一条边上面 //可以往前面绕，也可以后面绕，所以取一个min t=fa[t]; &#125; &#125; &#125;&#125;using namespace RS_Tree;int n,m;int main()&#123; n=read(),m=read(); int q=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),w=read(); AddEdge1(u,v,w); &#125; square=n; tarjan(1,0); dfs(1,1); while (q--)&#123; int u=read(),v=read(); int lca=LCA(u,v); if (lca&lt;=n)&#123;//圆点 printf(\"%d\\n\",Dis(u,v)); &#125; else &#123;//方点 int A=Jump(u,lca),B=Jump(v,lca);//前面说的a,b int ans=Dis(u,A)+Dis(B,v); if (sum[A]&lt;sum[B]) swap(A,B);//避免负数（不知道alb在A,B的哪里） printf(\"%d\\n\",ans+min(sum[A]-sum[B],sum[lca]+sum[B]-sum[A])); //直接调用sum[lca]体现出记录sum[square]的好处 &#125; &#125;&#125; 倍增写的，跑的比较慢。 Link-Cut Cactus咕咕 （我连LCT都不会哪）","categories":[],"tags":[{"name":"tarjan","slug":"tarjan","permalink":"https://gaisaiyuno.github.io/tags/tarjan/"},{"name":"仙人掌","slug":"仙人掌","permalink":"https://gaisaiyuno.github.io/tags/仙人掌/"},{"name":"圆方树","slug":"圆方树","permalink":"https://gaisaiyuno.github.io/tags/圆方树/"}]},{"title":"P1712 [NOI2016]区间","slug":"P1712-NOI2016-区间","date":"2019-07-31T03:59:19.000Z","updated":"2019-07-31T04:23:32.014Z","comments":true,"path":"archives/a1ea28df.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a1ea28df.html","excerpt":"","text":"传送门 考虑把所有线段按照长度排序，在排好序的序列上面跑尺取法，设尺取法维护的区间为$[pl,pr]$，一直移动右端点$pr$，直到现在有一个点在区间$[pl,pr]$代表的线段上面出现$&gt;=m$次，停止移动右端点，开始移动左端点，直到没有点在区间$[pl,pr]$代表的线段上面出现$&gt;=m$次，在这个过程中统计答案即可。 具体实现时，先把线段离散化，再搞一棵支持区间加，区间查询最大值的线段树即可。 注意：数组开大一点，更新答案时不能用离散化后的$l,r$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=max(tree[lc].val,tree[rc].val); &#125; inline void Change(int i,int val)&#123; tree[i].tag+=val; tree[i].val+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].val=tree[i].tag=0; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-0x7fffffff; pushdown(i); if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;struct Segment&#123; int l,r,len;&#125;p[MAXN];inline bool operator &lt; (Segment A,Segment B)&#123; return A.len&lt;B.len;&#125;int n,m;int num[MAXN&lt;&lt;1],cnt,maxn;inline void discrete()&#123; sort(num+1,num+1+cnt); cnt=unique(num+1,num+1+cnt)-num-1; for (register int i=1;i&lt;=n;++i)&#123; p[i].l=lower_bound(num+1,num+1+cnt,p[i].l)-num; p[i].r=lower_bound(num+1,num+1+cnt,p[i].r)-num; maxn=max(maxn,p[i].l); maxn=max(maxn,p[i].r); &#125;&#125;int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; int l=read(),r=read(); p[i]=Segment&#123;l,r,r-l&#125;; num[++cnt]=l,num[++cnt]=r; &#125; discrete(); sort(p+1,p+1+n); int ans=0x7fffffff; int pl=1,pr=0; Build(1,1,maxn); while (true)&#123; while (pr&lt;=n)&#123; if (Query(1,1,maxn)&gt;=m) break; pr++; Update(1,p[pr].l,p[pr].r,1); &#125; if (Query(1,1,maxn)&lt;m) break; while (pl&lt;=pr)&#123; if (Query(1,1,maxn)&lt;m) break; ans=min(ans,p[pr].len-p[pl].len); Update(1,p[pl].l,p[pl].r,-1); pl++; &#125; &#125; printf(\"%d\\n\",ans==0x7fffffff?-1:ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"尺取法","slug":"尺取法","permalink":"https://gaisaiyuno.github.io/tags/尺取法/"}]},{"title":"P1325 雷达安装","slug":"P1325-雷达安装","date":"2019-07-31T02:22:13.000Z","updated":"2019-07-31T04:22:10.253Z","comments":true,"path":"archives/baa544d4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/baa544d4.html","excerpt":"","text":"传送门 考虑只有一个点，一个雷达的时候，雷达在哪个区间才可以覆盖住这个点， 设$dis=\\sqrt{d^2-y^2}$，发现只有在区间$[x-dis,x+dis]$才能覆盖住点$(x,y)$，也就是说在$[x-dis,x+dis]$要至少有一个雷达。 于是题目转换成线段覆盖问题：给你一个数轴和一大堆线段，让你往数轴上面放点，要求每一个线段上面都至少有一个点。 这个问题可以贪心解决，把那些线段按照右端点排序，每次选点都是选右端点，这样为什么是正确的呢？ 考虑分情况讨论： 1.$l2 \\le r1$ 这种情况就不用再新增一个点，因为按照右端点排序保证了$r1 \\le r2$，所以$l2 \\le r1 \\le r2$，所以选的点$r1$在区间$[l2,r2]$之内。 2.$l2 &gt; r1$ 这种情况再怎么样也是要新增一个点的，所以$ans++$ 具体实现的时候，维护一个$now$的指针，表示现在已经覆盖到哪里了。 注意$y&gt;d$的时候要输出$-1$ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct node&#123;double l,r;&#125;p[MAXN];inline bool operator &lt; (const node &amp;A,const node &amp;B)&#123; return A.r&lt;B.r;&#125;int main()&#123; int n=read(),d=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(),y=read(); if ((double)y&gt;d)&#123; printf(\"-1\\n\"); return 0; &#125; const double dis=sqrt(d*d-y*y); p[i].l=(double)(x)-dis; p[i].r=(double)(x)+dis; &#125; sort(p+1,p+1+n); double now=p[1].r;int ans=1; for (register int i=2;i&lt;=n;++i)&#123; if (now&lt;p[i].l)&#123; ans++,now=p[i].r; &#125; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"贪心","slug":"贪心","permalink":"https://gaisaiyuno.github.io/tags/贪心/"}]},{"title":"SP1296 SUMFOUR - 4 values whose sum is 0","slug":"SP1296-SUMFOUR-4-values-whose-sum-is-0","date":"2019-07-31T00:56:41.000Z","updated":"2019-07-31T04:24:38.824Z","comments":true,"path":"archives/e606560d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e606560d.html","excerpt":"","text":"传送门 考虑把$A+B+C+D=0$转换成$-A-B=C+D$，于是预处理出$C+D$的数组，sort一遍以后二分查找即可。 时间复杂度$O(n^2\\log (n^2))$（反正不会爆就是了） 我以前写的代码，码风可能有点清奇。 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int A[4005], B[4005], C[4005], D[4005];int SumCD[4005 * 4005];int main()&#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d%d%d\", &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; SumCD[i + j * n] = C[i] + D[j]; &#125; &#125; sort(SumCD, SumCD + n * n); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int find = A[i] + B[j]; ans += upper_bound(SumCD, SumCD + n * n, -find) - lower_bound(SumCD, SumCD + n * n, -find); &#125; &#125; printf(\"%d\\n\", ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"二分","slug":"二分","permalink":"https://gaisaiyuno.github.io/tags/二分/"}]},{"title":"P2572 BZOJ1858 [SCOI2010]序列操作 ","slug":"P2572-BZOJ1858-SCOI2010-序列操作","date":"2019-07-30T11:56:18.000Z","updated":"2019-07-30T12:20:07.981Z","comments":true,"path":"archives/a1d81cba.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a1d81cba.html","excerpt":"","text":"洛谷 BZOJ 线段树维护，每个节点上面记录$6$个值$l0,l1,r0,r1,m0,m1$（套路），代表从左开始最长$0$的序列长度，最长$1$的序列的长度，从右开始的……，中间的……（懒） 翻转就是把他们两两交换，$\\rm pushup$也都是套路。 注意覆盖标记比翻转标记优先级高，于是区间覆盖的时候会把翻转标记设成$0$，$\\rm pushdown$的时候也是先判断区间覆盖标记。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int l0,r0,l1,r1,m0,m1; int sum,tag; bool rev; inline int len()&#123;return r-l+1;&#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void Rev(int i)&#123; tree[i].sum=tree[i].len()-tree[i].sum; swap(tree[i].l0,tree[i].l1); swap(tree[i].r0,tree[i].r1); swap(tree[i].m0,tree[i].m1); tree[i].rev^=1; &#125; inline void Cover(int i,int val)&#123; tree[i].tag=val; tree[i].sum=val*tree[i].len(); tree[i].l0=tree[i].r0=tree[i].m0=(1-val)*tree[i].len(); tree[i].r1=tree[i].l1=tree[i].m1=val*tree[i].len(); tree[i].rev=0; &#125; inline void pushdown(int i)&#123; if (tree[i].l==tree[i].r) return ; if (tree[i].tag!=-1)&#123; Cover(lc,tree[i].tag),Cover(rc,tree[i].tag); tree[i].tag=-1; &#125; if (tree[i].rev)&#123; Rev(lc),Rev(rc); tree[i].rev=0; &#125; &#125; node operator + (node a,node b)&#123; node c; c.l=a.l,c.r=b.r; c.l0=a.l0; if (a.sum==0) c.l0=max(c.l0,a.len()+b.l0); c.l1=a.l1; if (a.sum==a.len()) c.l1=max(c.l1,a.len()+b.l1); c.r0=b.r0; if (b.sum==0) c.r0=max(c.r0,b.len()+a.r0); c.r1=b.r1; if (b.sum==b.len()) c.r1=max(c.r1,b.len()+a.r1); c.m0=max(max(a.m0,b.m0),a.r0+b.l0); c.m1=max(max(a.m1,b.m1),a.r1+b.l1); c.sum=a.sum+b.sum; return c; &#125; inline void pushup(int i)&#123; int temp1=tree[i].rev,temp2=tree[i].tag; tree[i]=tree[lc]+tree[rc]; tree[i].rev=temp1,tree[i].tag=temp2; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].tag=-1; if (l==r)&#123; Cover(i,a[l]); return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Cover(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; void Reverse(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Rev(i); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Reverse(lc,L,R); if (mid&lt;R) Reverse(rc,L,R); pushup(i); &#125; int QuerySum(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].sum; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; pushdown(i); if (L&lt;=mid) ans+=QuerySum(lc,L,R); if (mid&lt;R) ans+=QuerySum(rc,L,R); return ans; &#125; node QueryMax(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i]; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (mid&gt;=R) return QueryMax(lc,L,R); else if (L&gt;mid) return QueryMax(rc,L,R); else return QueryMax(lc,L,R)+QueryMax(rc,L,R); &#125;&#125;using namespace SegmentTree;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,1,n); while (m--)&#123; int opr=read(),l=read()+1,r=read()+1; if (opr==0) Update(1,l,r,0); if (opr==1) Update(1,l,r,1); if (opr==2) Reverse(1,l,r); if (opr==3) printf(\"%d\\n\",QuerySum(1,l,r)); if (opr==4) printf(\"%d\\n\",QueryMax(1,l,r).m1); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"P2146 [NOI2015]软件包管理器","slug":"P2146-NOI2015-软件包管理器","date":"2019-07-30T07:09:55.000Z","updated":"2019-07-30T12:20:07.980Z","comments":true,"path":"archives/a2eb6ca4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/a2eb6ca4.html","excerpt":"","text":"传送门 安装操作其实就是把这个节点及其祖先节点变成$1$，卸载操作其实就是把这个节点及其子树之内的所有节点变成$0$ 树链剖分实现即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 100005using namespace std;vector&lt;int&gt; G[MAXN];char cmd[10];int fa[MAXN], size[MAXN], Bigson[MAXN], top[MAXN], id[MAXN], dep[MAXN];int cnt;int fro[MAXN], bac[MAXN];void dfs(int u, int father)&#123; size[u] = 1; Bigson[u] = 0; dep[u] = dep[father] + 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; if (G[u][i] != father) &#123; fa[G[u][i]] = u; dfs(G[u][i], u); size[u] += size[G[u][i]]; if (size[G[u][i]] &gt; size[Bigson[u]]) &#123; Bigson[u] = G[u][i]; &#125; &#125; &#125;&#125;void dfs2(int u, int Top)&#123; top[u] = Top; id[u] = ++cnt; fro[cnt] = u; if (Bigson[u]) &#123; dfs2(Bigson[u], Top); &#125; for (int i = 0; i &lt; G[u].size(); i++) &#123; if (G[u][i] != fa[u] &amp;&amp; G[u][i] != Bigson[u]) &#123; dfs2(G[u][i], G[u][i]); &#125; &#125;&#125;struct SegmentTree&#123; struct node &#123; int l, r; int val, tag; &#125; tree[MAXN &lt;&lt; 2]; void pushup(int i) &#123; tree[i].val = tree[i &lt;&lt; 1].val + tree[i &lt;&lt; 1 | 1].val; &#125; void pushdown(int i) &#123; if (tree[i].tag != -1) &#123; tree[i &lt;&lt; 1].tag = tree[i &lt;&lt; 1 | 1].tag = tree[i].tag; tree[i &lt;&lt; 1].val = tree[i].tag * (tree[i &lt;&lt; 1].r - tree[i &lt;&lt; 1].l + 1); tree[i &lt;&lt; 1 | 1].val = tree[i].tag * (tree[i &lt;&lt; 1 | 1].r - tree[i &lt;&lt; 1 | 1].l + 1); tree[i].tag = -1; &#125; &#125; void build(int l, int r, int i) &#123; tree[i].l = l; tree[i].r = r; tree[i].val = 0; tree[i].tag = -1; if (l == r) &#123; return; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, i &lt;&lt; 1); build(mid + 1, r, i &lt;&lt; 1 | 1); &#125; void update(int L, int R, int i, int v) &#123; int l = tree[i].l, r = tree[i].r; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; tree[i].val = v * (r - l + 1); tree[i].tag = v; return; &#125; pushdown(i); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) &#123; update(L, R, i &lt;&lt; 1, v); &#125; if (mid &lt; R) &#123; update(L, R, i &lt;&lt; 1 | 1, v); &#125; pushup(i); &#125;&#125; Seg;void update_tree(int u, int v)&#123; int topu = top[u]; int topv = top[v]; while (topu != topv) &#123; if (dep[topu] &lt; dep[topv]) &#123; swap(u, v); swap(topu, topv); &#125; Seg.update(id[topu], id[u], 1, 1); u = fa[topu]; topu = top[u]; &#125; if (dep[u] &gt; dep[v]) &#123; swap(u, v); &#125; Seg.update(id[u], id[v], 1, 1);&#125;int Myabs(int a, int b)&#123; return (a - b &gt; 0) ? a - b : b - a;&#125;int main()&#123; int n; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; int k; scanf(\"%d\", &amp;k); G[++k].push_back(i); G[i].push_back(k); &#125; dfs(1, 1); dfs2(1, 1); Seg.build(1, n, 1); int q; scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%s\", cmd); int Sum = Seg.tree[1].val; //初始值 if (cmd[0] == 'i') &#123; int x; scanf(\"%d\", &amp;x); ++x; update_tree(1, x); &#125; else if (cmd[0] == 'u') &#123; int x; scanf(\"%d\", &amp;x); ++x; Seg.update(id[x], id[x] + size[x] - 1, 1, 0); &#125; printf(\"%d\\n\", Myabs(Sum, Seg.tree[1].val)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P1505 [国家集训队]旅游","slug":"P1505-国家集训队-旅游","date":"2019-07-30T06:44:27.000Z","updated":"2019-07-30T12:20:07.976Z","comments":true,"path":"archives/19e57ca5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/19e57ca5.html","excerpt":"","text":"传送门 线段树实现区间查询最大值，查询最小值，查询和，区间$-1$，前面$3$种都没有什么好讲的，最后一种就是把区间和$-1$，最小值，最大值交换以后$*-1$ 注意：下标从$0$开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAXN 30005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return x*f;&#125;struct edge&#123; int to,cost;&#125;;vector&lt;edge&gt;G[MAXN];inline void add_edge(int u,int v,int w)&#123; edge temp; temp.to=v; temp.cost=w; G[u].push_back(temp);&#125;int value[MAXN],size[MAXN],fa[MAXN],dep[MAXN],top[MAXN],id[MAXN],Bigson[MAXN];int cnt;int tofa[MAXN],pre[MAXN];void dfs(int u,int father)&#123; size[u]=1; dep[u]=dep[father]+1; for (register int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int w=G[u][i].cost; if (v!=father)&#123; fa[v]=u; dfs(v,u); tofa[v]=w; size[u]+=size[v]; if (size[v]&gt;size[Bigson[u]])&#123; Bigson[u]=v; &#125; &#125; &#125;&#125;void dfs2(int u,int Top)&#123; top[u]=Top; pre[id[u]=++cnt]=u; if (Bigson[u])&#123; dfs2(Bigson[u],Top); &#125; for (register int i=0;i&lt;G[u].size();i++)&#123; if (G[u][i].to!=fa[u]&amp;&amp;G[u][i].to!=Bigson[u])&#123; dfs2(G[u][i].to,G[u][i].to); &#125; &#125;&#125;#define lc i&lt;&lt;1#define rc i&lt;&lt;1|1struct SegmentTree&#123; struct node&#123; int l,r; int sum,revtag;//tag==-1需要变成相反数 int maxval,minval; &#125;tree[MAXN&lt;&lt;2]; inline void Swap(int i)&#123; swap(tree[i].maxval,tree[i].minval); tree[i].maxval*=-1,tree[i].minval*=-1; &#125; inline void pushdown(int i)&#123; if (tree[i].revtag==-1)&#123; tree[lc].revtag*=-1; tree[rc].revtag*=-1; tree[lc].sum=-tree[lc].sum; tree[rc].sum=-tree[rc].sum; Swap(lc),Swap(rc); tree[i].revtag=1; &#125; &#125; inline void pushup(int i)&#123; tree[i].sum=tree[lc].sum+tree[rc].sum; tree[i].maxval=max(tree[lc].maxval,tree[rc].maxval); tree[i].minval=min(tree[lc].minval,tree[rc].minval); &#125; void build(int l,int r,int i)&#123; tree[i].l=l,tree[i].r=r; tree[i].revtag=1; if (l==r)&#123; tree[i].maxval=tree[i].minval=tree[i].sum=tofa[pre[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,lc); build(mid+1,r,rc); pushup(i); &#125; void update_pos(int pos,int v,int i)&#123; int l=tree[i].l,r=tree[i].r; if (l==r)&#123; tree[i].sum=tree[i].maxval=tree[i].minval=v; return ; &#125; pushdown(i); int mid=(l+r)&gt;&gt;1; if (pos&lt;=mid) update_pos(pos,v,lc); else update_pos(pos,v,rc); pushup(i); &#125; void rever(int L,int R,int i)&#123; int l=tree[i].l,r=tree[i].r; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; tree[i].sum*=-1; Swap(i); tree[i].revtag*=-1; return ; &#125; pushdown(i); int mid=(l+r)&gt;&gt;1; if (L&lt;=mid) rever(L,R,lc); if (mid&lt;R) rever(L,R,rc); pushup(i); &#125; int query_sum(int L,int R,int i)&#123; int l=tree[i].l,r=tree[i].r; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].sum; &#125; int mid=(l+r)&gt;&gt;1; int ans=0; pushdown(i); if (L&lt;=mid) ans+=query_sum(L,R,lc); if (mid&lt;R) ans+=query_sum(L,R,rc); return ans; &#125; int query_max(int L,int R,int i)&#123; int l=tree[i].l,r=tree[i].r; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].maxval; &#125; pushdown(i); int mid=(l+r)&gt;&gt;1; int ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,query_max(L,R,lc)); if (mid&lt;R) ans=max(ans,query_max(L,R,rc)); return ans; &#125; int query_min(int L,int R,int i)&#123; int l=tree[i].l,r=tree[i].r; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].minval; &#125; pushdown(i); int mid=(l+r)&gt;&gt;1; int ans=0x7fffffff; if (L&lt;=mid) ans=min(ans,query_min(L,R,lc)); if (mid&lt;R) ans=min(ans,query_min(L,R,rc)); return ans; &#125; #undef lc #undef rc&#125;Seg;inline int query_ans(int u,int v)&#123; int sum=0; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); sum+=Seg.query_sum(id[top[u]],id[u],1); u=fa[top[u]]; &#125; if (u==v) return sum; if (id[u]&gt;id[v]) swap(u,v); sum+=Seg.query_sum(id[u]+1,id[v],1); return sum;&#125;inline int query_maxval(int u,int v)&#123; int maxn=-0x7fffffff; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); maxn=max(maxn,Seg.query_max(id[top[u]],id[u],1)); u=fa[top[u]]; &#125; if (u==v) return maxn; if (id[u]&gt;id[v]) swap(u,v); maxn=max(maxn,Seg.query_max(id[u]+1,id[v],1)); return maxn;&#125;inline int query_minval(int u,int v)&#123; int mino=0x7fffffff; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); mino=min(mino,Seg.query_min(id[top[u]],id[u],1)); u=fa[top[u]]; &#125; if (u==v) return mino; if (id[u]&gt;id[v]) swap(u,v); mino=min(mino,Seg.query_min(id[u]+1,id[v],1)); return mino;&#125;inline void update_tree(int u,int v)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); Seg.rever(id[top[u]],id[u],1); u=fa[top[u]]; &#125; if (u==v) return ; if (id[u]&gt;id[v]) swap(u,v); Seg.rever(id[u]+1,id[v],1);&#125;char str[10];int main()&#123; int n=read(); for (register int i=1;i&lt;n;i++)&#123; int u=read()+1,v=read()+1,w=read(); add_edge(u,v,w); add_edge(v,u,w); &#125; dfs(1,1); dfs2(1,1); Seg.build(1,n,1); int q=read(); while (q--)&#123; scanf(\"%s\",str); if (str[0]=='C')&#123; int v=read()+1,w=read(); Seg.update_pos(id[v],w,1); continue; &#125; int u=read()+1,v=read()+1; if (str[0]=='N')&#123; update_tree(u,v); &#125; else if (str[0]=='S')&#123; printf(\"%d\\n\",query_ans(u,v)); &#125; else if (str[1]=='A')&#123; printf(\"%d\\n\",query_maxval(u,v)); &#125; else if (str[1]=='I')&#123; printf(\"%d\\n\",query_minval(u,v)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"CF735D Taxes","slug":"CF735D-Taxes","date":"2019-07-30T01:16:51.000Z","updated":"2019-07-30T01:30:29.838Z","comments":true,"path":"archives/20ee6331.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/20ee6331.html","excerpt":"","text":"传送门 一道比较有意思的数学题。 首先，根据贪心的原理，最好把$n$全部分成质数。 考虑分类讨论， 1.$n==1$或$n==2$，显然答案是$1$ 2.$n&gt;2$且$n$为偶数，也就是$n \\geq 4$，由哥德巴赫猜想，发现$n$可以分成两个质数之和，所以答案为$2$ 3.$n&gt;2$且$n$为奇数， 还是分成两种情况： a.$n$为质数，答案为$1$， b.$n$不为质数，发现$n$至少为$9$，这样比较好办，先从$n$里面分出一个$3$，剩下的由哥德巴赫猜想可以分成两个质数，答案为$3$ 在具体实现时，发现有更简洁的写法： 123if (isprime(n)) p(1);else if (n%2==0||isprime(n-2)) p(2);else p(3); 也就是把很多情况合起来写罢了。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define p(a) printf(\"%d\\n\",a)using namespace std;inline bool isprime(register int x)&#123; for (register int i=2;i*i&lt;=x;++i)&#123; if (x%i==0)&#123; return false; &#125; &#125; return true;&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); if (isprime(n)) p(1); else if (n%2==0||isprime(n-2)) p(2); else p(3);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"P3674 小清新人渣的本愿","slug":"P3674-小清新人渣的本愿","date":"2019-07-30T00:40:35.000Z","updated":"2019-07-30T01:08:09.982Z","comments":true,"path":"archives/34eac003.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/34eac003.html","excerpt":"","text":"传送门 设现在莫队指针$l,r$维护的区间中不同的数组成的集合为${a_1,a_2,a_3…a_n}$ 我们维护这样一个$\\rm bitset$$s$，对于$a_i$，$s[a_i]=1$ Query1考虑如何实现查询$x-y=n$，发现$x=y+n$，所以对于所有出现在$a$集合中的数$a_i$，查询$a_i+n$在$a$集合中有没有出现即可。 这个可以通过操作$(s \\text{&amp;} (s&lt;&lt;n)).any()$实现，其中$any()$查询$\\rm bitset$中有没有$1$ Query2考虑实现查询$x+y=n$，其实本质和上面一种一样，就是化成$x=-y+n$，再维护一个下标为$-a_i$的$\\rm bitset$$s1$即可，但是这样做会有一个严重的问题，$\\rm bitset$下标不能为负数。 考虑给$-a_i$加上一个很大的正数$N$，这里使用$MAXN-1$ 把$s1$维护的数变为集合$b_i=-a_i+N$，原来的式子化成$x=-y+N+n-N$ 查询的操作转换成查询$b_i+n-N$有没有在$a_i$中出现。 注意到$n-N$为负数，于是左移$n-N$转换成右移$N-n$。 通过操作$(s \\text{&amp;} (s1&gt;&gt;(N-n))).any()$实现。 Query3这个比较简单，将$xy=n$转换成$x=\\frac{n}{y}$，于是$O(\\sqrt{n})$枚举$n$的所有因数即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// luogu-judger-enable-o2//小清新莫队题#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;bitset&lt;MAXN&gt;s,s1;int a[MAXN],cnt[MAXN],pos[MAXN];// #define Add(x) if (cnt[x]++==0) s[x]=1,s1[MAXN-1-x]=1// #define Del(x) if (--cnt[x]==0) s[x]=0,s1[MAXN-1-x]=0inline void Add(int x)&#123; if (cnt[x]++==0) s[x]=1,s1[MAXN-1-x]=1;&#125;inline void Del(int x)&#123; if (--cnt[x]==0) s[x]=0,s1[MAXN-1-x]=0;&#125;struct Query&#123; int opt,l,r,x,id;&#125;q[MAXN];inline bool operator &lt; (const Query &amp;a,const Query &amp;b)&#123; return (pos[a.l]^pos[b.l])?pos[a.l]&lt;pos[b.l]:((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r);&#125;int ans[MAXN];int main()&#123; int n=read(),m=read(); int Size=(int)(sqrt(n)); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pos[i]=(i-1)/Size+1; &#125; for (register int i=1;i&lt;=m;++i)&#123; int opt=read(),l=read(),r=read(),x=read(); q[i]=Query&#123;opt,l,r,x,i&#125;; &#125; sort(q+1,q+1+m); int l=1,r=0; for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(a[l++]); while (l&gt;q[i].l) Add(a[--l]); while (r&gt;q[i].r) Del(a[r--]); while (r&lt;q[i].r) Add(a[++r]); if (q[i].opt==1)&#123; ans[q[i].id]=(s&amp;(s&lt;&lt;(q[i].x))).any(); &#125; else if (q[i].opt==2)&#123; ans[q[i].id]=(s&amp;(s1&gt;&gt;(MAXN-1-q[i].x))).any(); &#125; else if (q[i].opt==3)&#123; for (register int j=1;j*j&lt;=q[i].x;++j)&#123; if (q[i].x%j!=0) continue; if (s[j]&amp;&amp;s[q[i].x/j])&#123; ans[q[i].id]=1; break; &#125; &#125; &#125; &#125; for (register int i=1;i&lt;=m;++i)&#123; puts(ans[i]==1?\"hana\":\"bi\"); &#125;&#125; 最后提一点需要特别注意，不能乱用$\\rm define$，比如说 1#define Add(x) if (cnt[a[x]]) s[a[x]]=true; 调用时 1Add(l++) 其实相当于 1if (cnt[a[l++]]) s[a[l++]]=true 会导致$\\rm WA$","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"bitset","slug":"bitset","permalink":"https://gaisaiyuno.github.io/tags/bitset/"}]},{"title":"P2294 [HNOI2005]狡猾的商人","slug":"P2294-HNOI2005-狡猾的商人","date":"2019-07-28T13:42:46.000Z","updated":"2019-07-30T01:02:36.019Z","comments":true,"path":"archives/caa191db.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/caa191db.html","excerpt":"","text":"传送门 考虑将$s-1$向$t$连一条长度为$v$的边，$t$向$s-1$连一条长度为$-v$的边 先画图分析一下，发现出现如图这样的环，且环上的数之和不为$0$，就是不合法的。 发现如果这样一个环上面的边权之和为正，我们把这样的环上面的所有边取反，就可以得到一个负环。 如果边权之和为负，那么它就是负环。 于是$\\rm SPFA$判断图中是否有负环即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;struct node&#123; int to,len;&#125;;vector&lt;node&gt;G[MAXN];int in[MAXN];void AddEdge(int u,int v,int len)&#123; node temp; temp.to=v; temp.len=len; G[u].push_back(temp);&#125;int vis[MAXN],dis[MAXN];int cnt[MAXN];int n,m;inline int SPFA()&#123; queue&lt;int&gt;Q; for (register int i=0;i&lt;=n;++i)&#123; if (in[i]==0)&#123; vis[i]=1; dis[i]=0; Q.push(i); &#125; &#125; while (Q.size())&#123; int u=Q.front(); Q.pop(); vis[u]=false; if (++cnt[u]==n)&#123; return false; &#125; if (!vis[u])&#123; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; int len=G[u][i].len; if (dis[v]&gt;dis[u]+len)&#123; dis[v]=dis[u]+len; if (!vis[v])&#123; vis[v]=true; Q.push(v); &#125; &#125; &#125; &#125; &#125; return true;&#125;inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; G[i].clear(); &#125; memset(vis,0,sizeof(vis)); memset(cnt,0,sizeof(cnt)); memset(dis,0x3f,sizeof(dis));&#125;int main()&#123; int w=read(); while (w--)&#123; Init(); n=read(),m=read(); while (m--)&#123; int l=read(),r=read(),len=read(); AddEdge(l-1,r,len); AddEdge(r,l-1,-len); in[r]++; &#125; puts(SPFA()?\"true\":\"false\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"SPFA","slug":"SPFA","permalink":"https://gaisaiyuno.github.io/tags/SPFA/"},{"name":"负环","slug":"负环","permalink":"https://gaisaiyuno.github.io/tags/负环/"}]},{"title":"hexo下实现本地备份&&git提交","slug":"hexo下实现本地备份","date":"2019-07-28T10:12:47.000Z","updated":"2019-08-06T12:22:00.856Z","comments":true,"path":"archives/c30e4a1f.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c30e4a1f.html","excerpt":"","text":"hexo这个东西比较容易一魔改就挂掉，于是需要一个本地的备份。 考虑使用7zip进行备份，我们先下载7zip 下载exe文件之后，我们安装，但是我们需要的不是GUI界面的7zip，进入7zip安装文件夹，找到7z.exe。 把7z.exe拷过来，放进HexoBlog文件夹，其中的文件如下： 注意：blog是你的博客文件夹，backups是你的备份文件夹，backup.py是你的备份工具，待会会讲。 backup.py如下，其中source和target_dir是上面所讲的两个文件夹。 time.strftime(‘%Y%m%d%H%M%S’)+’.zip’的意思是生成一个文件名为系统时间的zip压缩包， zip_command就是生成zip文件的命令。 注意-t7z的命令是生成高压缩比7zip文件，对应压缩时间比较久，可以替换为-tzip，生成时间较短，但是生成文件体积较大。 123456789101112131415import osimport timesource = 'D:\\\\HexoBlog\\\\blog'target_dir='D:\\\\HexoBlog\\\\backups\\\\'target=target_dir+time.strftime('%Y%m%d%H%M%S')+'.zip'if not os.path.exists(target_dir): os.mkdir(target_dir)zip_command='7z.exe a -t7z '+target+' '+sourceprint('zip command is:')print(zip_command)if os.system(zip_command)==0: print('Successful backup to',target)else: print('Backup FAILED') 双击运行backup.py，backups文件夹就会出现一个新的备份文件，是不是非常方便。 8/6 upd 骚操作get 后面加一句 1os.system(\"cd backups &amp;&amp; git add . &amp;&amp; git commit -m \\\"backup\\\" &amp;&amp; git push -f origin master\") 即可实现git提交功能","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]},{"title":"GSS题目清单","slug":"GSS题目清单","date":"2019-07-27T14:32:58.000Z","updated":"2019-07-27T14:41:20.884Z","comments":true,"path":"archives/6737b2e7.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/6737b2e7.html","excerpt":"","text":"今天终于把$\\rm GSS$系列的题目刷完了。。。 介绍：$\\rm GSS$是$\\rm SPOJ$上面的毒瘤数据结构题，做完这一个系列能让你水很多黑题 GSS1基础线段树 GSS2基础线段树上面加了一个历史值 GSS3比较水，就是加了一个单点修改而已 GSS4思路比较清奇，就是开一个$flag$优化暴力 GSS5就是分类讨论一下，没了 GSS6FHQ Treap题，就是把GSS1搬到平衡树上面 GSS7树剖裸题 GSS8一道比较有意思的数学题 难度（个人估计） GSS1&lt;GSS3&lt;GSS4&lt;GSS6&lt;GSS5&lt;GSS2&lt;GSS7&lt;GSS8","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"},{"name":"数据结构","slug":"数据结构","permalink":"https://gaisaiyuno.github.io/tags/数据结构/"}]},{"title":"SP19543 GSS8 - Can you answer these queries VIII","slug":"SP19543-GSS8-Can-you-answer-these-queries-VIII","date":"2019-07-27T13:17:01.000Z","updated":"2019-07-27T14:29:14.267Z","comments":true,"path":"archives/3ef91b62.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3ef91b62.html","excerpt":"","text":"传送门 洛谷上面翻译有毒，一是没有数据范围，其实$n \\le 200000$，二是没有样例，这里粘贴一组$\\rm SPOJ$样例，和自己的对拍数据。 $\\rm SPOJ$样例 12345678910111213141516input:41 2 3 57Q 0 2 0I 3 4Q 2 4 1D 0Q 0 3 1R 1 2Q 0 1 0output:626404 我的对拍数据 123456789101112131415161718192021222324252627282930input201574452022 549188900 68567242 1729321800 30592296 1234967064 1540591694 1298547924 1791505596 347980114 142536772 369008392 492229442 883499152 569859698 1891123126 1765828398 540013562 1182847552 1727333276 20R 0 378520004I 0 1564716480D 1R 0 1349444400R 0 1758121648I 0 1716182608Q 1 1 1R 1 2068268798I 1 727687312I 2 1307033320Q 1 2 1I 3 54907522Q 1 3 7R 3 1157040456I 1 379786942Q 2 3 1I 1 1497285546D 4Q 3 4 2D 4output:1758121648334175395234789405433417539521060881840 附送数据生成器（注意生成器要记录一个$cur$代表当前数组的长度，否则删除操作容易搞错）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define ui unsigned intusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;const char op[4]=&#123;'I','D','R','Q'&#125;;inline ui Randui()&#123; return (((rand()&lt;&lt;(ui)15)|(rand()))&lt;&lt;1)|(rand()%2);&#125;int cur;int main()&#123; srand(time(NULL)); freopen(\"gss8.in\",\"w\",stdout); int n=20; printf(\"%d\\n\",n); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%u \",Randui()); &#125; printf(\"\\n\"); int q=20; printf(\"%d\\n\",q); for (register int i=1;i&lt;=q;++i)&#123; int opr=rand()%4; while (cur==0&amp;&amp;opr==1) opr=rand()%4; putchar(op[opr]); putchar(' '); if (opr==0)&#123; printf(\"%d %u\\n\",cur==0?0:rand()%cur+1,Randui()); cur++; &#125; else if (opr==1)&#123; printf(\"%d\\n\",cur==0?0:rand()%cur+1); cur--; &#125; else if (opr==2)&#123; printf(\"%d %u\\n\",cur==0?0:rand()%cur+1,Randui()); &#125; else &#123; int l=(cur==0?0:rand()%cur+1); int r=(cur==0?0:rand()%cur+1); if (l&gt;r) swap(l,r); printf(\"%d %d %d\\n\",l,r,rand()%11); &#125; &#125;&#125; 好了步入正题。 第一步，看见插入和删除操作，立马要条件反射地想到平衡树，这里使用$\\rm FHQ Treap$实现。 第二步，发现$\\rm I,D,R$操作都比较好实现，唯独$\\rm Q$比较烦人，又发现$0 \\le k \\le 10$，就有了思路。 考虑在每个节点上维护一个数组$ans$，其中$ans[k]=\\sum_{i=l}^r A[i] \\times (i-l+1)^k$ 考虑如何维护$ans$ 我们推一推式子： 设整个区间左右端点为$[l,r]$，中间的根节点为$m$，也就是说，根节点代表$[m,m]$，左子树代表$[l,m-1]$，右子树代表$[m+1,r]$，对于所有的$k$，我们要知道所有的$\\sum _{i=l}^r{A[i] \\times (i-l+1)^k}$ 大力拆式子，首先，对于前面的部分$\\sum_{i=l}^{m-1}A[i] \\times (i-l+1)^k$，它其实就是左子树代表的和，直接相加。 （程序里的$i$其实是上面的$k$） 1tree[x].ans[i]=tree[lc(x)].ans[i];//左半部分 接下来的过程中，我们设$s=m-l+1$ 别忘了中间还要一个根节点，就是$A[m] \\times (m-l+1)^k$，即$A[m] \\times s^k$ 1tree[x].ans[i]+=tree[x].val*(ui)Pow[s][i];//中间 最后烦人的是右子树，发现剩下还没消掉的和还有$\\sum _{i=m+1}^r A[i] \\times (i-l+1)^k$， 我们慢慢来，先拆成这个样子：$\\sum _{i=m+1}^r A[i] \\times ((m-l+1)+(i-m))^k$ 于是右边的式子可以用二项式定理展开： 考虑把那个$A[i]$提到里面去，则有： 注意到$A[i]$$(i-m)^{k-j}$其实就是右子树代表的和，所以直接相乘即可。 123for (register int j=0;j&lt;=i;++j)&#123;//右半部分 tree[x].ans[i]+=tree[rc(x)].ans[j]*Pow[s][i-j]*C[i][j];&#125; 注意题目要$\\mod 2^{32}$，我们采用$\\text {unsigned int}$自然溢出来取模。 输出$\\text {unsigned int}$我们使用$\\text{printf(“%u”)}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MAXK 12#define ui unsigned int //因为题目%2^32所以可以用unsigned int自动取模using namespace std;inline int readi() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;inline ui readu()&#123; ui x=0; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*(ui)(10))+(ui)(ch-'0'); ch=getchar(); &#125; return x;&#125;ui C[MAXK][MAXK],Pow[MAXN][MAXK];//pow[i][j] i^jinline void Init()&#123; for (register int i=0;i&lt;MAXK;++i)&#123; C[i][0]=C[i][i]=1; for (register int j=1;j&lt;i;++j)&#123; C[i][j]=C[i-1][j]+C[i-1][j-1]; &#125; &#125; for (register int i=1;i&lt;MAXN;++i)&#123; Pow[i][0]=1; for (register int j=1;j&lt;MAXK;++j)&#123; Pow[i][j]=Pow[i][j-1]*i; &#125; &#125;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int pri; int sz; ui val; ui ans[MAXK];//ans[i]表示sigma l&lt;=i&lt;=r A[i]*(i-l+1)^k &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r //注意fhq treap和线段树不同：根节点不会算 inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; const int s=tree[lc(x)].sz+1; for (register int i=0;i&lt;MAXK;++i)&#123; tree[x].ans[i]=tree[lc(x)].ans[i];//左半部分 tree[x].ans[i]+=tree[x].val*(ui)Pow[s][i];//中间 for (register int j=0;j&lt;=i;++j)&#123;//右半部分 tree[x].ans[i]+=tree[rc(x)].ans[j]*(ui)Pow[s][i-j]*(ui)C[i][j]; &#125; &#125; &#125; inline int New(ui v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; for (register int i=0;i&lt;MAXK;++i)&#123; tree[tot].ans[i]=v; &#125; return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i) &#123; x=y=0; &#125; else &#123; if (tree[lc(i)].sz&gt;=k) &#123;y=i,Split(lc(i),k,x,lc(i));&#125;//在左子树 else &#123;x=i,Split(rc(i),k-tree[lc(i)].sz-1,rc(i),y);&#125;//在右子树 Update(i); &#125; &#125; //以上为FHQ Treap int root,x,y,z; inline void Add(int pos,ui num)&#123;//在pos插入num Split(root,pos,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int pos)&#123;//删除pos处元素 Split(root,pos,x,y); Split(y,1,y,z); root=Merge(x,z); &#125;&#125;;using namespace FHQ_Treap;inline char gc()&#123; char ch=getchar(); while (ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='R'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;signed main()&#123; Init(); srand(time(NULL)); int n=readi(); for (register int i=1;i&lt;=n;++i)&#123; root=Merge(root,New(readu())); &#125; int q=readi(); while (q--)&#123; char opr=gc(); if (opr=='I')&#123; int pos=readi(); ui val=readu(); Add(pos,val); &#125; else if (opr=='D')&#123; int pos=readi(); Del(pos); &#125; else if (opr=='R')&#123; int pos=readi();ui val=readu(); Del(pos),Add(pos,val); &#125; else &#123; int l=readi(),r=readi(),k=readi(); Split(root,r+1,x,z); Split(x,l,x,y); printf(\"%u\\n\",tree[y].ans[k]); root=Merge(Merge(x,y),z); &#125; &#125;&#125; 然后你就把$\\text{GSS}$系列最难的一道题切掉了。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"P3131 [USACO16JAN]子共七Subsequences Summing to Sevens","slug":"P3131-USACO16JAN-子共七Subsequences-Summing-to-Sevens","date":"2019-07-27T07:07:24.000Z","updated":"2019-07-27T08:51:44.768Z","comments":true,"path":"archives/f084de21.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/f084de21.html","excerpt":"","text":"传送门 为什么你们的题解都写得这么长。 考虑前缀和，设$a[i]$的前缀和数组为$sum[i]$，则我们有$\\sum _{i=x} ^y a[i]=sum[y]-sum[x-1]$，因为$\\sum _{i=x} ^y a[i] \\mod 7 = 0$，所以我们有$sum[y]-sum[x-1] \\mod 7= 0$，即$sum[y]$和$sum[x-1]$模$7$同余。 考虑贪心，我们设$last[i]=\\min { j , sum[j] \\mod 7 = i}$，就可以求出模$7$意义下离现在位置$y$最远的$x$，满足$sum[x-1]$和$sum[y]$同余，就可以搞定了。 记得每步都%7，要不然可能会爆$\\rm int$1234567891011121314151617#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;int a[MAXN],last[7];int main()&#123; int n; scanf(\"%d\",&amp;n); for (register int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); memset(last,0x3f,sizeof(last)); int ans=0; for (register int i=1;i&lt;=n;++i)&#123; a[i]=(a[i]+a[i-1])%7; ans=max(ans,i-last[a[i]]); last[a[i]]=min(last[a[i]],i); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"前缀和","slug":"前缀和","permalink":"https://gaisaiyuno.github.io/tags/前缀和/"}]},{"title":"P2420 让我们异或吧","slug":"P2420-让我们异或吧","date":"2019-07-27T06:59:39.000Z","updated":"2019-07-27T08:51:44.764Z","comments":true,"path":"archives/e26ff16a.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e26ff16a.html","excerpt":"","text":"传送门 考虑异或的性质，我们发现两个相同的数放在一起异或就会抵消，所以我们预处理这个节点到根的路径上的所有边的异或和$dis$，查询时发现$lca(u,v)$以上的那部分会抵消，于是答案就是$dis[u]$ $\\rm xor$ $dis[v]$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;int dis[MAXN];void dfs(int u,int father)&#123; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father)&#123; dis[v]=dis[u]^w; dfs(v,u); &#125; &#125;&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); &#125; dfs(1,1); int m=read(); while (m--)&#123; int u=read(),v=read(); printf(\"%d\\n\",dis[u]^dis[v]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"二进制","slug":"二进制","permalink":"https://gaisaiyuno.github.io/tags/二进制/"}]},{"title":"P3038 [USACO11DEC]牧草种植Grass Planting","slug":"P3038-USACO11DEC-牧草种植Grass-Planting","date":"2019-07-26T23:55:05.000Z","updated":"2019-07-27T08:51:44.769Z","comments":true,"path":"archives/ad35bf33.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ad35bf33.html","excerpt":"","text":"传送门 翻译有误，应该是查询$u$到$v$上最大值。 线段树查询最大值和区间$+1$， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;#define MAXN 2000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int sz[MAXN],big[MAXN],fa[MAXN],top[MAXN],dep[MAXN],tofa[MAXN];void dfs1(int u,int father)&#123; fa[u]=father;sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs1(v,u); sz[u]+=sz[v]; if (sz[big[u]]&lt;sz[v]) big[u]=v; &#125; &#125;&#125;int seq[MAXN],cnt;int alb[MAXN];void dfs2(int u,int t)&#123; alb[seq[u]=++cnt]=u; top[u]=t; if (big[u]) dfs2(big[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=fa[u]&amp;&amp;v!=big[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; inline void Change(int i,int val)&#123; tree[i].val+=val*tree[i].len(); tree[i].tag+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r) &#123; tree[i].val=0; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125; void Update(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,1); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R); if (mid&lt;R) Update(rc,L,R); pushup(i); &#125;&#125;using namespace SegmentTree;inline int Query_Chain(int u,int v)&#123; int ans=0; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; ans+=Query(1,seq[top[u]],seq[u]); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); return ans+Query(1,seq[u]+1,seq[v]);&#125;inline void Update_Chain(int u,int v)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; Update(1,seq[top[u]],seq[u]); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); Update(1,seq[u]+1,seq[v]);&#125;inline void Init()&#123; dfs1(1,0); dfs2(1,1);&#125;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); AddEdge(v,u); &#125; Init(); Build(1,1,n); while (m--)&#123; char ch[2]; scanf(\"%s\",ch); int u=read(),v=read(); if (ch[0]=='Q') &#123; printf(\"%d\\n\",Query_Chain(u,v)); &#125; else if (ch[0]=='P')&#123; Update_Chain(u,v); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P3833 [SHOI2012]魔法树","slug":"P3833-SHOI2012-魔法树","date":"2019-07-26T23:51:58.000Z","updated":"2019-07-27T08:51:44.771Z","comments":true,"path":"archives/8387fe69.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8387fe69.html","excerpt":"","text":"传送门 需要一棵支持区间加，区间和查询的线段树 其他没什么好说的，注意开$\\rm long$ $\\rm long$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;#define MAXN 2000005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int sz[MAXN],big[MAXN],fa[MAXN],top[MAXN],dep[MAXN];void dfs1(int u,int father)&#123; fa[u]=father;sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs1(v,u); sz[u]+=sz[v]; if (sz[big[u]]&lt;sz[v]) big[u]=v; &#125; &#125;&#125;int ql[MAXN],qr[MAXN],cnt;void dfs2(int u,int t)&#123; ql[u]=++cnt; top[u]=t; if (big[u]) dfs2(big[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=fa[u]&amp;&amp;v!=big[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; inline void Change(int i,int val)&#123; tree[i].val+=val*tree[i].len(); tree[i].tag+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].val=tree[i].tag=0; if (l==r) &#123; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; pushdown(i); if (L&lt;=mid) ans+=Query(lc,L,R); if (mid&lt;R) ans+=Query(rc,L,R); return ans; &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125;&#125;using namespace SegmentTree;inline void Update_Chain(int u,int v,int w)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; Update(1,ql[top[u]],ql[u],w); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); Update(1,ql[u],ql[v],w);&#125;inline void Init()&#123; dfs1(1,0); dfs2(1,1);&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read()+1,v=read()+1; AddEdge(u,v); AddEdge(v,u); &#125; Init(); Build(1,1,cnt); int m=read(); while (m--)&#123; char ch[2]; scanf(\"%s\",ch); if (ch[0]=='Q') &#123; int u=read()+1; printf(\"%lld\\n\",Query(1,ql[u],ql[u]+sz[u]-1)); &#125; else if (ch[0]=='A')&#123; int u=read()+1,v=read()+1,w=read(); Update_Chain(u,v,w); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P4315 月下“毛景树”","slug":"P4315-月下“毛景树”","date":"2019-07-26T23:45:46.000Z","updated":"2019-07-27T08:51:44.772Z","comments":true,"path":"archives/5ee3982c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5ee3982c.html","excerpt":"","text":"传送门 树链剖分模板题，用支持区间加，区间覆盖，查询区间最大的线段树实现。 注意覆盖标记$cotag$优先级比加标记$tag$要高，所以覆盖时直接设$tag=0$ 需要把$Change$操作转化为顶点$U[k]$和$V[k]$的覆盖操作 其他没什么好说的，注意细节即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 2000005#define HA 19260817#define INF 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Edge&#123;v,w&#125;);&#125;int sz[MAXN],big[MAXN],fa[MAXN],top[MAXN],dep[MAXN],tofa[MAXN];void dfs1(int u,int father)&#123; fa[u]=father;sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; if (v!=father)&#123; dep[v]=dep[u]+1; tofa[v]=G[u][i].len; dfs1(v,u); sz[u]+=sz[v]; if (sz[big[u]]&lt;sz[v]) big[u]=v; &#125; &#125;&#125;int ql[MAXN],alb[MAXN],cnt;void dfs2(int u,int t)&#123; alb[ql[u]=++cnt]=u; top[u]=t; if (big[u]) dfs2(big[u],t); for (register int i=0;i&lt;(int)G[u].size();++i)&#123; int v=G[u][i].to; if (v!=fa[u]&amp;&amp;v!=big[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int maxn,tag,cotag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; inline void Add(int i,int val)&#123; tree[i].maxn+=val; tree[i].tag+=val; &#125; inline void Cover(int i,int val)&#123; tree[i].maxn=val; tree[i].cotag=val; tree[i].tag=0; &#125; inline void pushdown(int i)&#123; if (tree[i].cotag!=HA)&#123; Cover(lc,tree[i].cotag); Cover(rc,tree[i].cotag); tree[i].cotag=HA; &#125; if (tree[i].tag)&#123; Add(lc,tree[i].tag); Add(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].cotag=HA,tree[i].tag=0; if (l==r)&#123; tree[i].maxn=tofa[alb[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-INF; pushdown(i); if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125; void CoverInterval(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Cover(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) CoverInterval(lc,L,R,val); if (mid&lt;R) CoverInterval(rc,L,R,val); pushup(i); &#125; void AddInterval(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Add(i,val); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) AddInterval(lc,L,R,val); if (mid&lt;R) AddInterval(rc,L,R,val); pushup(i); &#125;&#125;using namespace SegmentTree;inline void Add_Chain(int u,int v,int w)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; AddInterval(1,ql[top[u]],ql[u],w); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); AddInterval(1,ql[u]+1,ql[v],w);&#125;inline void Cover_Chain(int u,int v,int w)&#123; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; CoverInterval(1,ql[top[u]],ql[u],w); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); CoverInterval(1,ql[u]+1,ql[v],w);&#125;inline int Query_Chain(int u,int v)&#123; int ans=-INF; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; ans=max(ans,Query(1,ql[top[u]],ql[u])); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); return max(ans,Query(1,ql[u]+1,ql[v]));&#125;int U[MAXN],V[MAXN];inline void Init()&#123; dfs1(1,0); dfs2(1,1);&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); U[i]=u,V[i]=v; &#125; Init(); Build(1,1,n); while (true)&#123; char ch[10]; scanf(\"%s\",ch); if (ch[0]=='C'&amp;&amp;ch[1]=='h')&#123; int k=read(),w=read(); Cover_Chain(U[k],V[k],w); &#125; else if (ch[0]=='C'&amp;&amp;ch[1]=='o')&#123; int u=read(),v=read(),w=read(); Cover_Chain(u,v,w); &#125; else if (ch[0]=='A')&#123; int u=read(),v=read(),w=read(); Add_Chain(u,v,w); &#125; else if (ch[0]=='M')&#123; int u=read(),v=read(); printf(\"%d\\n\",Query_Chain(u,v)); &#125; else &#123; break; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"P4085 [USACO17DEC]Haybale Feast","slug":"P4085-USACO17DEC-Haybale-Feast","date":"2019-07-25T05:39:39.000Z","updated":"2019-07-25T05:48:15.352Z","comments":true,"path":"archives/4e7e1605.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4e7e1605.html","excerpt":"","text":"传送门 考虑尺取法求出所有满足条件的$i,j$，使$\\sum ^j _{k=i}F_k&gt;=M$，$O(n)$即可求出。 再考虑如何求$\\max(S_i,S_{i+1},…S_{j-1},S_j)$ 用线段树预处理即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long long#define MAXN 100005using namespace std;ll S[MAXN],F[MAXN];inline void lread(ll &amp;x)&#123; ll f=1ll; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1ll; ch=getchar(); &#125; x=0; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=(x&lt;&lt;3ll)+(x&lt;&lt;1ll)+(ll)(ch-'0'); ch=getchar(); &#125; x*=f;&#125;struct SegmentTree&#123; struct node&#123; int l,r; ll val; &#125;tree[MAXN&lt;&lt;2]; inline void pushup(int i)&#123; tree[i].val=max(tree[i&lt;&lt;1].val,tree[i&lt;&lt;1|1].val); &#125; void build(int l,int r,int i)&#123; tree[i].l=l; tree[i].r=r; if (l==r)&#123; tree[i].val=S[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,i&lt;&lt;1); build(mid+1,r,i&lt;&lt;1|1); pushup(i); &#125; ll query(int L,int R,int i)&#123; int l=tree[i].l,r=tree[i].r; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].val; &#125; int mid=(l+r)&gt;&gt;1; ll ans=-0x7fffffff; if (L&lt;=mid)&#123; ans=max(ans,query(L,R,i&lt;&lt;1)); &#125; if (mid&lt;R)&#123; ans=max(ans,query(L,R,i&lt;&lt;1|1)); &#125; return ans; &#125;&#125;Seg;int main()&#123;// freopen(\"hayfeast.in\",\"r\",stdin);// freopen(\"hayfeast.out\",\"w\",stdout); int n; ll m; scanf(\"%d%lld\",&amp;n,&amp;m); for (register int i=1;i&lt;=n;++i)&#123; lread(F[i]),lread(S[i]); &#125; Seg.build(1,n,1); int l=1,r=1; ll sum=F[1],ans=0x7fffffff; while (l&lt;=n&amp;&amp;r&lt;=n)&#123; while (r&lt;=n&amp;&amp;sum&lt;m)&#123; sum+=F[++r]; &#125; while (r&lt;=n)&#123; sum+=F[++r]; ll val=Seg.query(l,r,1); if (val&gt;=ans)&#123;break;&#125; else&#123;ans=val;&#125; &#125; while (l&lt;=r&amp;&amp;sum&gt;=m)&#123; sum-=F[l++]; &#125; &#125; printf(\"%lld\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"尺取法","slug":"尺取法","permalink":"https://gaisaiyuno.github.io/tags/尺取法/"}]},{"title":"P4089 [USACO17DEC]The Bovine Shuffle","slug":"P4089-USACO17DEC-The-Bovine-Shuffle","date":"2019-07-25T05:32:06.000Z","updated":"2019-07-25T05:36:37.483Z","comments":true,"path":"archives/e6c26dfa.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e6c26dfa.html","excerpt":"","text":"传送门 将$i$与$a_i$连边，发现在一个环上的牛永远不会消失，总是在绕圈圈，所以问题转换为求这个图里面所有环的长度之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MOD#define MAXN 100005#define MAXM#define LL long long#define ll long long#define mem(a) memset(a,0,sizeof(a))#define memmax(a) memset(a,0x3f,sizeof(a))//#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int to[MAXN],in[MAXN],vis[MAXN],vis2[MAXN];void dfs(int u)&#123; vis[u]=true; if (--in[to[u]]==0)&#123; dfs(to[u]); &#125;&#125;int dp[MAXN];void dfs2(int u)&#123; if (vis2[u])&#123; dp[u]=0; return ; &#125; vis2[u]=true; dfs2(to[u]); dp[u]=dp[to[u]]+1;&#125;//#undef intint main()&#123;//#define int long long int n; scanf(\"%d\",&amp;n); for (register int i=1;i&lt;=n;++i)&#123; to[i]=read(); ++in[to[i]]; &#125; for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i]&amp;&amp;!in[i])&#123; dfs(i); &#125; &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (!vis[i]&amp;&amp;!vis2[i])&#123; dfs2(i); ans+=dp[i]; &#125; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"}]},{"title":"P4392 [BOI2007]Sound 静音问题","slug":"P4392-BOI2007-Sound-静音问题","date":"2019-07-25T05:26:36.000Z","updated":"2019-07-25T05:28:04.617Z","comments":true,"path":"archives/ade5d163.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ade5d163.html","excerpt":"","text":"传送门 线段树模板题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (x=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int maxn,mino; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); tree[i].mino=min(tree[lc].mino,tree[rc].mino); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].maxn=tree[i].mino=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; int QueryMax(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; int ans=-0x7fffffff; if (L&lt;=mid) ans=max(ans,QueryMax(lc,L,R)); if (mid&lt;R) ans=max(ans,QueryMax(rc,L,R)); return ans; &#125; int QueryMin(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].mino; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; int ans=0x7fffffff; if (L&lt;=mid) ans=min(ans,QueryMin(lc,L,R)); if (mid&lt;R) ans=min(ans,QueryMin(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;int main()&#123; int n=read(),m=read(),c=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); Build(1,1,n); bool flag=false; for (register int i=1;i&lt;=n-m+1;++i)&#123; int Max=QueryMax(1,i,i+m-1),Min=QueryMin(1,i,i+m-1); if (Max-Min&lt;=c)&#123; printf(\"%d\\n\",i); flag=true; &#125; &#125; if (!flag) printf(\"NONE\\n\");&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"P3313 [SDOI2014]旅行","slug":"P3313-SDOI2014-旅行","date":"2019-07-25T03:01:30.000Z","updated":"2019-07-25T03:08:06.337Z","comments":true,"path":"archives/e1f4368d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e1f4368d.html","excerpt":"","text":"传送门 考虑每个宗教建立一棵线段树，但是空间会炸，考虑动态开点。 时间复杂度$O(n \\log n)$，空间复杂度$O(n \\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); &#125; return x*f;&#125;inline void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;vector&lt;int&gt;G[MAXN];int value[MAXN],size[MAXN],fa[MAXN],dep[MAXN],top[MAXN],id[MAXN],Bigson[MAXN];int root[MAXN],cnt;void dfs(int u,int father)&#123; fa[u]=father; size[u]=1; Bigson[u]=0; dep[u]=dep[father]+1; for (register int i=0;i&lt;G[u].size();++i)&#123; if (G[u][i]!=father)&#123; dfs(G[u][i],u); size[u]+=size[G[u][i]]; if (Bigson[u]==0||size[G[u][i]]&gt;size[Bigson[u]])&#123; Bigson[u]=G[u][i]; &#125; &#125; &#125;&#125;void dfs2(int u,int Top)&#123; top[u]=Top; id[u]=++cnt; if (!Bigson[u])&#123; return ; &#125; dfs2(Bigson[u],Top); for (register int i=0;i&lt;G[u].size();++i)&#123; if (G[u][i]!=fa[u]&amp;&amp;G[u][i]!=Bigson[u])&#123; dfs2(G[u][i],G[u][i]); &#125; &#125;&#125;struct SegmentTree&#123; struct node&#123; int l,r; int maxn,sum; &#125;tree[MAXN&lt;&lt;5]; #define lc tree[i].l #define rc tree[i].r int tot_node; SegmentTree()&#123; tot_node=0; &#125; void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); tree[i].sum=tree[lc].sum+tree[rc].sum; &#125; void update(int &amp;i,int L,int R,int pos,int val)&#123; if (!i) i=++tot_node; if (L==R)&#123; tree[i].maxn=tree[i].sum=val; return ; &#125; int mid=(L+R)&gt;&gt;1; if (pos&lt;=mid) update(lc,L,mid,pos,val); else update(rc,mid+1,R,pos,val); pushup(i); &#125; int query_max(int i,int qL,int qR,int L,int R)&#123; if (qL&lt;=L&amp;&amp;R&lt;=qR)&#123; return tree[i].maxn; &#125; int mid=(L+R)&gt;&gt;1; int ans=-0x7fffffff; if (qL&lt;=mid) ans=max(ans,query_max(lc,qL,qR,L,mid)); if (mid&lt;qR) ans=max(ans,query_max(rc,qL,qR,mid+1,R)); return ans; &#125; int query_sum(int i,int qL,int qR,int L,int R)&#123; if (qL&lt;=L&amp;&amp;R&lt;=qR)&#123; return tree[i].sum; &#125; int mid=(L+R)&gt;&gt;1,ans=0; if (qL&lt;=mid) ans+=query_sum(lc,qL,qR,L,mid); if (mid&lt;qR) ans+=query_sum(rc,qL,qR,mid+1,R); return ans; &#125; #undef lc #undef rc&#125;Seg;int w[MAXN],c[MAXN],n;inline int query_ans(int u,int v,int type)&#123;//type==0 sum type==1 max int color=c[u]; int sum=0,maxval=-0x7fffffff; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; if (type==0)&#123; sum+=Seg.query_sum(root[color],id[top[u]],id[u],1,cnt); &#125; else &#123; maxval=max(maxval,Seg.query_max(root[color],id[top[u]],id[u],1,cnt)); &#125; u=fa[top[u]]; &#125; if (id[u]&gt;id[v])&#123; swap(u,v); &#125; if (type==0)&#123; sum+=Seg.query_sum(root[color],id[u],id[v],1,cnt); return sum; &#125; else &#123; maxval=max(maxval,Seg.query_max(root[color],id[u],id[v],1,cnt)); return maxval; &#125;&#125;int main()&#123; int q; n=read(),q=read(); for (register int i=1;i&lt;=n;++i)&#123; w[i]=read(),c[i]=read(); &#125; for (register int i=1;i&lt;n;++i)&#123; int u,v; u=read(),v=read(); G[u].push_back(v),G[v].push_back(u); &#125; dfs(1,1),dfs2(1,1); for (register int i=1;i&lt;=n;++i)&#123; Seg.update(root[c[i]],1,n,id[i],w[i]); &#125; char opr[10]; while (q--)&#123; scanf(\"%s\",opr); if (opr[0]=='C')&#123; if (opr[1]=='C')&#123; int u,color; u=read(),color=read(); Seg.update(root[c[u]],1,n,id[u],0); Seg.update(root[c[u]=color],1,n,id[u],w[u]); &#125; else&#123; int u,weight; u=read(),weight=read(); Seg.update(root[c[u]],1,n,id[u],w[u]=weight); &#125; &#125; else if (opr[0]=='Q')&#123; printf(\"%d\\n\",query_ans(read(),read(),opr[1]=='M')); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"}]},{"title":"[HDU5807] [BestCoder Round #86 1004] Keep In Touch ","slug":"HDU5807-BestCoder-Round-86-1004-Keep-In-Touch","date":"2019-07-25T01:59:05.000Z","updated":"2019-07-25T02:38:11.028Z","comments":true,"path":"archives/f14e4c76.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/f14e4c76.html","excerpt":"","text":"传送门 $Pro$有n个城市，编号依次为1到n，同时有m条单向道路连接着这些城市，其中第i条道路的起点为Ui，终点为Vi 。(1&lt;=Ui &lt; Vi &lt;= n)。特工团队一共有3名成员：007，008，以及009，他们将要执行q次秘密任务。 在每次任务中，三人可能会处于三个不同的城市，他们互相之间通过对讲机保持联络。编号为i的城市的无线电频为Wi，如果两个城市的无线电频差值的绝对值不超过K，那么无线电就可以接通。三个特工每个时刻必须要选择一条道路，走到下一个城市，每条道路都只需要花费1单位时间。他们可以选择在任意城市终止任务，甚至可以在起点就终止任务，但不允许在道路上终止任务。现在他们想知道，对于每次任务，给定三个人的起始位置，有多少种可能的合法行动方案，使得行动过程中任意在城市的时刻，他们都可以两两联络？ 两个方案被视作不同当且仅当至少存在一个人在某一时刻所在的城市不同。 $Sol$考虑一个$O(n^6)$的$dp$，我们设$dp[i][j][k]$为第一个人到$i$，第二个人到$j$，第三个人到$j$的方法数，每次都枚举后继的节点，但是这样会$TLE$ 考虑如何优化，不妨不要让他们随便走，而是轮流走，第一人先走，第二人其次，第三人最后。 考虑设一个四维的$dp[sta][i][j][k]$，其中$sta==0$，表示三人都分别在现在的$i$，$j$，$k$，$sta==1$，表示第一人在现在的$i$，第二人和第三人在上一次的$j$，$k$，$sta==2$，表示第一人和第二人在现在的$i$，$j$，但是第三人还在上次的$k$。 假设三人编号为$a$，$b$，$c$，那么我们可以画出如下的图： 转移非常简单，这里不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MAXN 55#define MOD 998244353using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int w[MAXN];int dp[3][MAXN][MAXN][MAXN];int G[MAXN][MAXN];inline int alb(int x)&#123; return x&gt;0?x:-x;&#125;inline void inc(int &amp;x,int y)&#123; x=(x+y)%MOD;&#125;int n,m,c,q;int main()&#123; int T=read(); while (T--)&#123; memset(G,0,sizeof(G)); n=read(),m=read(),c=read(),q=read(); for (register int i=1;i&lt;=n;++i)&#123; w[i]=read(); &#125; for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(); G[u][v]=1; &#125; for (register int i=n;i&gt;=1;--i)&#123; for (register int j=n;j&gt;=1;--j)&#123; for (register int k=n;k&gt;=1;--k)&#123; dp[0][i][j][k]=1,dp[1][i][j][k]=dp[2][i][j][k]=0; if (max(max(alb(w[i]-w[j]),alb(w[j]-w[k])),alb(w[k]-w[i]))&gt;c)&#123; dp[0][i][j][k]=0; &#125; else &#123; for (register int u=k+1;u&lt;=n;++u)&#123; if (G[k][u]) inc(dp[0][i][j][k],dp[2][i][j][u]); &#125; &#125; for (register int u=i+1;u&lt;=n;++u)&#123; if (G[i][u]) inc(dp[1][i][j][k],dp[0][u][j][k]); &#125; for (register int u=j+1;u&lt;=n;++u)&#123; if (G[j][u]) inc(dp[2][i][j][k],dp[1][i][u][k]); &#125; &#125; &#125; &#125; while (q--)&#123; int x=read(),y=read(),z=read(); printf(\"%d\\n\",dp[0][x][y][z]); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"}]},{"title":"[POJ2229] [USACO 2005 January Silver] Sum sets ","slug":"POJ2229-USACO-2005-January-Silver-Sum-sets","date":"2019-07-24T15:30:12.000Z","updated":"2019-07-24T15:32:19.171Z","comments":true,"path":"archives/8d0fe55e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8d0fe55e.html","excerpt":"","text":"一个裸的完全背包，考虑将$2^k$当做物品，做完全背包即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1000005#define MAXM 24#define MOD 1000000000using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int pow2[MAXN];int dp[MAXN];//dp[i]和为i的方法数int main()&#123; int n=read(); for (register int i=0;i&lt;MAXM;++i)&#123; pow2[i]=(1&lt;&lt;i); &#125; dp[0]=1; for (register int j=0;j&lt;MAXM;++j)&#123; for (register int i=1;i&lt;=n;++i)&#123; if (i-pow2[j]&gt;=0)&#123; dp[i]+=dp[i-pow2[j]]; dp[i]%=MOD; &#125; &#125; &#125; printf(\"%d\\n\",dp[n]);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"背包","slug":"背包","permalink":"https://gaisaiyuno.github.io/tags/背包/"},{"name":"完全背包","slug":"完全背包","permalink":"https://gaisaiyuno.github.io/tags/完全背包/"}]},{"title":"CF1016D Vasya And The Matrix","slug":"CF1016D-Vasya-And-The-Matrix","date":"2019-07-24T15:09:26.000Z","updated":"2019-07-24T15:26:22.095Z","comments":true,"path":"archives/2bddaeb1.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2bddaeb1.html","excerpt":"","text":"传送门 考虑异或的性质：(a xor b) xor b=a，且a xor b = b xor a 先判断不合法的情况，由异或交换律，我们知道$a$数组异或和，$b$数组异或和都是整个数组的异或和，所以这两个值一样的。 我们不妨这么想，我们知道x1 xor x2 xor x3 xor x4 … xor xn-1，知道x1 xor x2 xor x3 xor x4 … xor xn，把他们两异或一下，就能知道xn，xn是唯一且一定有解的。 从简单考虑，我们就把$ans[i]j$ 设成$0$（设成任意的数理论上都是没有问题的，只是$0$在这里比较方便），显然$ans[i][0]$ xor $ans[i][1]$ xor $ans[i][2]$ xor …$ans[i][m-1]=0$，我们把这个带到上面的式子里，我们发现$ans[i][m]=0$ xor $a[i]=a[i]$，同理$ans[n][j]=a[j]$。 最后还差一个$ans[n][m]$，还是套到上面的式子里面，就可以求出$ans[n][m]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;#define MAXN 105#include &lt;cstdio&gt;#include &lt;iostream&gt;namespace fast_io&#123;inline char read()&#123; static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return s == t ? (((t = (s = buf) + fread(buf, 1, IN_LEN, stdin)) == s) ? -1 : *s++) : *s++;&#125;inline void read(int &amp;x)&#123; static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) &#123; if (c == '-') iosig = true; if (c == -1) return; &#125; for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (iosig) x = -x;&#125;inline void read(char *a)&#123; static char c = read(); while (c != -1 &amp;&amp; (c == ' ' || c == '\\n' || c == '\\r')) c = read(); while (c != -1 &amp;&amp; c != '\\r' &amp;&amp; c != ' ' &amp;&amp; c != '\\n') *a++ = c, c = read(); *a = 0;&#125;const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh = obuf;inline void print(char c)&#123; if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;&#125;inline void print(int x)&#123; static int buf[30], cntt; if (x == 0) print('0'); else &#123; if (x &lt; 0) print('-'), x = -x; for (cntt = 0; x; x /= 10) buf[++cntt] = x % 10 + 48; while (cntt) print((char)buf[cntt--]); &#125;&#125;inline void print(char *a)&#123; while (*a) print(*a++);&#125;inline void flush() &#123; fwrite(obuf, 1, ooh - obuf, stdout); &#125;&#125; // namespace fast_iousing namespace fast_io;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;using namespace std;long long a[MAXN],b[MAXN];long long ans[MAXN][MAXN];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); long long sum1=0,sum2=0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%I64d\",&amp;a[i]); sum1^=a[i]; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(\"%I64d\",&amp;b[i]); sum2^=b[i]; &#125; if (sum1!=sum2)&#123; puts(\"NO\"); return 0; &#125; else &#123; puts(\"YES\"); &#125; long long sum3=0,sum4=0; for (int i=1;i&lt;=n-1;i++)&#123; ans[i][m]=a[i]; sum3^=a[i]; &#125; for (int i=1;i&lt;=m-1;i++)&#123; ans[n][i]=b[i]; sum4^=b[i]; &#125; ans[n][m]=a[n]^sum4; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; printf(\"%I64d \",ans[i][j]); &#125; printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"异或","slug":"异或","permalink":"https://gaisaiyuno.github.io/tags/异或/"}]},{"title":"CF607B Zuma","slug":"CF607B-Zuma","date":"2019-07-24T14:48:16.000Z","updated":"2019-07-24T15:05:19.474Z","comments":true,"path":"archives/9d964d26.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/9d964d26.html","excerpt":"","text":"传送门 我们发现一个很有趣的性质：假设$a[i]==a[j]$且$i&lt;j$，先把$[i+1,j-1]$区间中的回文串消到只剩一个，这一个回文串会和两段的$a[i],a[j]$构成一个更大的回文串，所以在消去这个回文串的同时，顺便消掉两端的$a[i]$和$a[j]$即可。 考虑如下的$dp$方程，$dp[l][r]$为把$[l,r]$全部消完最小的花费。 $1.$$a[l]==a[r]$，为上面讨论过的情况，直接$dp[l][r]=min(dp[l+1][r-1])$即可 $2.$考虑在中间设一个分割点$k$，发现$dp[l][r]=min(dp[l][k]+dp[k+1][r])$ $3.$边界条件，这里我们把$dp[i][i]$设为$1$（长度为$1$的回文串），把$dp[i][i-1]$设为$1$（长度为$0$的回文串） 代码最好用记忆化搜索实现，看起来清晰一点： 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAXN 505using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int dp[MAXN][MAXN],a[MAXN],n;int dfs(int l,int r)&#123; if (dp[l][r]!=0x3f3f3f3f) return dp[l][r]; if (l==r||l==r+1) return 1; if (a[l]==a[r]) dp[l][r]=dfs(l+1,r-1); for (register int i=l;i&lt;r;++i)&#123; dp[l][r]=min(dp[l][r],dfs(l,i)+dfs(i+1,r)); &#125; return dp[l][r];&#125;int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; memset(dp,0x3f,sizeof(dp)); printf(\"%d\\n\",dfs(1,n));&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P2331 [SCOI2005]最大子矩阵","slug":"P2331-SCOI2005-最大子矩阵","date":"2019-07-24T13:57:31.000Z","updated":"2019-07-24T14:46:48.602Z","comments":true,"path":"archives/eb6149e7.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/eb6149e7.html","excerpt":"","text":"传送门 这道题把坑设在了数据范围里面，第一眼看上去没有思路，第二眼发现$m \\le 2$，思路瞬间来了。 分情况讨论，分为$m=1$情况和$m=2$的情况。 声明，为了简略，我们设$sum(l,r)$为$\\sum_{i=l}^{r}a[i]$，$sum1(l,r)$为$\\sum_{i=l}^r=a[0][i]$，$sum2(l,r)$同理 $m=1$这个$dp$方程比较容易，设$dp[i][j]$为搞到第$i$个数，总共$j$段的最大和。发现第$i$个数可选可不选，$dp[i-1][j]$为不选的情况。 方程为$dp[i][j]=\\max(dp[i-1][j],dp[k-1][j]+sum(k,i))$ $m=2$考虑这个$dp$方程，设$dp[i][j][p]$为第一行搞到第$i$个数，第二行搞到第$j$个数，总共$p$个矩阵，的最大和。 考虑每次可以从第一行转移一个$1$行的矩阵，第二行转移一个$1$行的矩阵，也可以从两行一起转移一个$2$行的矩阵，也可以什么都不转移。 考虑什么都不转移：$dp[i][j][p]=\\max (dp[i-1][j][p],dp[i][j-1][p])$ 考虑转移第一行：$dp[i][j][p]=\\max(dp[l][j][p-1]+sum1(l+1,j))(l \\in [0,i))$，第二列同理 转移第一行的情况： 转移第二行的情况： 注意，标成蓝色代表这里$dp$做完，并不代表全部选择，标成红色代表全部选择 考虑转移两行，只有在$i==j$的时候才有这种转移，因为$2$行的矩阵把状态一波推平，推出$dp[i][i][p]=\\max (dp[l][l][p-1]+sum1(l+1,i)+sum2(l+1,i) ) (l \\in [0,i))$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define sum1(l,r) (s1[(r)]-s1[(l)-1])#define sum2(l,r) (s2[(r)]-s2[(l)-1])#define MAXN 105#define MAXK 15using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline void chkmax(int &amp;x,int y)&#123; if (x&lt;y) x=y;&#125;int n,m,k;namespace Solve1&#123; int a[MAXN]; int dp[MAXN][MAXK]; inline int Solve()&#123; for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for (register int p=1;p&lt;=k;++p)&#123; for (register int i=1;i&lt;=n;++i)&#123; dp[i][p]=dp[i-1][p]; int sum=0; for (register int j=i;j&gt;=1;--j)&#123; sum+=a[j]; chkmax(dp[i][p],dp[j-1][p-1]+sum); &#125; &#125; &#125; printf(\"%d\\n\",dp[n][k]); return 0; &#125;&#125;namespace Solve2&#123; int a[2][MAXN]; int s1[MAXN],s2[MAXN]; int dp[MAXN][MAXN][MAXK]; //第一行搞到i第二行搞到j总共k个矩形 inline int Solve()&#123; for (register int i=1;i&lt;=n;++i)&#123; s1[i]=s1[i-1]+read(); s2[i]=s2[i-1]+read(); &#125; for (register int p=1;p&lt;=k;++p)&#123; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=n;++j)&#123; dp[i][j][p]=max(dp[i-1][j][p],dp[i][j-1][p]);//可以什么也不搞 if (i==j)&#123;//可以2个2个地推进 for (register int l=0;l&lt;i;++l)&#123; chkmax(dp[i][j][p],dp[l][l][p-1]+sum1(l+1,i)+sum2(l+1,j)); &#125; &#125; for (register int l=0;l&lt;i;++l)&#123; chkmax(dp[i][j][p],dp[l][j][p-1]+sum1(l+1,i)); &#125; for (register int l=0;l&lt;j;++l)&#123; chkmax(dp[i][j][p],dp[i][l][p-1]+sum2(l+1,j)); &#125; &#125; &#125; &#125; printf(\"%d\\n\",dp[n][n][k]); return 0; &#125;&#125;int main()&#123; n=read(),m=read(),k=read(); if (m==1)&#123; return Solve1::Solve(); &#125; else &#123; return Solve2::Solve(); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"OI中常犯的错误","slug":"OI中常犯的错误","date":"2019-07-24T09:04:23.000Z","updated":"2019-07-24T14:39:42.433Z","comments":true,"path":"archives/19193b76.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/19193b76.html","excerpt":"","text":"1.对拍的时候不加$srand(time(NULL))$，对拍了好久以为自己稳了，结果成绩爆$0$。 2.这个错误比较难发现： 12#define Calc(x) 1-xprintf(\"%d\\n\",Calc(1-2)); 大多数人以为这个程序输出结果是$2$，他们是这么计算的： $x=1-2=-1$，$Calc(x)=Calc(-1)=1-(-1)=2$ 但是，别忘记$define$是纯文本替换，所以其实是这个样子的： $Calc(x)=Calc(1-2)=1-1-2=4$ 惊不惊喜，意不意外？ 所以建议这么写 1#define Calc(x) 1-(x) 3.树剖的查询和线段树的查询写反","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]},{"title":"P2885 [USACO07NOV]电话线Telephone Wire","slug":"P2885-USACO07NOV-电话线Telephone-Wire","date":"2019-07-24T08:49:11.000Z","updated":"2019-07-24T14:39:42.439Z","comments":true,"path":"archives/5f08073.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5f08073.html","excerpt":"","text":"传送门 （题目描述有毒，这里的树不是指$n$点$n-1$条边的连通图，而是普普通通的树（植物）） 考虑$DP$，很容易想到一个$O(n C^2)$的$DP$，令$dp[i][j]$为第$i$棵树拔到$j$的高度，且$1$到$i$的所有树之间都连了线的最小花费，我们有： $dp[i][j]=\\min{dp[i-1][k]+c \\times |j-k|}+(j-h[i])^2$ 实际操作过程中，假设一开始最高的树高度为$maxh$，我们发现把一棵树拔到$maxh$以上永远是亏本的，所以不用考虑。 代码，开了$O2$才能在洛谷上面$AC$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 105using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int f[MAXN][MAXM];int h[MAXN],maxh;int main()&#123; int n=read(),c=read(); maxh=-0x7fffffff; for (register int i=1;i&lt;=n;++i)&#123; h[i]=read(); maxh=max(maxh,h[i]); &#125; for (register int i=h[1];i&lt;=maxh;++i)&#123; f[1][i]=(i-h[1])*(i-h[1]); &#125; for (register int i=2;i&lt;=n;++i)&#123; for (register int j=h[i];j&lt;=maxh;++j)&#123; f[i][j]=0x7fffffff; for (register int k=h[i-1];k&lt;=maxh;++k)&#123; f[i][j]=min(f[i][j],f[i-1][k]+c*abs(j-k)); &#125; f[i][j]+=(j-h[i])*(j-h[i]); &#125; &#125; int ans=0x7fffffff; for (register int i=h[n];i&lt;=maxh;++i)&#123; ans=min(ans,f[n][i]); &#125; printf(\"%d\\n\",ans);&#125; 考虑如何优化，发现$c \\times abs(j-p)$具有单调性，所以就可以$O(nk)$ 1234567891011121314151617181920212223242526272829303132333435363738394041// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 105#define Calc(p) (f[i-1][p]+c*abs(j-(p)))using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int f[MAXN][MAXM];int h[MAXN],maxh;int main()&#123; int n=read(),c=read(); maxh=-0x7fffffff; for (register int i=1;i&lt;=n;++i)&#123; h[i]=read(); maxh=max(maxh,h[i]); &#125; for (register int i=1;i&lt;=n;++i)&#123; int p=h[i-1]; for (register int j=h[i];j&lt;=maxh;++j)&#123; while (p&lt;maxh&amp;&amp;Calc(p+1)&lt;Calc(p)) p++; f[i][j]=Calc(p)+(j-h[i])*(j-h[i]); &#125; &#125; int ans=0x7fffffff; for (register int i=h[n];i&lt;=maxh;++i)&#123; ans=min(ans,f[n][i]); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P2592 [ZJOI2008]生日聚会","slug":"P2592-ZJOI2008-生日聚会","date":"2019-07-23T14:48:45.000Z","updated":"2019-07-23T14:59:32.429Z","comments":true,"path":"archives/e1a84f39.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e1a84f39.html","excerpt":"","text":"传送门 比较有意思的$DP$ 题目，考虑转化题目条件： 原题目：对于任意连续的一段，男女数目之差不超过$k$ 转化成：对于所有的连续的段，男女数目之差的最大值不超过$k$ 然后就可以$DP$了，令$dp[i][j][x][y]$为前$i+j$人中$i$人为男孩，$j$人为女孩，对于前$i+j$人中所有连续的段，男减女最多$x$ 人，女减男最多$y$人的方案数。 考虑新加进的是男孩，即$dp[i+1][j][x+1][max(y-1,0)]+=dp[i][j][x][y]$ 新加进的是女孩，即$dp[i][j][max(x-1,0)][y]+=dp[i][j][x][y]$ 时间复杂度$O(nmk^2)$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define MAXN 155#define MAXM 25#define MOD 12345678using namespace std;int dp[MAXN][MAXN][MAXM][MAXM];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int main()&#123; int n=read(),m=read(),k=read(); dp[0][0][0][0]=1; for (register int i=0;i&lt;=n;++i)&#123; for (register int j=0;j&lt;=m;++j)&#123; for (register int x=0;x&lt;=k;++x)&#123; for (register int y=0;y&lt;=k;++y)&#123; dp[i+1][j][x+1][max(y-1,0)]+=dp[i][j][x][y]; dp[i+1][j][x+1][max(y-1,0)]%=MOD; dp[i][j+1][max(0,x-1)][y+1]+=dp[i][j][x][y]; dp[i][j+1][max(0,x-1)][y+1]%=MOD; &#125; &#125; &#125; &#125; int ans=0; for (register int i=0;i&lt;=k;++i)&#123; for (register int j=0;j&lt;=k;++j)&#123; ans=(ans+dp[n][m][i][j])%MOD; &#125; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P1903 [国家集训队]数颜色 / 维护队列","slug":"P1903-国家集训队-数颜色-维护队列","date":"2019-07-23T14:11:30.000Z","updated":"2019-07-25T08:00:45.163Z","comments":true,"path":"archives/5eb62ea9.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5eb62ea9.html","excerpt":"","text":"传送门 首先，假设你会了不带修改的莫队（不会出门右拐百度） 我们来想一想莫队如何支持修改，我们把查询和修改操作离线下来，如图，将查询标为蓝色，将修改标为红色。 假设我们要查询六号查询的答案，考虑哪些修改会影响答案，肯定是在六号之前的修改，且这些修改的下标$ind$在六号查询的区间$[l,r]$之内，如图中$2$，$4$号修改，要把这些修改全部做完，才能得到正确的结果。 所以，我们在每个查询中除了$l,r,id$，还要记录一个$last$，代表最近的修改位置，查询时，我们要把$last$前面的修改全部做完，如代码。 123struct Query&#123; int l,r,id,last;//last为最近的修改位置&#125;q[MAXN]; 同时记录每个修改操作，只用记录修改的下标$ind$和修改的值$val$即可。 123struct Update&#123; int ind,val;//把ind修改成val&#125;u[MAXN]; 为了做带修莫队，我们记录一个指针$p$ ，代表我们把$[1,p]$的修改操作全部做完了，做莫队的时候，除了常规的莫队操作，还要有下面两行： 12while (p&lt;q[i].last) Upd(++p,i);while (p&gt;q[i].last) Upd(p--,i); 如果操作做少了，那么我们调用$Upd(++p,i)$，多做一次操作，如果操作做少了，我们调用$Upd(p—,i)$，撤销一次操作。 那么这个撤销怎么弄呢？ 很容易想到的是，我们在每个$Update$结构体里面再多存一个$flag$，代表当前是增加操作还是撤销操作，如果是撤销操作，那么我们删除$u[p].val$，加入$num[u[p].ind]$，每次操作后，$flag$取反，即撤销操作变成加入操作，加入操作变成撤销操作。 但是呢，这样代码量不但增加，常数也增多了，这道题你可能$TLE$，考虑有没有更加简洁优美的方法替代$flag$。 有！ 我们每次操作之后，将$num[u[p].ind]$和$u[p].val$对调，我们再撤销回去的时候，就相当于将$u[p].val$改成$num[u[p].ind]$，非常巧妙。 实现如下，注意只有修改的下标在现在查询范围之内才会对答案造成影响： 123456inline void Upd(int p,int i)&#123; if (q[i].l&lt;=u[p].ind&amp;&amp;u[p].ind&lt;=q[i].r)&#123; Del(num[u[p].ind]),Add(u[p].val);//修改，先删去原有的，再加进val &#125; swap(num[u[p].ind],u[p].val);&#125; 注意要加$sort$，（虽然我不加$sort$也卡过） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Query&#123; int l,r,id,last;//last为最近的修改位置&#125;q[MAXN];struct Update&#123; int ind,val;//把ind修改成val&#125;u[MAXN];int pos[MAXN],num[MAXN];inline bool operator &lt; (const Query &amp;x,const Query &amp;y)&#123; if(pos[x.l]!=pos[y.l]) return pos[x.l]&lt;pos[y.l]; if(pos[x.r]!=pos[y.r]) return pos[x.r]&lt;pos[y.r]; return x.last&lt;y.last;&#125;int cntq,cntu;inline char gc()&#123; char ch=getchar(); while (ch!='Q'&amp;&amp;ch!='R') ch=getchar(); return ch;&#125;int ans,Ans[MAXN];static int cnt[MAXN];#define Add(x) (++cnt[x]==1)?++ans:0#define Del(x) (--cnt[x]==0)?--ans:0inline void Upd(int p,int i)&#123; if (q[i].l&lt;=u[p].ind&amp;&amp;u[p].ind&lt;=q[i].r)&#123; Del(num[u[p].ind]),Add(u[p].val);//修改，先删去原有的，再加进val &#125; swap(num[u[p].ind],u[p].val);&#125;inline void Print(register int x)&#123; if (x&gt;=10ll) Print(x/10ll); putchar(x%10ll+48ll);&#125;inline void print(register int x,const char ch)&#123; if (x&lt;0)&#123;x=-x,putchar('-');&#125; if (x==0)&#123;putchar('0');putchar(ch);return ;&#125; Print(x);putchar(ch);&#125;int main()&#123; int n=read(),m=read(); const int Size=pow(n,(double)0.666666666); for (register int i=1;i&lt;=n;++i)&#123; num[i]=read(); &#125; for (register int i=1;i&lt;=m;++i)&#123; char opr=gc(); if (opr=='Q') q[++cntq]=Query&#123;read(),read(),cntq,cntu&#125;; else u[++cntu]=Update&#123;read(),read()&#125;; &#125; for (register int i=1;i&lt;=n;++i)&#123; pos[i]=(i-1)/Size+1; &#125; sort(q+1,q+1+cntq); register int l=1,r=0; register int p=0;//修改的操作 for (register int i=1;i&lt;=m;++i)&#123; while (l&lt;q[i].l) Del(num[l++]); while (l&gt;q[i].l) Add(num[--l]); while (r&lt;q[i].r) Add(num[++r]); while (r&gt;q[i].r) Del(num[r--]); while (p&lt;q[i].last) Upd(++p,i); while (p&gt;q[i].last) Upd(p--,i); Ans[q[i].id]=ans; &#125; for (register int i=1;i&lt;=cntq;++i)&#123; print(Ans[i],'\\n'); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"莫队","slug":"莫队","permalink":"https://gaisaiyuno.github.io/tags/莫队/"},{"name":"带修莫队","slug":"带修莫队","permalink":"https://gaisaiyuno.github.io/tags/带修莫队/"},{"name":"卡常","slug":"卡常","permalink":"https://gaisaiyuno.github.io/tags/卡常/"}]},{"title":"P5459 [BJOI2016]回转寿司","slug":"P5459-BJOI2016-回转寿司","date":"2019-07-23T09:47:17.000Z","updated":"2019-07-23T09:58:32.971Z","comments":true,"path":"archives/451404ec.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/451404ec.html","excerpt":"","text":"传送门 题意给你一个数列${a_i}$和两数$L,R$，询问有多少组$l,r$，满足$\\sum ^r _{i=l}a[i] \\in [L,R]$ 题解考虑把$\\sum ^r _{i=l} a[i]$转化为前缀和$sum[r]-sum[l-1]$，发现$L \\le sum[r]-sum[l-1] \\le R$，继续化一下式子，发现$L-sum[r] \\le -sum[l-1]\\le R-sum[r]$，即$sum[r]-R \\le sum[l-1] \\le sum[r]-L$（注意这里等式两边乘了$-1$，所以左右交换） 所以，对于一个$r$，我们只需要求满足$sum[r]-R \\le sum[l-1] \\le sum[r]-L$有多少个$l-1$，这个线段树区间查询就可以做到，注意到$l-1 \\le r$，所以我们只需要将右端点向右移动，查询后同时更新即可。 注意到$1 \\le L,R \\le 10^9$，范围很大，所以我们需要一棵动态开点的线段树。 注意$long$ $long$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define int long long#define MAXN 100005#define MAXM 1e12using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val; &#125;tree[40*MAXN&lt;&lt;2]; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; int tot; void Update(int &amp;i,int l,int r,int index)&#123; if (!i) i=++tot; if (l==r) &#123; tree[i].val++; return ; &#125; int mid=(l+r)&gt;&gt;1; if (index&lt;=mid) Update(tree[i].l,l,mid,index); else Update(tree[i].r,mid+1,r,index); pushup(i); &#125; int Query(int &amp;i,int l,int r,int L,int R)&#123; if (!i) i=++tot; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i].val; &#125; int mid=(l+r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans+=Query(lc,l,mid,L,R); if (mid&lt;R) ans+=Query(rc,mid+1,r,L,R); return ans; &#125;&#125;using namespace SegmentTree;int a[MAXN],sum[MAXN];#undef intint main()&#123;#define int long long int n=read(),L=read(),R=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(); sum[i]=sum[i-1]+x; &#125; int ans=0,root=0; for (register int i=0;i&lt;=n;++i)&#123; ans+=Query(root,-MAXM,MAXM,sum[i]-R,sum[i]-L); Update(root,-MAXM,MAXM,sum[i]); &#125; printf(\"%lld\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"动态开点","slug":"动态开点","permalink":"https://gaisaiyuno.github.io/tags/动态开点/"}]},{"title":"CF609E Minimum spanning tree for each edge","slug":"CF609E-Minimum-spanning-tree-for-each-edge","date":"2019-07-23T09:24:57.000Z","updated":"2019-07-27T03:10:59.385Z","comments":true,"path":"archives/3b573a7c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3b573a7c.html","excerpt":"","text":"传送门 考虑先把这张图的最小生成树$G$建出来，假设查询的边为$E$， 发现： $1.$如果$E$本来就在$G$里面，那么直接输出$G$的边权和，因为没有比这个更优的解。 $2.$如果$E$不在$G$里面，那么$E$一定和$G$ 形成一个环，根据贪心的原则，我们把这条环上面最大边权的边删去，这样新的图仍然是一棵树，而且边权和最小。 在实际操作过程中，我们并不用找到那个环，可以这么想，假设$E$的端点分别为$u,v$，在最小生成树上它们的$LCA$为$alb$，那么这个环一定是由$u,alb$这条链，$alb,v$这条链和边$E$所构成，于是，只要找到路径$u,v$上面边权最大的一条边即可。 具体实现时，可以使用树上倍增或树链剖分。 注意： $1.$求完最小生成树之后，一定要把按边权排序过的$E$数组还原。 $2.$$\\rm QueryChain$和$\\rm Query$不要写混。 $3.$要开$\\rm long$ $\\rm long$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define MAXN 400005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Node&#123; int to,w;&#125;;vector&lt;Node&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(Node&#123;v,w&#125;);&#125;int sz[MAXN],big[MAXN],fa[MAXN],top[MAXN],dep[MAXN],tofa[MAXN];void dfs1(int u,int father)&#123; fa[u]=father;sz[u]=1; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].w; if (v!=father)&#123; dep[v]=dep[u]+1; dfs1(v,u); tofa[v]=w; sz[u]+=sz[v]; if (sz[big[u]]&lt;sz[v]) big[u]=v; &#125; &#125;&#125;int seq[MAXN],cnt;int alb[MAXN];void dfs2(int u,int t)&#123; alb[seq[u]=++cnt]=u; top[u]=t; if (big[u]) dfs2(big[u],t); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; if (v!=fa[u]&amp;&amp;v!=big[u])&#123; dfs2(v,v); &#125; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=max(tree[lc].val,tree[rc].val); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r) &#123; tree[i].val=tofa[alb[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;inline int Query_Chain(int u,int v)&#123; int ans=0; while (top[u]!=top[v])&#123; if (dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v); &#125; ans=max(ans,Query(1,seq[top[u]],seq[u])); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); return max(ans,Query(1,seq[u]+1,seq[v]));&#125;int n;inline void Init()&#123; dep[1]=1; dfs1(1,0); dfs2(1,1);&#125; struct Edge&#123; int u,v,w,id;&#125;E[MAXN];int tot;inline void AddEdge1(int u,int v,int w)&#123; E[++tot]=Edge&#123;u,v,w,tot&#125;;&#125;inline bool cmp1(const Edge &amp;A,const Edge &amp;B)&#123;return A.w&lt;B.w;&#125;inline bool cmp2(const Edge &amp;A,const Edge &amp;B)&#123;return A.id&lt;B.id;&#125;namespace BCJ&#123; int Fa[MAXN]; inline void Init_BCJ()&#123;for (register int i=0;i&lt;MAXN;++i) Fa[i]=i;&#125; inline int Get_Fa(int i)&#123;return Fa[i]==i?i:Fa[i]=Get_Fa(Fa[i]);&#125;&#125;using namespace BCJ;int MST[MAXN];//这条边在MST中出现过int Size;//生成树大小inline void Kruscal()&#123; sort(E+1,E+1+tot,cmp1); Init_BCJ(); Size=0; for (register int i=1;i&lt;=tot;++i)&#123; int fau=Get_Fa(E[i].u),fav=Get_Fa(E[i].v); if (fau!=fav)&#123; AddEdge(E[i].u,E[i].v,E[i].w); AddEdge(E[i].v,E[i].u,E[i].w); Fa[fau]=fav; Size+=E[i].w; MST[E[i].id]=true; &#125; &#125; sort(E+1,E+1+tot,cmp2);//再给他sort回去&#125;#undef intint main()&#123;#define int long long int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),w=read(); AddEdge1(u,v,w); &#125; Kruscal(); Init();//在生成树上面跑树链剖分 Build(1,1,n); for (register int i=1;i&lt;=m;++i)&#123; if (MST[i])&#123; printf(\"%lld\\n\",Size); &#125; else &#123; printf(\"%lld\\n\",Size-Query_Chain(E[i].u,E[i].v)+E[i].w); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://gaisaiyuno.github.io/tags/最小生成树/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://gaisaiyuno.github.io/tags/Kruskal/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"}]},{"title":"P2371 [国家集训队]墨墨的等式","slug":"P2371-国家集训队-墨墨的等式","date":"2019-07-23T02:49:24.000Z","updated":"2019-07-23T12:15:51.392Z","comments":true,"path":"archives/7e1a6aa.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/7e1a6aa.html","excerpt":"","text":"传送门 首先，大家都可以看出来，这道题是一个多重背包，设$f(i)$为和为$i$可不可行，那么假设$k$为${a_n}$中的一个数，且$f(s)==1$，我们把$f(s+k \\times 1)$，$f(s+k \\times 2)$，$f(s+k \\times 3)$，….都设为$1$ 但是，作为一个不知道高到哪里去的膜法师，你发现这样子搞太$Naive$了，这样要做无穷次，而且得出来的数$s+k \\times 1 , s+k \\times 2,s + k \\times 3$取值范围也是正无穷，于是，你决定给它取一个膜，假设我们膜的是$ha$ 发现$s+k \\times {(i+ha)} == s+k \\times i (\\mod ha)$，所以连的边最多$ha$条，取值范围也变成$[0,ha)$，你不禁叫了一声： 吼啊！ 如图： 于是，此题的具体思路就有了，我们对于每一个$s \\in [0,ha)$建立一个点，把$s$和$(s+a[i]) \\mod ha$连一条边，边权为$a[i]$，从$s=0$跑最短路，得到$dist$数组。 考虑差分得出$[L,R]$中$B$有多少种取值，","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"SPFA","slug":"SPFA","permalink":"https://gaisaiyuno.github.io/tags/SPFA/"},{"name":"最短路","slug":"最短路","permalink":"https://gaisaiyuno.github.io/tags/最短路/"}]},{"title":"P4178 Tree","slug":"P4178-Tree","date":"2019-07-22T14:50:51.000Z","updated":"2019-07-22T15:12:12.851Z","comments":true,"path":"archives/124033e5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/124033e5.html","excerpt":"","text":"传送门 考虑点分治，$Calc()$函数如何实现呢？，我们把$u$子树内以根节点为端点的链的长度全部存到一个栈里面，将栈排一个序，令$f(i)$为使得$stk[i]+stk[j] \\le k$的最小的$j$，考虑把这个式子转换成$stk[j] \\le k-stk[i]$，发现只要一次upper_bound，就可以求出$j$， 然后左端点的$i$和区间$[i+1,f[i]]$的数都可以配对，所以有$f[i]-i$种配对方法。 注意是upper_bound而不是lower_bound 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 40005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct node&#123; int to,len;&#125;;vector&lt;node&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(node&#123;v,w&#125;);&#125;int sz[MAXN],f[MAXN],root;int vis[MAXN];//sz是有向的子树的大小，f是无向的子树的最大值，root为重心void GetRoot(int u,int father,int tot)&#123; sz[u]=1,f[u]=0; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; if (v!=father&amp;&amp;!vis[v])&#123; GetRoot(v,u,tot); sz[u]+=sz[v]; f[u]=max(f[u],sz[v]); &#125; &#125; f[u]=max(f[u],tot-sz[u]); if (f[u]&lt;f[root]) root=u;&#125;int stk[MAXN],r;void GetDep(int u,int father,int dep)&#123; stk[++r]=dep; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father&amp;&amp;!vis[v])&#123; GetDep(v,u,dep+w); &#125; &#125;&#125;int k;inline int Calc(int u,int w)&#123; r=0; GetDep(u,0,w); sort(stk+1,stk+1+r); int sum=0; for (register int i=1;i&lt;=r;++i)&#123; sum+=upper_bound(stk+i,stk+1+r,k-stk[i])-stk-i-1; &#125; return sum;&#125;inline void NewRoot(int u,int sz)&#123; root=0; GetRoot(u,0,sz);&#125;int ans;void dfs(int u)&#123; ans+=Calc(u,0); vis[u]=true; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (!vis[v])&#123; ans-=Calc(v,w); NewRoot(v,sz[v]); dfs(root); &#125; &#125;&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); &#125; k=read(); f[0]=n; NewRoot(1,n); dfs(root); printf(\"%d\\n\",ans);&#125; 还有一种$O(n)$求配对方法的办法，考虑$two$ $pointers$，维护两个指针$l,r$，我们发现左端点往右，对应的$k-stk[l]$是单调递减的，也就是说，右端点一定是往左的，根据这个性质，如果$stk[l]+stk[r] \\le k$，把左端点往右移动，顺便记录答案，否则把右端点往左移动即可。 每个指针加起来移动$n$次，所以算法是$O(n)$的 123456int l=1,sum=0;while (l&lt;r)&#123; if (stk[l]+stk[r]&lt;=k) sum+=(r-l),l++; else r--;&#125;return sum;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"点分治","slug":"点分治","permalink":"https://gaisaiyuno.github.io/tags/点分治/"}]},{"title":"P2634 [国家集训队]聪聪可可","slug":"P2634-国家集训队-聪聪可可","date":"2019-07-22T14:38:16.000Z","updated":"2019-07-22T14:50:28.388Z","comments":true,"path":"archives/4147b09b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4147b09b.html","excerpt":"","text":"传送门 一道非常模板的点分治，核心函数是$Calc()$，返回当前子树中，经过根节点的链有多少条长度是$3$的倍数，实现时，记录$f_0,f_1,f_2$，分别代表有多少条以根节点为端点的链长度$\\mod 3=0,1,2$，最后乘法原理相乘即可。 注意容斥原理，要减去两条链共用一条根节点发出的边的情况，如图中红蓝两条链： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define MAXN 20005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct node&#123; int to,len;&#125;;vector&lt;node&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; G[u].push_back(node&#123;v,w&#125;);&#125;int sz[MAXN],f[MAXN],root;int vis[MAXN];//sz是有向的子树的大小，f是无向的子树的最大值，root为重心void GetRoot(int u,int father,int tot)&#123; sz[u]=1,f[u]=0; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to; if (v!=father&amp;&amp;!vis[v])&#123; GetRoot(v,u,tot); sz[u]+=sz[v]; f[u]=max(f[u],sz[v]); &#125; &#125; f[u]=max(f[u],tot-sz[u]); if (f[u]&lt;f[root]) root=u;&#125;int ha[3];void GetDep(int u,int father,int dep)&#123; ha[dep]++; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (v!=father&amp;&amp;!vis[v])&#123; GetDep(v,u,(dep+w)%3); &#125; &#125;&#125;inline int Calc(int u,int w)&#123; ha[0]=ha[1]=ha[2]=0; GetDep(u,0,w); return ha[1]*ha[2]*2+ha[0]*ha[0];//1和2可以互相交换，所以两种情况&#125;inline void NewRoot(int u,int sz)&#123;//将root赋值为以u为根节点的子树(大小sz)的重心 root=0; GetRoot(u,0,sz);&#125;int ans;void dfs(int u)&#123; ans+=Calc(u,0); vis[u]=true; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len; if (!vis[v])&#123; ans-=Calc(v,w);//容斥 NewRoot(v,sz[v]); dfs(root); &#125; &#125;&#125;int gcd(int x,int y)&#123; return x%y==0?y:gcd(y,x%y);&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(),w=read()%3; AddEdge(u,v,w); AddEdge(v,u,w); &#125; f[0]=n; NewRoot(1,n); dfs(root); int g=gcd(ans,n*n); printf(\"%d/%d\\n\",ans/g,n*n/g);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"点分治","slug":"点分治","permalink":"https://gaisaiyuno.github.io/tags/点分治/"}]},{"title":"P2971 [USACO10HOL]牛的政治Cow Politics","slug":"P2971-USACO10HOL-牛的政治Cow-Politics","date":"2019-07-22T08:02:07.000Z","updated":"2019-07-22T10:27:50.804Z","comments":true,"path":"archives/b13f4097.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/b13f4097.html","excerpt":"","text":"传送门 扫了一眼题解，发现没有一个严谨证明的，那么我就来证明一波吧。 首先，我们看一看如何求树的直径： $1.$随便定一个根节点，第一遍$bfs$求出树中深度最深的节点，记为$u$。 $2 .$以$u$为根节点，第二遍$bfs$求出树中深度最深的点$v$ $3.$树的直径的端点即为$u,v$ 类比到此题： 我们把政党$p$中的牛最深的记为$\\max _p$ 发现：$p$政党最长的链一定是某个$p$政党的牛和$\\max_p$构成的（类似于树的直径） 考虑如何证明这个结论，采用反证法（自己画一个图比较好理解）： 声明：为了简化证明，我们记$ab$为树上$ab$两点的最短路径，$dep(a)$为节点$a$在树中的深度。 设某个$p$政党的牛$a$和另一个深度小于$\\max _p $的牛$b$构成了最长的链。 首先，我们求出$lca (a,b)$，设为$c$，求出$lca(a,\\max _p)$，设为$c’$。 我们可以知道，$c’$，$c$有直接的祖先关系，也有可能$c=c’$，简单来说，就是在同一条到根节点的链上。（这一点参见虚树的证明） 考虑两种情况： $1.$$c’$的祖先为$c$（如图），那我们有$c’\\max_ p+cc’+dep(c)=dep({\\max_ p})$，且$cb+dep(c)=dep(b)$， 由$dep(b) &lt; dep({\\max_ p})$，两式相减，发现$dep(c)$抵消，我们有$cb&lt;c’ \\max _p+cc’…*$ 发现$ab=ac’+c’c+cb$，且$a\\max_p=ac’+c’\\max_p$，将$*$式代入，我们有$ab=ac’+c’c+cb&lt;ac’+c’c+c’\\max _p+c’c=a\\max _p+cc’ \\times 2$ 由于$c’$的祖先为$c$，所以$cc’&gt;0$，所以$ab&lt;a\\max_p$，假设错误。 $2.$$c$的祖先为$c$，证明方法差不多，不再赘述。 所以，我们求一波$LCA$，然后预处理出$\\max_p$，最后暴力扫过一遍所有的牛，求出答案。 时间复杂度$O(n\\log n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;#define MAXN 200005#define MAXM 25using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int anc[MAXN][MAXM],dep[MAXN],n,m;void dfs(int u,int father)&#123; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i)&#123; anc[u][i]=anc[anc[u][i-1]][i-1]; &#125; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs(v,u); &#125; &#125;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i]; v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;inline void Init(int root)&#123; memset(dep,0,sizeof(dep)); dfs(root,0);&#125;int val[MAXN],maxu[MAXN],maxdep[MAXN],ans[MAXN];inline int Dis(int u,int v)&#123; return dep[u]+dep[v]-2*dep[LCA(u,v)];&#125;int main()&#123; int n=read(),k=read(); int root; for (register int i=1;i&lt;=n;++i)&#123; int a=read(),p=read(); val[i]=a; AddEdge(i,p),AddEdge(p,i); if (!p) root=i; &#125; Init(root); for (register int i=1;i&lt;=n;++i)&#123;//预处理 if (dep[maxu[val[i]]]&lt;dep[i]) maxu[val[i]]=i; &#125; for (register int i=1;i&lt;=n;++i)&#123; ans[val[i]]=max(ans[val[i]],Dis(maxu[val[i]],i)); &#125; for (register int i=1;i&lt;=k;++i)&#123; printf(\"%d\\n\",ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"},{"name":"树的直径","slug":"树的直径","permalink":"https://gaisaiyuno.github.io/tags/树的直径/"}]},{"title":"P4556 [Vani有约会]雨天的尾巴","slug":"P4556-Vani有约会-雨天的尾巴","date":"2019-07-22T06:16:44.000Z","updated":"2019-07-27T03:13:40.110Z","comments":true,"path":"archives/f855d365.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/f855d365.html","excerpt":"","text":"传送门 这道题我们使用权值线段树合并，节点$[l,r]​$存的是第$l…r​$种救济粮的最大值$val​$，还要记录最多的救济粮的种类$pos​$，这个维护起来很简单，不再赘述。 考虑树上差分，每个节点开一个权值线段树，我们把节点$x$，$y$的救济粮数目$+1$，把节点$lca(x,y)$，$fa(lca(x,y))$的救济粮数目$-1$，最后一遍$\\rm dfs$把$u$点的所有子树的权值线段树和$u$点的权值线段树合并，并且记录答案即可。 注意空间要开$n\\log n$，还有$fa(lca(x,y))$不存在，即$lca(x,y)==1$时要加特判。 时间复杂度$O(n\\log n)$，空间复杂度$O(n \\log n)$，用$\\rm set$ 启发式合并可以做到两只$\\log$，但是也不好写到哪里去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 60using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,pos; &#125;tree[MAXN*MAXM]; int tot; #define lc tree[i].l #define rc tree[i].r inline void pushup(int i)&#123; if (tree[lc].val&lt;tree[rc].val)&#123; tree[i].val=tree[rc].val; tree[i].pos=tree[rc].pos; &#125; else &#123; tree[i].val=tree[lc].val; tree[i].pos=tree[lc].pos; &#125; &#125; void Update(int &amp;i,int l,int r,int index,int val)&#123; if (!i) i=++tot; if (l==r) &#123; tree[i].val+=val; tree[i].pos=l; return ; &#125; int mid=(l+r)&gt;&gt;1; if (index&lt;=mid) Update(lc,l,mid,index,val); else Update(rc,mid+1,r,index,val); pushup(i); &#125; int Merge(int x,int y,int l,int r)&#123; if (!x||!y) return x+y; if (l==r)&#123; tree[x].val+=tree[y].val; tree[x].pos=l; return x; &#125; int mid=(l+r)&gt;&gt;1; tree[x].l=Merge(tree[x].l,tree[y].l,l,mid); tree[x].r=Merge(tree[x].r,tree[y].r,mid+1,r); pushup(x); return x; &#125;&#125;using namespace SegmentTree;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v);&#125;int anc[MAXN][MAXM],dep[MAXN],n,m;void dfs(int u,int father)&#123; anc[u][0]=father; for (register int i=1;i&lt;MAXM;++i)&#123; anc[u][i]=anc[anc[u][i-1]][i-1]; &#125; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; dep[v]=dep[u]+1; dfs(v,u); &#125; &#125;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (dep[anc[u][i]]&gt;=dep[v])&#123; u=anc[u][i]; &#125; &#125; if (u==v) return u; for (register int i=MAXM-1;i&gt;=0;--i)&#123; if (anc[u][i]!=anc[v][i])&#123; u=anc[u][i]; v=anc[v][i]; &#125; &#125; return anc[u][0];&#125;inline void Init()&#123; memset(dep,0,sizeof(dep)); dfs(1,1);&#125;int ans[MAXN],rt[MAXN];void DP(int u,int father)&#123; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (v!=father)&#123; DP(v,u); rt[u]=Merge(rt[u],rt[v],1,MAXN-1); &#125; &#125; if (tree[rt[u]].val)&#123; ans[u]=tree[rt[u]].pos; &#125;&#125;inline void Upd(int u,int pos,int val)&#123; Update(rt[u],1,MAXN-1,pos,val);&#125;inline void Add(int x,int y,int z)&#123; int lca=LCA(x,y); Upd(x,z,1),Upd(y,z,1); Upd(lca,z,-1); if (lca!=1) Upd(anc[lca][0],z,-1);&#125;int main()&#123; n=read(),m=read(); for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v),AddEdge(v,u); &#125; Init(); for (register int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(),z=read(); Add(x,y,z); &#125; DP(1,1); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d\\n\",ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"权值线段树","slug":"权值线段树","permalink":"https://gaisaiyuno.github.io/tags/权值线段树/"},{"name":"LCA","slug":"LCA","permalink":"https://gaisaiyuno.github.io/tags/LCA/"},{"name":"树上差分","slug":"树上差分","permalink":"https://gaisaiyuno.github.io/tags/树上差分/"}]},{"title":"P5057 [CQOI2006]简单题","slug":"P5057-CQOI2006-简单题","date":"2019-07-21T14:53:26.000Z","updated":"2019-07-21T14:56:06.094Z","comments":true,"path":"archives/2ddc428f.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2ddc428f.html","excerpt":"","text":"传送门 发现翻转奇数次的数变成$1$，翻转偶数次的数变成$0$，于是只需知道每个数翻转了几次，就知道它最终的值，使用单点查询，区间修改的普通线段树即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val; int tag; inline int len()&#123; return r-l+1; &#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; inline void Rev(int i,int val)&#123; tree[i].val+=tree[i].len()*val; tree[i].tag+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Rev(lc,tree[i].tag),Rev(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Rev(i,1); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(lc,L,R); if (mid&lt;R) Update(rc,L,R); pushup(i); &#125; int Query(int i,int index)&#123; if (tree[i].l==tree[i].r)&#123; return tree[i].val; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) return Query(lc,index); else return Query(rc,index); &#125;&#125;using namespace SegmentTree;int main()&#123; int n=read(),m=read(); Build(1,1,n); for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1)&#123; int l=read(),r=read(); Update(1,l,r); &#125; else &#123; int p=read(); printf(\"%d\\n\",Query(1,p)&amp;1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"随机化入门","slug":"随机化入门","date":"2019-07-21T14:02:25.000Z","updated":"2019-07-21T14:28:34.400Z","comments":true,"path":"archives/dac1177.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/dac1177.html","excerpt":"","text":"我们日常生活中，随机化主要有三种。 $1.$ 这种随机化有一定概率是错的，但是时间一定在范围之内： 如：$Miller Rabin$素数测试，模拟退火，比赛时输出rand（也不能说这个没有正确的概率） 如果你发现题目中有如下性质，那么你可以用随机化试一试： 要你从$a_1 a_2 a_3 …. a_n$选择一些数，构造一个序列$b_1b_2b_3….b_m$，使序列合法且$m$尽可能大。 123456789101112for (register int k=1;k&lt;=10000;++k)&#123; random_shuffle(a+1,a+1+n); //......... for (register int i=1;i&lt;=n;++i)&#123; //.......... if (!Check())&#123; ans=max(ans,....); break; &#125; &#125;&#125;printf(\"%d\\n\",ans); 例题： P4212 外太空旅行 $2.$这种随机化一定是对的，但是时间可能超时（看你脸白不白）： 如果你发现题目中有如下性质，那么你可以用随机化试一试： 要你从$a_1 a_2 a_3 …. a_n$选择一些数，构造一个合法序列$b_1b_2b_3….b_m$，这种构造方法有很多，因此是$SPJ$，模板如下： （$b$为下标序列） 1234567891011121314for (register int t=1;t&lt;=100000;++t)&#123; random_shuffle(b+1,b+1+n); //........ for (register int i=1;i&lt;=n;++i)&#123; //......... if (Check())&#123; for (register int j=1;j&lt;=i;++j)&#123; printf(\"%d \",a[b[j]]); &#125; printf(\"\\n\"); return 0; &#125; &#125;&#125; 例题： LOJ #6220.sum CF405D Toy Sum $3.$随机化用来均摊时间复杂度，如快排，$Treap$。 这类题目比较玄学，大部分是找最小的最大值或最大的最小值（前提二分不可做） 例题： CF981F Round Marriage 最后一点非常重要： srand(19260817)","categories":[],"tags":[{"name":"随机化","slug":"随机化","permalink":"https://gaisaiyuno.github.io/tags/随机化/"}]},{"title":"LOJ #6220.sum","slug":"LOJ-6220-sum","date":"2019-07-21T12:43:27.000Z","updated":"2019-07-27T03:12:57.456Z","comments":true,"path":"archives/49aed47d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/49aed47d.html","excerpt":"","text":"传送门 大家好，我非常喜欢随机化，所以用$\\rm randomshuffle$ AC了此题。 每次$\\rm randomshuffle$整个序列，判断前缀的和是否是$n$的倍数。 你一定会怀疑这个算法的时间复杂度，但是它就是AC了，所以不要怀疑$\\rm srand(19260817)$，它会让你的程序以$O(-1)$ 的时间跑过数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAXN 1000011#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN];#undef intint main()&#123;#define int long long srand(19260817); int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for (register int i=1;i&lt;=n;++i)&#123; b[i]=i; &#125; for (register int t=1;t&lt;=100000;++t)&#123; random_shuffle(b+1,b+1+n); int sum=0; for (register int i=1;i&lt;=n;++i)&#123; sum+=a[b[i]]; if (sum%n==0)&#123; for (register int j=1;j&lt;=i;++j)&#123; printf(\"%lld %lld\\n\",b[j],a[b[j]]); &#125; printf(\"\\n\"); return 0; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"随机化","slug":"随机化","permalink":"https://gaisaiyuno.github.io/tags/随机化/"}]},{"title":"CF914F Substrings in a String","slug":"CF914F-Substrings-in-a-String","date":"2019-07-21T12:05:08.000Z","updated":"2019-07-21T12:24:23.607Z","comments":true,"path":"archives/289007d3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/289007d3.html","excerpt":"","text":"传送门 $bitset$的神奇用法，乍眼一看好像是$KMP$，发现每次都要预处理$next$数组，时间复杂度爆了。 考虑$bitset$（玄学），我们记录这样一个$bitset$ $ a[i][j]$，其中$a[i][j]=1$时，$s[j]$-‘a’$=i$ 大概把字符串$abcabcabc$能转换成这样一个东西： a 1 0 0 1 0 0 1 0 0 b 0 1 0 0 1 0 0 1 0 c 0 0 1 0 0 1 0 0 1 修改非常简单，只要把原来的$1$变成$0$，再把新加进的变成$1$ 考虑如何查询，假设我们查询的是$abc$，我们把$a,b,c$挪到同一列（用位移操作即可完成），如下： a 1 0 0 1 0 0 1 0 0 b 1 0 0 1 0 0 1 0 0 c 1 0 0 1 0 0 1 0 0 用$ans$去和每一列做$and$运算，操作完之后，$ans$大概长成这个样子： ans 1 0 0 1 0 0 1 0 0 发现只有在$i$位后面出现$abc$字符串，$ans[i]$才为$1$。 于是我们发现答案为$\\sum_{i=l}^{r-len+1} ans[i]$（$len$为查询的字符串的长度），前缀和相减即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define MAXM 27using namespace std;bitset&lt;MAXN&gt;B[MAXM];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline char gc()&#123; char ch=getchar(); while (ch&lt;'a'||ch&gt;'z') ch=getchar(); return ch;&#125;int main()&#123; char ch[MAXN]; scanf(\"%s\",ch); int n=strlen(ch); for (register int i=1;i&lt;=n;++i)&#123; B[ch[i-1]-'a'][i]=1; &#125; int q=read(); while (q--)&#123; int opr=read(); if (opr==1)&#123; int i=read(); char c=gc(); B[ch[i-1]-'a'][i]=0; ch[i-1]=c; B[ch[i-1]-'a'][i]=1; &#125; else &#123; int l=read(),r=read(); char y[MAXN]; scanf(\"%s\",y); int len=strlen(y); bitset&lt;MAXN&gt;ans; ans.set();//set是全部变成1 for (register int i=0;i&lt;len;++i)&#123; ans&amp;=(B[y[i]-'a']&gt;&gt;i); &#125; printf(\"%d\\n\",max(0,(int)(ans&gt;&gt;l).count()-(int)(ans&gt;&gt;(r-len+2)).count())); &#125; &#125;&#125; 听说正解是分块+$SAM$，害怕","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"乱搞","slug":"乱搞","permalink":"https://gaisaiyuno.github.io/tags/乱搞/"},{"name":"bitset","slug":"bitset","permalink":"https://gaisaiyuno.github.io/tags/bitset/"}]},{"title":"P2847 [USACO16DEC]Moocast(gold)奶牛广播-金","slug":"P2847-USACO16DEC-Moocast-gold-奶牛广播-金","date":"2019-07-21T09:25:21.000Z","updated":"2019-07-21T09:27:48.944Z","comments":true,"path":"archives/cb6b515c.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/cb6b515c.html","excerpt":"","text":"传送门 并查集+二分答案，假设现在二分到$mid$这个值，把距离小于$mid$的奶牛全部连边，看看最后是不是只剩一个集合。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MAXN 10005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; fa[i]=i; &#125; &#125; int Fa(int i)&#123; return fa[i]==i?i:fa[i]=Fa(fa[i]); &#125; inline void Union(int i,int j)&#123; fa[Fa(i)]=Fa(j); &#125;&#125;;using namespace BCJ;int x[MAXN],y[MAXN];inline int Dist(int i,int j)&#123; return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);&#125;int n,k;inline bool Check(int mid)&#123; Init(); for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=n;++j)&#123; if (Dist(i,j)&lt;=mid)&#123; Union(i,j); &#125; &#125; &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (fa[i]==i) ans++; &#125; return ans==1;&#125;int main()&#123; Init(); n=read(); for (register int i=1;i&lt;=n;++i)&#123; x[i]=read(),y[i]=read(); &#125; int l=0,r=0x7fffffff; while (l&lt;=r)&#123; int mid=(l+r)/2.0; if (Check(mid)) r=mid-1; else l=mid+1; &#125; printf(\"%d\\n\",l);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"},{"name":"二分答案","slug":"二分答案","permalink":"https://gaisaiyuno.github.io/tags/二分答案/"}]},{"title":"P1438 无聊的数列","slug":"P1438-无聊的数列","date":"2019-07-21T09:08:56.000Z","updated":"2019-07-21T09:15:58.800Z","comments":true,"path":"archives/32195edb.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/32195edb.html","excerpt":"","text":"传送门 算是一道非常经典的题，首先，看见等差数列就要下意识地想到差分，考虑把原序列转换为差分序列，发现查询操作就转化为查询前缀和，在区间$[l,r]$加上等差数列就相当于区间$[l+1,r]$加上公差，在$l$上加上首项，最需要注意的是加上等差数列的操作不影响$r$后面的数，于是在$r+1$ 的位置要减去$k+d \\times (r-l)$，抵消前面的影响。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int b[MAXN],a[MAXN],temp[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; inline int len()&#123;return r-l+1;&#125; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; &#125; inline void Change(int i,int val)&#123; tree[i].val+=val*tree[i].len(); tree[i].tag+=val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].val=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Change(i,val); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans+=Query(lc,L,R); if (mid&lt;R) ans+=Query(rc,L,R); return ans; &#125;&#125;using namespace SegmentTree;int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; b[i]=read(); &#125; for (register int i=1;i&lt;=n;++i)&#123; a[i]=b[i]-b[i-1]; &#125; Build(1,1,n); while (m--)&#123; int opr=read(); if (opr==1)&#123; int l=read(),r=read(),k=read(),d=read(); Update(1,l,l,k); if (l&lt;r)&#123; Update(1,l+1,r,d); &#125; if (r!=n) Update(1,r+1,r+1,-k-d*(r-l)); &#125; else if (opr==2)&#123; int p=read(); printf(\"%d\\n\",Query(1,1,p)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"差分","slug":"差分","permalink":"https://gaisaiyuno.github.io/tags/差分/"}]},{"title":"P2507 [SCOI2008]配对","slug":"P2507-SCOI2008-配对","date":"2019-07-21T07:40:37.000Z","updated":"2019-07-21T08:11:48.589Z","comments":true,"path":"archives/ed74f072.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/ed74f072.html","excerpt":"","text":"传送门 假设没有不允许两个相同的数配对的条件，那么直接将$AB$数组排序一遍，每一位每一位配对即可。 现在不允许两个相同的数配对，还是考虑贪心，如果出现如图的匹配情况，即$a[i]$和$b[i-alb]$匹配，其中$alb&gt;2$。 发现这种情况肯定不是最优的，因为我们发现一定存在一个$aj$和$bk$匹配，简单的来说，就是匹配的两条直线相交，可以构造出一种更优的情况如下图。 所以我们只用考虑连续$3$个数，后面大力$dp$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define INF 0x3f3f3f3f#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int A[MAXN],B[MAXN],dp[MAXN];inline int f(int a,int b)&#123; if (a==b) return INF; else return (a&gt;b)?(a-b):(b-a);&#125;#undef intint main()&#123;#define int long long int n=read(); for (register int i=1;i&lt;=n;++i)&#123; A[i]=read(),B[i]=read(); &#125; if (n==1&amp;&amp;A[1]==B[1])&#123; printf(\"-1\\n\"); return 0; &#125; sort(A+1,A+1+n); sort(B+1,B+1+n); dp[0]=0; for (register int i=1;i&lt;=n;++i)&#123; dp[i]=dp[i-1]+f(A[i],B[i]); if (i&gt;=2)&#123; dp[i]=min(dp[i],dp[i-2]+f(A[i],B[i-1])+f(A[i-1],B[i])); &#125; if (i&gt;=3)&#123; dp[i]=min(dp[i],dp[i-3]+f(A[i],B[i-1])+f(A[i-1],B[i-2])+f(A[i-2],B[i])); dp[i]=min(dp[i],dp[i-3]+f(A[i-1],B[i])+f(A[i-2],B[i-1])+f(A[i],B[i-2])); &#125; &#125; printf(\"%lld\\n\",dp[n]);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"贪心","slug":"贪心","permalink":"https://gaisaiyuno.github.io/tags/贪心/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P1663 山","slug":"P1663-山","date":"2019-07-21T07:08:54.000Z","updated":"2019-07-21T07:18:14.672Z","comments":true,"path":"archives/6c8e1123.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/6c8e1123.html","excerpt":"","text":"传送门 首先，将组成山的线段延长，形成许多直线，发现要使得这座山的任何一个部位都能够被看到，灯必须在所有直线之上，假设灯的坐标为$(x,y)$，这可以转化为所有直线上横坐标与之相同的一点$(x,y_0)$，有$y_0 \\le y$，根据贪心的原则，我们根据$x$算出所有$y_0$后，取一个最大值就可以得出$y$。 设根据$x$算出的纵坐标$y$满足$y=f(x)$，我们发现$f(x)$是一个下凸函数，于是三分即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define eps 0.0001#define MAXN 5005using namespace std;double k[MAXN];int x[MAXN],y[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int n;inline double Calc(double m)&#123; double ans=0; for (register int i=1;i&lt;n;++i)&#123; ans=max(ans,(double)y[i]+(m-(double)x[i])*k[i]); &#125; return ans;&#125;int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i)&#123; x[i]=read(),y[i]=read(); &#125; for (register int i=1;i&lt;n;++i)&#123; k[i]=(double)(y[i+1]-y[i])/(double)(x[i+1]-x[i]); &#125; double l=0,r=1000000.0; while (l+eps&lt;r)&#123; double mid1=(l*2.00+r)/3.00,mid2=(l+r*2.00)/3.00; if (Calc(mid1)&lt;Calc(mid2)) r=mid2; else l=mid1; &#125; printf(\"%.2lf\\n\",Calc(l));&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"三分法","slug":"三分法","permalink":"https://gaisaiyuno.github.io/tags/三分法/"}]},{"title":"P5414 [YNOI2019]排序","slug":"P5414","date":"2019-07-21T04:36:05.000Z","updated":"2019-07-21T04:41:58.303Z","comments":true,"path":"archives/fd4f8e0e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/fd4f8e0e.html","excerpt":"","text":"传送门 我们yy一下，一个数不可能被移动超过$2$次，否则就不是最优解，我们可以这么想，移动之后的序列一定是有序的，也就是说它是固定的，问题就转化为钦定几个单调递增的数的位置，它们不移动，移动其它的数，使序列变得有序。 既然要让移动的数的总和尽量小，那就要让没有移动的数的总和尽量大，问题就转化为求序列的和最大的上升子序列，$dp$$O(n^2)$求一下即可。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],dp[MAXN];int main()&#123; int t=read(); while (t--)&#123; int n=read(),sum=0; for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); sum+=a[i]; &#125; memset(dp,0,sizeof(dp)); int maxn=0; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;i;++j)&#123; if (a[j]&lt;=a[i])&#123; dp[i]=max(dp[i],dp[j]); &#125; &#125; dp[i]+=a[i]; maxn=max(dp[i],maxn); &#125; printf(\"%d\\n\",sum-maxn); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P3793 由乃救爷爷","slug":"P3793","date":"2019-07-21T03:42:21.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/8cdf7020.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/8cdf7020.html","excerpt":"","text":"传送门 毒瘤$lxl$数据结构题。 首先，考虑传统的$ST$表，发现$n=2000000$，空间开不下。 考虑分块$+ST$表，每个块里面存的是块内前缀最大值，后缀最大值。 最后$ST$表查询的是块的最大值。 注意查询的区间$[l,r]$在同一块内需要暴力搞一下，发现数据随机，所以出现这种情况不多。 为了卡常数，需要预处理$\\log$，注意查询时要特判$l&gt;r$ 还有一点非常玄学，块大小要开$5000$，要不然会$TLE$ 时间复杂度$O(n+\\log5000 \\times 5000+a \\times 5000 + b)$，其中$a$表示查询区间$[l,r]$在同一块的情况总数，$b$表示查询区间$[l,r]$不在同一块的情况总数。 空间复杂度$O(n+\\log5000 \\times 5000)$，反正不会$MLE$ 注意此代码常数蜃大，提交前需要洗一把脸。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 20000005#define BMAX 5005 //块的最大值#define STMAX 13#define max(a,b) (a&gt;b?a:b)#define min(a,b) (a&lt;b?a:b)using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace GenHelper&#123; unsigned z1,z2,z3,z4,b; inline unsigned rand_()&#123; b=((z1&lt;&lt;6)^z1)&gt;&gt;13; z1=((z1&amp;4294967294U)&lt;&lt;18)^b; b=((z2&lt;&lt;2)^z2)&gt;&gt;27; z2=((z2&amp;4294967288U)&lt;&lt;2)^b; b=((z3&lt;&lt;13)^z3)&gt;&gt;21; z3=((z3&amp;4294967280U)&lt;&lt;7)^b; b=((z4&lt;&lt;3)^z4)&gt;&gt;12; z4=((z4&amp;4294967168U)&lt;&lt;13)^b; return (z1^z2^z3^z4); &#125;&#125;inline void srand(unsigned x)&#123; using namespace GenHelper; z1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;&#125;inline int _read()&#123; using namespace GenHelper; return (rand_()&amp;32767)*32768+(rand_()&amp;32767);&#125;static int Block_L[MAXN],Block_R[MAXN],a[MAXN];static int id[MAXN],lg[BMAX];int Size;//ST表处理Block最大值static int ST[STMAX][BMAX];inline void Init_ST(int n)&#123; for (register int i=1;i&lt;STMAX;++i)&#123; for (register int j=1;j+(1&lt;&lt;i)-1&lt;BMAX;++j)&#123; ST[i][j]=max(ST[i-1][j],ST[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline int Query(int l,int r)&#123; if (l&gt;r) return 0; int k=lg[r-l+1]; return max(ST[k][l],ST[k][r-(1&lt;&lt;k)+1]);&#125;inline void Init(int n)&#123; for (register int i=1;i&lt;=n;++i)&#123;//前缀和 Block_L[i]=(((id[i]-1)*Size+1)==i)?a[i]:max(Block_L[i-1],a[i]); &#125; for (register int i=n;i&gt;=1;--i)&#123;//后缀和 Block_R[i]=(min(id[i]*Size,n)==i)?a[i]:max(Block_R[i+1],a[i]); &#125; for (register int i=1;i&lt;=n;++i)&#123;//整块的最大值 ST[0][id[i]]=max(ST[0][id[i]],a[i]); &#125; Init_ST(n);&#125;#define ull unsigned long longint main()&#123; int n=read(),m=read(),s=read(); srand(s); Size=5000; for (register int i=1;i&lt;=n;++i)&#123; a[i]=_read(); id[i]=(i-1)/Size+1; &#125; lg[0]=-1; for (register int i=1;i&lt;BMAX;++i) lg[i]=lg[i&gt;&gt;1]+1; Init(n); ull ans=0; while (m--)&#123; int l=_read()%n+1,r=_read()%n+1; if (l&gt;r) swap(l,r); if (id[l]==id[r])&#123;//Brute_Force int maxn=0; for (register int i=l;i&lt;=r;++i)&#123; maxn=max(maxn,a[i]); &#125; ans+=(ull)maxn; &#125; else &#123; ans+=(ull)(max(max(Block_L[r],Block_R[l]),Query(id[l]+1,id[r]-1))); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"},{"name":"卡常","slug":"卡常","permalink":"https://gaisaiyuno.github.io/tags/卡常/"},{"name":"分块","slug":"分块","permalink":"https://gaisaiyuno.github.io/tags/分块/"},{"name":"ST表","slug":"ST表","permalink":"https://gaisaiyuno.github.io/tags/ST表/"}]},{"title":"CF833B The Bakery 线段树 动态规划","slug":"CF833B","date":"2019-07-20T13:25:26.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/90b6ba83.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/90b6ba83.html","excerpt":"","text":"传送门 建议先做这道题，有一些套路是一模一样的。 考虑如何$dp$，$dp[i][j]$表示现在扫到第$i$个数，用了$j$段区间，最大的总价值，$cnt(l,r)$表示在区间$[l,r]$中不同的数的个数。 考虑在区间$[1,p]$分段，很容易列出$dp$方程： dp[i][j]=\\max \\{ dp[p][j-1]+cnt(p+1,i) \\}其中1 \\le p \\le i-1 容易算出，枚举$i$复杂度为$O(k)$，枚举$p$复杂度为$O(n)$，计算$cnt$复杂度为$O(n)$ 总复杂度为$O(n^2k)$，会$TLE$ 考虑如何优化，发现复杂度瓶颈在寻找最大值和计算$cnt$，考虑线段树优化。 考虑计算数组$lst[i]$，表示颜色$a[i]$上一次出现的地方，这个$O(n)$ 在输入时预处理即可。 对于$dp$数组每一层，每次跑$dp$都重建一个线段树。 发现枚举到$a[i]$，$[lst[i],i-1]$都要$+1$，因为只有对于区间$[p,i] (p \\in [lst[i],i-1])$，$a[i]$才算新出现的元素。 查询时，查询$[0,j-1]$$dp$数组最大值即可。 时间复杂度$O(kn\\log n)$ 代码里面$dp$数组下标从$0$开始是为了更方便地计算$[0,j-1]$$dp$数组最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define MAXN 35005#define MAXM 51using namespace std;int dp[MAXM][MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int maxn,tag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; tree[lc].tag+=tree[i].tag; tree[lc].maxn+=tree[i].tag; tree[rc].tag+=tree[i].tag; tree[rc].maxn+=tree[i].tag; tree[i].tag=0; &#125; &#125; void Build(int i,int lev,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].tag=0; if (l==r)&#123; tree[i].maxn=dp[lev][l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,lev,l,mid); Build(rc,lev,mid+1,r); pushup(i); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].maxn+=val; tree[i].tag+=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; pushdown(i); if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; pushdown(i); if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;int lst[MAXN],lstcolor[MAXN];int a[MAXN];//lst[i]表示a[i]这种颜色最后出现的位置//lstcolor[i]表示颜色i最后出现的位置//类似于一个链表吧。。。int main()&#123; int n=read(),k=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); lst[i]=lstcolor[a[i]]; lstcolor[a[i]]=i; &#125; for (register int i=1;i&lt;=k;++i)&#123; Build(1,i-1,0,n); for (register int j=1;j&lt;=n;++j)&#123; Update(1,lst[j],j-1,1); dp[i][j]=Query(1,0,j-1); &#125; &#125; printf(\"%d\\n\",dp[k][n]);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"P2114 [NOI2014]起床困难综合症","slug":"P2114-NOI2014-起床困难综合症","date":"2019-07-20T12:27:11.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/728a6040.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/728a6040.html","excerpt":"","text":"传送门 首先，我们发现位运算和十进制的加减乘除不一样，位运算对于每一位都是独立的，而加减乘除会产生进位，在一位上的操作会影响另一位。 我们可以这样理解，对于一大堆不知道是蜃么奇奇怪怪的$And$，$Or$，$Xor$ ，我们可以算出来一个函数$f(x,pos)$（其中$x=0,1$且$f(x,pos)=0,1$），使得原数上$pos$位置的$x$，经过操作之后对应位置上一定是$f(x)$。 考虑如何计算$f(x)$，发现只要搞一个全是$1$的数和一个全是$0$的数，按照题目意思给他操作一遍，操作完的数对应到$pos$位上，一定是$f(1,pos)$和$f(0,pos)$（因为位运算每一位都是独立的） 算出来$f(x)$就好做了，我们考虑贪心， 可以由$0$变成$1$，那么肯定要变 可以由$1$变成$1$，也要变 可以由$0$变成$0$，不用变（因为$0$已经是最小的可能数了） 可以由$1$变成$0$，这样一搞反而亏本了，肯定不用变 详细细节见代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAXM 30using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;inline char gc()&#123; char ch=getchar(); while (ch!='A'&amp;&amp;ch!='O'&amp;&amp;ch!='X') ch=getchar(); return ch;&#125;int main()&#123; int n=read(),m=read(); int f1=0x7fffffff,f0=0; for (register int i=1;i&lt;=n;++i)&#123; char opr=gc(); int x=read(); if (opr=='A') f0&amp;=x,f1&amp;=x; if (opr=='O') f0|=x,f1|=x; if (opr=='X') f0^=x,f1^=x; &#125; int ans=0; for (register int i=MAXM;i&gt;=0;--i)&#123; if (f0&amp;(1&lt;&lt;i))&#123; ans|=(1&lt;&lt;i); &#125; else if ((1&lt;&lt;i)&lt;=m&amp;&amp;(f1&amp;(1&lt;&lt;i)))&#123; ans|=(1&lt;&lt;i); m-=(1&lt;&lt;i); &#125; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"贪心","slug":"贪心","permalink":"https://gaisaiyuno.github.io/tags/贪心/"},{"name":"位运算","slug":"位运算","permalink":"https://gaisaiyuno.github.io/tags/位运算/"}]},{"title":"P3116 [USACO15JAN]约会时间Meeting Time 拓扑排序","slug":"P3116-USACO15JAN-约会时间Meeting-Time","date":"2019-07-15T13:30:40.000Z","updated":"2019-07-27T03:05:54.062Z","comments":true,"path":"archives/abe8eb3f.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/abe8eb3f.html","excerpt":"","text":"考虑$\\rm dp$，其中$f1[i][j]$表示由起点到达$i$，走的是路径$1$，路径总长度为$j$的方法可不可行，$f2$类似，拓扑排序的过程中大力转移即可。 转移过程类似背包问题。 好像可以用$\\rm bitset$优化，少一些常数。 注意输出$\\rm IMPOSSIBLE!$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 105#define MAXE 10005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;struct Edge&#123; int to,l1,l2;&#125;;vector&lt;Edge&gt;G[MAXN];int in[MAXN];inline void AddEdge(int u,int v,int l1,int l2)&#123; in[v]++; Edge temp; temp.to=v; temp.l1=l1; temp.l2=l2; G[u].push_back(temp);&#125;int f1[MAXN][MAXE],f2[MAXN][MAXE];int main()&#123; int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),l1=read(),l2=read(); AddEdge(u,v,l1,l2); &#125; queue&lt;int&gt;Q; for (register int i=1;i&lt;=n;++i)&#123; if (!in[i]) Q.push(i); &#125; f1[1][0]=f2[1][0]=true; while (Q.size())&#123;//拓扑排序 int u=Q.front();Q.pop(); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,l1=G[u][i].l1,l2=G[u][i].l2; in[v]--; for (register int j=0;j&lt;MAXE;++j)&#123;//顺便统计一下dp if (j+l1&lt;MAXE) f1[v][j+l1]|=f1[u][j]; if (j+l2&lt;MAXE) f2[v][j+l2]|=f2[u][j]; &#125; if (!in[v]) &#123; Q.push(v); &#125; &#125; &#125; for (register int i=0;i&lt;MAXE;++i)&#123; if (f1[n][i]&amp;&amp;f2[n][i]) &#123; printf(\"%d\\n\",i); return 0; &#125; &#125; printf(\"IMPOSSIBLE\");&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://gaisaiyuno.github.io/tags/拓扑排序/"}]},{"title":"P2341 [HAOI2006]受欢迎的牛 暴力","slug":"P2341 [HAOI2006]受欢迎的牛","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/aaab3e1b.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/aaab3e1b.html","excerpt":"","text":"传送门这道题可以用暴力水过，不用$tarjan$思路：将奶牛看成节点，反向建边，对于一只奶牛，跑一边暴力$dfs$，判断能不能到达其他所有奶牛，然后加一些小小的剪枝就可以过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//n方过百万，暴力碾标算//我相信：暴力出奇迹 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAXN 10005using namespace std;int vis[MAXN];int is_all[MAXN];//是否全部被欢迎:-1不确定，1：全部被欢迎，0：不全部被欢迎 int sz[MAXN];int haveans;vector&lt;int&gt;G[MAXN];void dfs(int u)&#123; if (haveans==1)&#123; return ; &#125; for (register int i=0;i&lt;sz[u];++i)&#123; if (!vis[G[u][i]])&#123; vis[G[u][i]]=true; if (is_all[G[u][i]]==1)&#123;//剪枝1：当搜索到一只奶牛，从它出发能到达所有奶牛，则从这只奶牛出发能够到达所有奶牛 haveans=is_all[G[u][i]]; return ; &#125; dfs(G[u][i]); &#125; &#125;&#125;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for (register int i=0;i&lt;m;++i)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); vis[u]=true,vis[v]=true; G[v].push_back(u); &#125; bool flag=false; for (register int i=1;i&lt;=n;++i)&#123; if (vis[i]==0)&#123; flag=true; break; &#125; &#125; if (flag==true)&#123;//第二个剪枝，如果有奶牛没有在图中，则答案为0 printf(\"0\\n\"); return 0; &#125; for (register int i=1;i&lt;=n;++i)&#123; sort(G[i].begin(),G[i].end()); sz[i]=unique(G[i].begin(),G[i].end())-G[i].begin(); &#125; int sum=0; memset(is_all,-1,sizeof(is_all)); for (register int i=1;i&lt;=n;++i)&#123; if (is_all[i]==0)&#123;//无法到达所有奶牛 continue; &#125; haveans=-1; memset(vis,0,sizeof(vis)); vis[i]=true; dfs(i); if (haveans==1)&#123; is_all[i]=1; sum++; &#125; else if (haveans==-1)&#123; bool flag=false; for (register int j=1;j&lt;=n;++j)&#123; if (vis[j]==0)&#123; flag=true; break; &#125; &#125; if (flag==false)&#123; is_all[i]=1; sum++; &#125; else &#123; for (register int j=1;j&lt;=n;++j)&#123; if (vis[j]) is_all[j]=0; &#125; //这个剪枝很重要，如果此奶牛无法到达所有奶牛， //那么此奶牛能够到达的所有奶牛无法到达所有奶牛(有点绕口qwq) &#125; &#125; &#125; printf(\"%d\\n\",sum);&#125; 然后就可以水过了，膜拜各个大佬的$tarjan$","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"搜索","slug":"搜索","permalink":"https://gaisaiyuno.github.io/tags/搜索/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"}]},{"title":"SP1716 GSS3 - Can you answer these queries III 线段树","slug":"SP1716 GSS3 - Can you answer these queries III","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/663570ad.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/663570ad.html","excerpt":"","text":"建议先做SP1043 GSS1 - Can you answer these queries I传送门没什么好讲的，也就是在GSS1的基础上加一个修改，连pushdown都不要。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int lmax,rmax,maxn;//从左端开始最大值，从右端开始最大值，整段最大值 int val;//这段的和 &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 node operator + (node A,node B)&#123; node temp; temp.lmax=max(B.lmax+A.val,A.lmax); temp.rmax=max(A.rmax+B.val,B.rmax); temp.maxn=max(max(A.maxn,B.maxn),A.rmax+B.lmax); temp.val=A.val+B.val; temp.l=A.l,temp.r=B.r; return temp; &#125; void pushup(int i)&#123; tree[i]=tree[lc]+tree[rc]; &#125; void Build(int l,int r,int i)&#123; if (l==r)&#123; tree[i].lmax=tree[i].rmax=tree[i].maxn=tree[i].val=a[l]; tree[i].l=tree[i].r=l; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); pushup(i); &#125; node Query(int L,int R,int i)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i]; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&gt;mid) return Query(L,R,rc); else if (R&lt;=mid) return Query(L,R,lc); else return Query(L,R,lc)+Query(L,R,rc); &#125; void Update(int index,int i,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].lmax=tree[i].rmax=tree[i].maxn=tree[i].val=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) Update(index,lc,val); else Update(index,rc,val); pushup(i); &#125;&#125;;using namespace SegmentTree;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,n,1); int q=read(); while (q--)&#123; int opr=read(),L=read(),R=read(); if (opr==0)&#123; Update(L,1,R); &#125; else &#123; printf(\"%d\\n\",Query(L,R,1).maxn); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"LibreOJ NOIP Round 1 DNA 序列 字符串哈希","slug":"#537. 「LibreOJ NOIP Round #1」DNA 序列","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/218c88fe.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/218c88fe.html","excerpt":"","text":"模拟赛一开始的时候以为有$26$个英文字母，想了半天。。。后来发现只有$4$个字母$\\rm A,T,C,G$，就发现这题水了。因为$4^{10}=1048576$数组能开的下，考虑把每$k$个字母装压在一个$\\rm int$里面我们就得到了一种$O(nk)$的做法： 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define MAXN 5000005#define MAXM 1050000using namespace std;char ch[MAXN];int cnt[MAXN];const int val[26]=&#123;0,0,2,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0&#125;;//打一个表 A:0 T:1 C:2 G:3const char st[4]=&#123;'A','T','C','G'&#125;;int main()&#123; int n=0; while (true)&#123; char c=getchar(); if (c=='\\n') break; else ch[++n]=c; &#125; int k; scanf(\"%d\",&amp;k); for (register int i=1;i&lt;=n-k+1;++i)&#123; int ans=0; for (register int j=i;j&lt;=i+k-1;++j)&#123; ans=ans*4+val[ch[j]-'A']; &#125; cnt[ans]++; &#125; int maxn=0; for (register int i=0;i&lt;MAXM;++i)&#123; if (cnt[i]&gt;maxn) maxn=cnt[i]; &#125; printf(\"%d\\n\",maxn);&#125; 后来发现还有一种$O(n)$的做法：发现这个求哈希的过程类似于一个滑动窗口，每次取出最前的数，加入末尾的数。于是只用考虑这两个移动就可以了 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAXN 5000005#define MAXM 1050000using namespace std;int ch[MAXN],cnt[MAXN];const int val[26]=&#123;0,0,2,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0&#125;;int main()&#123; int n=0; while (true)&#123; char c=getchar(); if (c=='\\n') break; else ch[++n]=val[c-'A']; &#125; int k; scanf(\"%d\",&amp;k); int now=0; int pw=1; for (register int i=1;i&lt;=k;++i)&#123; now=now*4+ch[i]; pw*=4; &#125; cnt[now]++; for (register int i=2;i&lt;=n-k+1;++i)&#123; now-=ch[i-1]*pw/4; now*=4; now+=ch[i+k-1]; cnt[now]++; &#125; int maxn=0; for (register int i=0;i&lt;MAXM;++i)&#123; if (cnt[i]&gt;maxn) maxn=cnt[i]; &#125; printf(\"%d\\n\",maxn);&#125; 话说也没比$O(nk)$快多少","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"哈希","slug":"哈希","permalink":"https://gaisaiyuno.github.io/tags/哈希/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"https://gaisaiyuno.github.io/tags/字符串哈希/"}]},{"title":"SP2713 GSS4 - Can you answer these queries IV 线段树","slug":"SP2713 GSS4 - Can you answer these queries IV","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/491bd6e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/491bd6e.html","excerpt":"","text":"传送门注意到开方是向下取整的，而且$\\sum a_i \\le 10^{18}$所以我们发现没开几次方，大部分$a_i$都会变成$1$，此时再怎么开方，$a_i$还是$1$，所以不用修改$a_i$所以想到开一个$flag$，记录这个区间是不是都是$1$若区间都是$1$修改时直接跳过1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; bool flag; int val;//这段的和 &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; tree[i].flag=tree[lc].flag&amp;tree[rc].flag; &#125; void Init()&#123; memset(tree,0,sizeof(tree)); &#125; void Build(int l,int r,int i)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].val=a[l]; if (tree[i].val==1) tree[i].flag=true; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); pushup(i); &#125; void Update(int L,int R,int i)&#123;//暴♂力update if (tree[i].flag) return ; if (tree[i].l==tree[i].r)&#123; tree[i].val=(int)(sqrt(tree[i].val)); if (tree[i].val==1) tree[i].flag=true; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(L,R,i&lt;&lt;1); if (mid&lt;R) Update(L,R,i&lt;&lt;1|1); pushup(i); &#125; int Query(int L,int R,int i)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int ans=0; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) ans+=Query(L,R,i&lt;&lt;1); if (mid&lt;R) ans+=Query(L,R,i&lt;&lt;1|1); return ans; &#125;&#125;;using namespace SegmentTree;#undef intint main()&#123;#define int long long //freopen(\"1.in\",\"r\",stdin); int n,cnt=0; while (scanf(\"%lld\",&amp;n)!=EOF)&#123; for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Init(); Build(1,n,1); int q=read(); printf(\"Case #%lld:\\n\",++cnt); while (q--)&#123; int opr=read(),l=read(),r=read(); if (l&gt;r) swap(l,r); if (opr==0)&#123; Update(l,r,1); &#125; else &#123; printf(\"%lld\\n\",Query(l,r,1)); &#125; &#125; printf(\"\\n\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"P1486 [NOI2004]郁闷的出纳员 FHQ Treap","slug":"P1486 [NOI2004]郁闷的出纳员","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/41dcc859.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/41dcc859.html","excerpt":"","text":"传送门这道题比较有意思考虑记录一个$tag$表示员工工资应该加上多少。加工资的操作不会导致员工离开但是扣工资的操作会导致工资所有小于$min-tag$的员工离开 怎么删除所有小于$min-tag$的值呢？yy一下，发现FHQ Treap中$num$左子树的值都小于num于是每次删除所有小于$min-tag$的值时，删除其左子树即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz; &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k)&#123;x=i,Split(rc(i),k,rc(i),y);&#125; else&#123;y=i,Split(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; int kth(int i,int k)&#123;//排名为k while (true)&#123; if (k&lt;=tree[lc(i)].sz)&#123; i=lc(i); &#125; else if (k==tree[lc(i)].sz+1)&#123; return i; &#125; else&#123; k-=tree[lc(i)].sz+1; i=rc(i); &#125; &#125; &#125; //以上为FHQ Treap int root,x,y,z; void Init()&#123; tot=0; memset(tree,0,sizeof(tree)); root=0; srand(19260817); &#125; inline void Add(int num)&#123; Split(root,num,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int num)&#123; Split(root,num,x,z); Split(x,num-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125; #define Get_K(rt,rk) tree[kth(rt,rk)].val inline int Kth(int k)&#123;//获得数组中第k大 if (tree[root].sz&lt;k) return -1; return Get_K(root,tree[root].sz-k+1); &#125; inline int Pre(int num)&#123; Split(root,num-1,x,y); int temp=Get_K(x,tree[x].sz); root=Merge(x,y); return temp; &#125; inline int Delete_Pre(int num)&#123; //删除全部小于num的数，直接删除左子树 Split(root,num-1,x,y);//x:左边 root=y; return tree[x].sz; &#125;&#125;;using namespace FHQ_Treap;#define INF 0x3f3f3f3finline char gc()&#123; char ch=getchar(); while (ch!='I'&amp;&amp;ch!='A'&amp;&amp;ch!='S'&amp;&amp;ch!='F') ch=getchar(); return ch;&#125;int main()&#123; Init(); // Add(INF),Add(-INF); int n=read(),Min=read(); int tag=0;//每个人的工资加上多少，类似于lazytag int sum=0; while (n--)&#123; char opr=gc(); int num=read(); if (opr=='I')&#123; if (num&lt;Min)&#123;continue;&#125;//员工直接离开 Add(num-tag); &#125; else if (opr=='A')&#123; tag+=num;//加工资的操作不会导致员工离开 &#125; else if (opr=='S')&#123; tag-=num; sum+=Delete_Pre(Min-tag); &#125; else if (opr=='F')&#123; int ans=Kth(num); if (ans==-1) printf(\"-1\\n\"); else printf(\"%d\\n\",ans+tag); &#125; &#125; printf(\"%d\\n\",sum);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"SP5973 SELTEAM - Selecting Teams","slug":"SP5973 SELTEAM - Selecting Teams","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/d0c5fa.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d0c5fa.html","excerpt":"","text":"传送门 考虑先选$p$名队员，方法数为$C^p_n$，其中$1\\le p\\le k$，然后从$p$名队员中钦定一名队长，方法数为$p$，其他的队员可选可不选，有$2^{p-1}$种方法。所以总的方案数为 \\sum^k_{p=1}C^p_n \\times p \\times 2^{p-1}但是这似乎也没什么用，算这个式子的复杂度为$O(k)$，有$T$组数据，总复杂度为$O(Tk)$。经过一(cha)番(zhao)思(ti)考(jie)后发现模数$8388608=2^{23}$，所以对于$p \\ge 24$，$C^p_n \\times p \\times 2^{p-1}=0$，可以不用考虑。所以单次查询时间复杂度为$O(min(k,23))$，总复杂度为$O(min(k,23) \\times T)$，可以过。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define MOD 8388608#define MAXN 1000005#define MAXK 30#define ll long longusing namespace std;ll C[MAXN][MAXK],pow2[MAXK];inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; C[i][0]=1; for (register int j=1;j&lt;=min(23,i);++j)&#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; &#125; &#125; pow2[0]=1; for (register int i=1;i&lt;MAXK;++i)&#123; pow2[i]=pow2[i-1]&lt;&lt;1ll; &#125;&#125;int main()&#123; Init(); int T; scanf(\"%d\",&amp;T); while (T--)&#123; ll n,k; scanf(\"%lld%lld\",&amp;n,&amp;k); ll ans=0; for (register int i=1;i&lt;=min(k,23ll);++i)&#123; ans=(ans+pow2[i-1]*(ll)i*C[n][i])%MOD; &#125; printf(\"%lld\\n\",ans); &#125;&#125; p.s.这种在模数上下坑的题目我还是第一次见到","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"组合数","slug":"组合数","permalink":"https://gaisaiyuno.github.io/tags/组合数/"}]},{"title":"SP4487 GSS6 - Can you answer these queries VI 平衡树","slug":"SP4487 GSS6 - Can you answer these queries VI","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/6442638e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/6442638e.html","excerpt":"","text":"建议先做SP1043 GSS1 - Can you answer these queries I传送门我们可以用$FHQ Treap$做这道题。首先，$FHQ Treap$最重要的是Merge和Split操作，Split按照权值split但是这道题插入删除修改时，要按照分出序列前$k$个值，是不是没法做？没关系，我们采用类似于FindKth的方法split，即按照节点的子树大小split就可以方便地分出序列前$k$个值了 然后其他的就没有别的什么特别的了。在提取区间时只需要split一下$r$，然后split一下$l-1$，分成的三棵子树中中间的那棵子树就是维护$l ~ r$的节点的子树了。还有tree[0].maxn要初始化，这一点非常孙 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz; int sum; int lmax,rmax; int maxn; &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r //注意fhq treap和线段树不同：根节点不会算 inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; tree[x].sum=tree[lc(x)].sum+tree[rc(x)].sum+tree[x].val; tree[x].lmax=max(tree[lc(x)].lmax,tree[lc(x)].sum+tree[x].val+tree[rc(x)].lmax); tree[x].rmax=max(tree[rc(x)].rmax,tree[lc(x)].rmax+tree[x].val+tree[rc(x)].sum); tree[x].maxn=max(max(tree[lc(x)].maxn,tree[rc(x)].maxn),tree[lc(x)].rmax+tree[x].val+tree[rc(x)].lmax); &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; tree[tot].maxn=tree[tot].sum=v; tree[tot].lmax=tree[tot].rmax=max(v,0); return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; //这是按照权值split的方法 /* void SplitByVal(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k)&#123;x=i,SplitByVal(rc(i),k,rc(i),y);&#125; else&#123;y=i,SplitByVal(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; */ void Split(int i,int k,int &amp;x,int &amp;y)&#123; //按照排名split，就可以方便地在数组k位置插入val(妙啊) if (!i) &#123; x=y=0; &#125; else &#123; if (tree[lc(i)].sz&gt;=k) &#123;y=i,Split(lc(i),k,x,lc(i));&#125;//在左子树 else &#123;x=i,Split(rc(i),k-tree[lc(i)].sz-1,rc(i),y);&#125;//在右子树 Update(i); &#125; &#125; //以上为FHQ Treap int root,x,y,z; void Init()&#123; tot=0,root=0; memset(tree,0,sizeof(tree)); srand(19260817); &#125; inline void Add(int pos,int num)&#123;//在pos插入num Split(root,pos,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int pos)&#123;//删除pos处元素 Split(root,pos,x,z); Split(x,pos-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125;&#125;;using namespace FHQ_Treap;inline char gc()&#123; char ch=getchar(); while (ch!='I'&amp;&amp;ch!='D'&amp;&amp;ch!='R'&amp;&amp;ch!='Q') ch=getchar(); return ch;&#125;int main()&#123; Init(); int n=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(); root=Merge(root,New(x)); &#125; tree[0].maxn=-0x7fffffff;//Very Important int q=read(); while (q--)&#123; char opr=gc(); if (opr=='I')&#123; int p=read(),x=read(); Add(p-1,x); &#125; else if (opr=='D')&#123; int p=read(); Del(p); &#125; else if (opr=='R')&#123; int p=read(),x=read(); Del(p),Add(p-1,x); &#125; else &#123; int l=read(),r=read(); //舍弃r右子树 舍弃l左子树 Split(root,r,x,z); Split(x,l-1,x,y); printf(\"%d\\n\",tree[y].maxn); root=Merge(Merge(x,y),z); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"SP6779 GSS7 - Can you answer these queries VII 树链剖分","slug":"SP6779 GSS7 - Can you answer these queries VII","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/373d1617.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/373d1617.html","excerpt":"","text":"建议先做SP1043 GSS1 - Can you answer these queries I传送门树链剖分模板题尽管如此，这道题还是孙了我甚久。坑点：在查询的时候，因为两条树链$L,R$是左右对称的，所以不能直接将两条树链合并计算，而是先翻转$L$或$R$，再合并计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; return x*f;&#125;void swap(int &amp;a,int &amp;b)&#123; int temp=a;a=b;b=temp;&#125;vector&lt;int&gt;G[MAXN];inline void AddEdge(int u,int v)&#123; G[u].push_back(v); G[v].push_back(u);&#125;int a[MAXN],size[MAXN],fa[MAXN],dep[MAXN],top[MAXN],id[MAXN],Bigson[MAXN];int cnt;void dfs(int u,int father)&#123; size[u]=1; dep[u]=dep[father]+1; fa[u]=father; for (int i=0;i&lt;(int)G[u].size();i++)&#123; if (G[u][i]!=father)&#123; dfs(G[u][i],u); size[u]+=size[G[u][i]]; if (size[G[u][i]]&gt;size[Bigson[u]])&#123; Bigson[u]=G[u][i]; &#125; &#125; &#125;&#125;int seq[MAXN];void dfs2(int u,int Top)&#123; top[u]=Top;id[u]=++cnt; seq[cnt]=u; if (!Bigson[u]) return ; dfs2(Bigson[u],Top); for (int i=0;i&lt;(int)G[u].size();i++)&#123; if (G[u][i]!=fa[u]&amp;&amp;G[u][i]!=Bigson[u])&#123; dfs2(G[u][i],G[u][i]); &#125; &#125;&#125;int n;//可以直接把GSS1的模板拿过来用namespace SegmentTree&#123; struct node&#123; int lmax,rmax,maxn; //从左端开始最大值，从右端开始最大值，整段最大值 int val;//这段的和 int tag,flag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 node empty_node()&#123; node temp; temp.lmax=temp.rmax=temp.maxn=temp.val=0; return temp; &#125; node operator + (node A,node B)&#123; node temp; temp.lmax=max(B.lmax+A.val,A.lmax); temp.rmax=max(A.rmax+B.val,B.rmax); temp.maxn=max(max(A.maxn,B.maxn),A.rmax+B.lmax); temp.val=A.val+B.val; temp.tag=temp.flag=0; return temp; &#125; inline void change(int i,int val,int l,int r)&#123; tree[i].val=(r-l+1)*val; tree[i].lmax=tree[i].rmax=tree[i].maxn=max(0,tree[i].val); tree[i].tag=val,tree[i].flag=1; &#125; void pushdown(int i,int l,int r)&#123; if (tree[i].flag)&#123; int mid=(l+r)&gt;&gt;1; change(lc,tree[i].tag,l,mid); change(rc,tree[i].tag,mid+1,r); tree[i].tag=tree[i].flag=0; &#125; &#125; void Build(int l,int r,int i)&#123; if (l==r)&#123; tree[i].val=a[seq[l]]; tree[i].lmax=tree[i].rmax=tree[i].maxn=max(tree[i].val,0);//注意可以为空 tree[i].flag=0; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); tree[i]=tree[lc]+tree[rc]; &#125; node _Query(int l,int r,int L,int R,int i)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; return tree[i]; &#125; pushdown(i,l,r); int mid=(l+r)&gt;&gt;1; node ans1=empty_node(),ans2=empty_node(); if (L&lt;=mid) ans1=_Query(l,mid,L,R,lc); if (mid&lt;R) ans2=_Query(mid+1,r,L,R,rc); return ans1+ans2; &#125; node Query(int L,int R)&#123; return _Query(1,n,L,R,1); &#125; void _Update(int l,int r,int L,int R,int i,int val)&#123; if (L&lt;=l&amp;&amp;r&lt;=R)&#123; change(i,val,l,r); return ; &#125; pushdown(i,l,r); int mid=(l+r)&gt;&gt;1; if (L&lt;=mid) _Update(l,mid,L,R,lc,val); if (mid&lt;R) _Update(mid+1,r,L,R,rc,val); tree[i]=tree[lc]+tree[rc]; &#125; void Update(int L,int R,int val)&#123; _Update(1,n,L,R,1,val); &#125;&#125;;using namespace SegmentTree;inline void Update_Tree(int u,int v,int val)&#123; int fu=top[u],fv=top[v]; while (fu!=fv)&#123; if (dep[fu]&lt;dep[fv]) swap(u,v),swap(fu,fv); Update(id[fu],id[u],val); u=fa[fu];fu=top[u]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); Update(id[u],id[v],val);&#125;inline node Query_Tree(int u,int v)&#123; node L=empty_node(),R=empty_node(); //L为左半边,R为右半边，因为L,R对称所以要分别计算 int fu=top[u],fv=top[v]; while (fu!=fv)&#123; if (dep[fu]&lt;dep[fv])&#123; R=Query(id[fv],id[v])+R; v=fa[fv],fv=top[v]; &#125; else &#123; L=Query(id[fu],id[u])+L; u=fa[fu],fu=top[u]; &#125; &#125; if (dep[u]&gt;dep[v])&#123; L=Query(id[v],id[u])+L; &#125; else &#123; R=Query(id[u],id[v])+R; &#125; swap(L.lmax,L.rmax);//翻转L return L+R;&#125;int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for (register int i=1;i&lt;n;++i)&#123; int u=read(),v=read(); AddEdge(u,v); &#125; dfs(1,0);dfs2(1,1); Build(1,n,1); int q=read(); while (q--)&#123; int opr=read(),l=read(),r=read(); if (opr==1)&#123; printf(\"%d\\n\",Query_Tree(l,r).maxn); &#125; else &#123; int val=read(); Update_Tree(l,r,val); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://gaisaiyuno.github.io/tags/树链剖分/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"U77080 大水题 裴蜀定理","slug":"U77080 大水题","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/efdb3cc7.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/efdb3cc7.html","excerpt":"","text":"传送门巨佬zyd出的一道题 裴蜀定理：对于正整数$a,b$，方程$ax+by=c$有解的充分必要条件为$gcd(a,b)|c$ 我们设$gcd(a,b)=d$，$\\frac{a}d = a′$，$\\frac{b}d = b′$，$\\frac{c}d = c′$首先证明充分条件：若$gcd(a,b)|c$则$c′$为整数，原方程两边同时除以$d$，方程化为：$a′x+b′y=c′$，即$a′x=c′ \\pmod {b′}$，显然$a′,b′$两两互质，根据extgcd，我们知道这个方程一定有整数解。充分性得证 再证明必要条件：用反证法若$gcd(a,b)不整除c$则$c’$不为整数，原方程两边同时除以$d$，方程化为：$a′x+b′y=c′$，等式左边为整数，右边不为整数，所以无解。必要性得证 回到本题，发现这是一种裴蜀定理推广到$n$个数的情况即$a_1x_1+a_2x_2+a_3x_3…a_nx_n=b$有解的充分必要条件为$gcd(a_1,a_2,a_3…a_n)|b$又因为$b$为正整数，所以$b_{min}=gcd(a_1,a_2,a_3…a_n)$ 代码：1234567891011121314151617181920212223242526// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123;//这个read自动忽略负数 int x=0; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x;&#125;int gcd(int jzm,int xjp)&#123; return jzm%xjp==0?xjp:gcd(xjp,jzm%xjp);&#125;int main()&#123; int n=read(); int ans=read(); for (register int i=2;i&lt;=n;++i)&#123; ans=gcd(ans,read()); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"CF1006F Xor-Paths 双向搜索","slug":"CF1006F Xor-Paths","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.355Z","comments":true,"path":"archives/65461872.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/65461872.html","excerpt":"","text":"传送门 题解双向搜索，$Map[x][y][n]$表示搜索到$(x,y)$异或和为n有多少种方法。还要利用异或的性质： 1(a^b)^b=a 记得开long long12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#include &lt;hash_map&gt;#define MAXN 25#define int long longusing namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;#define inside(x,y) 1&lt;=x&amp;&amp;x&lt;=n&amp;&amp;1&lt;=y&amp;&amp;y&lt;=munordered_map&lt;int,int&gt;Map[MAXN][MAXN];int G[MAXN][MAXN],n,m,k;void dfs1(int x,int y,int Sum)&#123; if (x+y==n+1)&#123;Map[x][y][Sum]++;return ;&#125;//必定经过对角线 if (inside(x+1,y)) dfs1(x+1,y,Sum^G[x+1][y]); if (inside(x,y+1)) dfs1(x,y+1,Sum^G[x][y+1]);&#125;int ans;void dfs2(int x,int y,int Sum)&#123; if (x+y==n+1)&#123; ans+=Map[x][y][Sum^k^G[x][y]];//G[x][y]重复算了一遍 return ; &#125; if (inside(x-1,y)) dfs2(x-1,y,Sum^G[x-1][y]); if (inside(x,y-1)) dfs2(x,y-1,Sum^G[x][y-1]);&#125;#undef intint main()&#123;#define int long long n=read(),m=read(),k=read(); for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=m;++j)&#123; G[i][j]=read(); &#125; &#125; dfs1(1,1,G[1][1]); dfs2(n,m,G[n][m]); printf(\"%lld\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"搜索","slug":"搜索","permalink":"https://gaisaiyuno.github.io/tags/搜索/"},{"name":"双向搜索","slug":"双向搜索","permalink":"https://gaisaiyuno.github.io/tags/双向搜索/"}]},{"title":"P1259 黑白棋子的移动 找规律","slug":"P1259 黑白棋子的移动","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/aa159f1d.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/aa159f1d.html","excerpt":"","text":"传送门我们先分析一下样例1234567891011121314151617ooooooo*******--oooooo--******o*oooooo******--o*ooooo--*****o*o*ooooo*****--o*o*oooo--****o*o*o*oooo****--o*o*o*ooo--***o*o*o*o*ooo*o**--*o*o*o*o--*o**oo*o*o*o*o*o*o*--o*o*o*o*--o*o*o*o*o*o*o* 每两行分一组的时候,可以很明显地看到规律. 中间的 “o*” 与 “—“ 交换 最左边的 “**” 与 “—“ 交换 然而后四行我并没有发现什么规律,于是无耻地打了一个表. 打表原理: 12345678910ooo*o**--* o*o*o*o--*o**oo* o*o*o*o*o*o*--o* o*o*o*--o*o*o*o* o*o*o*后6个字符为固定的&quot;o*o*o*&quot;于是只要记录 ooo*o**--*, o--*o**oo*, o*o*o*--o*, --o*o*o*o* 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n;char ch[205];//存储棋子的状态void swap(char &amp;a, char &amp;b)//交换函数&#123; char t = a; a = b; b = t;&#125;void output()&#123;//输出 for (int i = 0; i &lt; 2 * n + 2; i++) putchar(ch[i]); putchar('\\n');&#125;void movechess(int start, int end)&#123;//移动棋子 swap(ch[start], ch[end]); swap(ch[start + 1], ch[end + 1]); output();&#125;string out[4] = &#123;\"ooo*o**--*\", \"o--*o**oo*\", \"o*o*o*--o*\", \"--o*o*o*o*\"&#125;;//打表qwqint main()&#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) ch[i] = 'o'; for (int i = n; i &lt; 2 * n; i++) ch[i] = '*'; ch[2 * n] = '-'; ch[2 * n + 1] = '-'; //打印初始状态 output(); int len = n; //需要移动的黑/白棋子 while (true) &#123; movechess(len - 1, 2 * len); //中间的 \"o*\" 与 \"--\" 交换 len--; if (len == 3) //不符合上述规律,开始输出打表内容 break; movechess(len, 2 * len); //最左边的 \"**\" 与 \"--\" 交换 &#125; string ss; for (int i = 0; i &lt; n - 4; i++) ss += \"o*\"; for (int i = 0; i &lt; 4; i++) cout &lt;&lt; out[i] &lt;&lt; ss &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"找规律","slug":"找规律","permalink":"https://gaisaiyuno.github.io/tags/找规律/"}]},{"title":"P2757 [国家集训队]等差子序列 暴力","slug":"P2757 [国家集训队]等差子序列","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/c2feaa5a.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c2feaa5a.html","excerpt":"","text":"传送门显然只用考虑长度为$3$的等差序列，设$a_i,a_j,a_k$为连续的$3$项发现$2*a_j=a_i+d+a_k-d=a_i+a_k$考虑枚举$i,j$，判断存不存在$k$开一个桶记录$a[i]$然后你发现$O(n^2)$的暴力$A$了12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int num[MAXN],cnt[MAXN];int main()&#123; int t=read(); while (t--)&#123; int n=read(); memset(cnt,0,sizeof(cnt)); memset(num,0,sizeof(num)); for (register int i=1;i&lt;=n;++i)&#123; num[i]=read(); cnt[num[i]]=i; &#125; bool flag=false; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=i+1;j&lt;=n;++j)&#123; if (cnt[num[j]-num[i]+num[j]]&gt;j)&#123; flag=true; break; &#125; &#125; if (flag) break; &#125; puts(flag?\"Y\":\"N\"); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"}]},{"title":"FFT入门","slug":"fft","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/76ede821.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/76ede821.html","excerpt":"","text":"FFT入门 FFT(快速傅里叶变换)是上个学期学会的东西，由于接下来要玩母函数，所以现在写篇博客复习一下。FFT可以在$O(n\\log n)$的时间内完成多项式乘法。 问题给定两个十进制数（$10^5$位），求它们的乘积。 不妨把它归为一个多项式乘积的问题：每一位都是一个系数，那么1234*2333就变成了： $\\displaystyle (x^3+2x^2+3x+4)*(2x^3+3x^2+3x+3)$ 对于多项式乘积问题，显然跑$O(n^2)$的朴素高精度乘法是过不了的。考虑我们计算$a \\times b$的方式：令$X$为答案，则有：$\\displaystyle X_n = \\sum_{i=0}^n a_i\\times b_{n-i}$ 因此，我们做的事情是直接计算答案的每一位。现在我们换一种思路。 点值表达之前我们使用的$(x^{5}+233x^3+x)$这种表达方式，被称为系数表达。因为它给出了系数向量：$(1,0,233,0,1,0)$。 但是考虑这样一个事实：给定$n$个点，可以唯一确定一个$n-1$次多项式函数。至于如何确定，有高斯消元和拉格朗日插值法。 因此我们拥有了一种全新的表达多项式的方式：点值表达。给出$n+1$个点，可以表达一个多项式。例如：$(0,0),(1,1),(2,4)$是多项式$(x^2)$的一种点值表达。一个多项式有无数组点值表达。 有什么用呢？考虑多项式的加法$A+B$，生成的多项式的点值表达，可以由$A$和$B$的点值表达得到。在$A$和$B$上取相同的一些$x$，求出对应的点值表达：$A:(x_1,y_{a1}),(x_2,y_{a2})\\cdots$$B:(x_1,y_{b1}),(x_2,y_{b2})\\cdots$ 则$A+B :(x_1,y_{a1}+y_{b1}),(x_2,y_{a2}+y_{b2})\\cdots$ 看图很好理解： 我们把从点值表达变成系数表达的过程称作插值。 那么多项式的乘法也类似。大概是这样的步骤： 单位复数根对着数学书脑补一番就解决了。 单位复数根：$ω_n^k$均匀分布在以$(0,0)$为中心的复平面圆上。$n=8$时长成这样： $ω_n^k=e^{2πi\\frac{k}{n}}$（注意其中的$i$是虚数单位）。欧拉告诉我们，$e^{iu}=\\cos(u)+i\\sin(u)$，故有：$ω_n^k=\\cos(2πk/n)+i\\sin(2πk/n)$. 看图应该能脑补出来：尽管$ω_n^k$有$n$种取值，$(ω_n^k)^2$只有$\\frac{n}{2}$种取值。 在图中的意义是：第一象限点的平方与第三象限点的平方一致；第二象限点的平方与第四象限点的平方一致。因为$(a+b)^2=(-a-b)^2$。 由于这货的性质，我们选择单位复数根作为$x$坐标进行求值。 FFT关键步骤：将$\\displaystyle A=\\sum_{i=0}^n a_i x^i$拆分为：$A_0={a_0,a_2x,a_4x^2,\\cdots,a_{n-2}x^{\\frac{n}{2}-1}}$$A_1={a_1,a_3x,a_5x^2,…,a_{n-1}x^{\\frac{n}{2}-1}}$则有：$A(x)=A_0(x^2)+xA_1(x^2)$ 由于我们使用单位复数根进行求值，则$x^2$只有$n/2$种取值。我们把问题规模成功降低了一半！ 那么如何插值回来呢？令$ω_n^k=\\cos(2πk/n)-i\\sin(2πk/n)$即可。（这里变成减号） 上面那段话并不清楚，因为我太弱了，根本讲不清楚。要完全理解上面的话，推荐看完代码，然后啃一啃《导论》。 所以我们就写出了代码：uoj #34.多项式乘法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;iostream&gt;using namespace std;typedef complex&lt;double&gt; cp; //complex库void fft(cp *a,int n,int flag) //作用：求出a的点值表达，存进a&#123; int i; cp a0[n/2+1],a1[n/2+1]; if(n==1) return; cp w_n(cos(2*M_PI/n),sin(flag*2*M_PI/n)); //flag=1:求值 flag=2:插值 cp w(1,0); for(i=0;i&lt;n/2;i++) a0[i]=a[i*2],a1[i]=a[i*2+1]; //分治 fft(a0,n/2,flag); fft(a1,n/2,flag); for(i=0;i&lt;n/2;i++) &#123; a[i]=a0[i]+w*a1[i]; a[i+n/2]=a0[i]-w*a1[i]; w=w*w_n; //递推单位复数根 &#125;&#125;cp x[300005]=&#123;0&#125;,y[300005]=&#123;0&#125;;int n,m;void init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=0;i&lt;=n;i++) cin&gt;&gt;x[i].real(); for(i=0;i&lt;=m;i++) cin&gt;&gt;y[i].real(); m+=n; for(n=1;n&lt;=m;n=n*2);&#125;int main(void)&#123; int i; init(); fft(x,n,1); //求值 fft(y,n,1); //求值 for(i=0;i&lt;n;i++) x[i]=x[i]*y[i]; //点值乘法 fft(x,n,-1); //插值 for(i=0;i&lt;=m;i++) printf(\"%d \",int((x[i].real())/n+0.5)); //四舍五入输出 return 0;&#125; 跑了4460ms。提交记录递归版的比较慢（废话），迭代版的跑得比香港记者还快。 然而我并不会蝴蝶操作那套理论，请看riteme的博客：有关多项式的算法 相关资料 riteme 快速数论变换(NTT)简要介绍了快速数论变换。xlightgod UOJ34 多项式乘法适合入门FFT。我就是在那里学习了一个。iamzky 快速傅里叶变换讲解很详细。","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"P2286 [HNOI2004]宠物收养场 平衡树","slug":"P2286 [HNOI2004]宠物收养场","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/84e83592.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/84e83592.html","excerpt":"","text":"传送门平衡树模板题也是模拟题宠物和人会相互抵消，所以不存在一次操作后集合中既存在人也存在宠物分情况讨论当前是人集合还是宠物集合如果加进来的是同类，直接$Insert$如果是不同类，查询前驱后继，按题目意思模拟即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MOD 1000000using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz; &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; return tot; &#125; int Merge(int x,int y)&#123; // printf(\"%d %d\\n\",x,y); if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k)&#123;x=i,Split(rc(i),k,rc(i),y);&#125; else&#123;y=i,Split(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; int kth(int i,int k)&#123;//排名为k while (true)&#123; if (k&lt;=tree[lc(i)].sz)&#123; i=lc(i); &#125; else if (k==tree[lc(i)].sz+1)&#123; return i; &#125; else&#123; k-=tree[lc(i)].sz+1; i=rc(i); &#125; &#125; &#125; //以上为FHQ Treap int root,x,y,z; void Init()&#123; tot=0; memset(tree,0,sizeof(tree)); root=0; srand(19260817); &#125; inline void Add(int num)&#123; Split(root,num,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int num)&#123; Split(root,num,x,z); Split(x,num-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125; inline int Rank(int num)&#123;//获得num排名 Split(root,num-1,x,y); int temp=tree[x].sz+1; root=Merge(x,y); return temp; &#125; #define Get_K(rt,rk) tree[kth(rt,rk)].val inline int Kth(int k)&#123;//获得数组中第k大 return Get_K(root,k); &#125; inline int Pre(int num)&#123; Split(root,num-1,x,y); int temp=Get_K(x,tree[x].sz); root=Merge(x,y); return temp; &#125; inline int Nex(int num)&#123; Split(root,num,x,y); int temp=Get_K(y,1); root=Merge(x,y); return temp; &#125;&#125;;using namespace FHQ_Treap;#define INF 0x3f3f3f3finline int Abs(int x)&#123; return x&gt;0?x:-x;&#125;int main()&#123; Init(); int n=read(); Add(INF),Add(-INF); int pets=0;//宠物数量 int man=0;//领养者数量 int ans=0; for (register int i=1;i&lt;=n;++i)&#123; int opr=read(),p=read(); if (pets==man)&#123;//空树 Add(p); &#125; else&#123; if ((opr==0&amp;&amp;pets&gt;man)||(opr==1&amp;&amp;pets&lt;man))&#123; Add(p); &#125; else &#123; int pre=Pre(p),nex=Nex(p); int d1=p-pre,d2=nex-p; if (d1&lt;=d2) ans+=d1,Del(pre); else ans+=d2,Del(nex); &#125; &#125; if (opr==0) pets++; else man++; ans%=MOD; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"P5099 [USACO2004OPEN]Cave Cows 4 洞穴里的牛之四 SPFA","slug":"P5099 [USACO2004OPEN]Cave Cows 4 洞穴里的牛之四","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/dcd3e3e5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/dcd3e3e5.html","excerpt":"","text":"传送门考虑建图，把$x$方向$z$方向距离都不超过$2$的点连一条边长为$1$的边，最后跑一遍SPFA。具体实现可以把点放进一个$map$里面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 50000#define pii pair&lt;int,int&gt;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x;&#125;using namespace std;vector&lt;int&gt;G[MAXN];void AddEdge(int u,int v)&#123; //printf(\"Adding Edge from %d to %d\\n\",u,v); G[u].push_back(v); G[v].push_back(u);&#125;map&lt;pii ,int&gt;M;int X[MAXN],Z[MAXN];int vis[MAXN],dis[MAXN];int t,n;inline int SPFA()&#123; queue&lt;int&gt;Q; Q.push(n+1); vis[n+1]=true; for (register int i=1;i&lt;=n;++i)&#123; dis[i]=0x7fffffff; &#125; dis[n+1]=0; while (Q.size())&#123; int u=Q.front(); Q.pop(); for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i]; if (!vis[v])&#123; vis[v]=true; dis[v]=min(dis[v],dis[u]+1); Q.push(v); &#125; &#125; &#125; int ans=0x7fffffff; for (register int i=1;i&lt;=n+1;++i)&#123; if (Z[i]==t)&#123; ans=min(ans,dis[i]); &#125; &#125; if (ans==0x7fffffff)&#123; return -1; &#125; else &#123; return ans; &#125;&#125;int main()&#123; //freopen(\"testdata.in\",\"r\",stdin); n=read(),t=read(); for (register int i=1;i&lt;=n;++i)&#123; int x=read(),z=read(); M[make_pair(x,z)]=i; X[i]=x,Z[i]=z; &#125; X[n+1]=Z[n+1]=0; M[make_pair(0,0)]=n+1; for (register int i=1;i&lt;=n+1;++i)&#123; for (register int p=-2;p&lt;=2;++p)&#123; for (register int q=-2;q&lt;=2;++q)&#123; if (p!=0||q!=0)&#123; int ni=X[i]+p,nj=Z[i]+q; if (M.count(make_pair(ni,nj)))&#123; AddEdge(i,M[make_pair(ni,nj)]); &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\",SPFA());&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"SPFA","slug":"SPFA","permalink":"https://gaisaiyuno.github.io/tags/SPFA/"}]},{"title":"P4309 [TJOI2013]最长上升子序列 平衡树","slug":"P4309 [TJOI2013]最长上升子序列","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.364Z","comments":true,"path":"archives/91a69bd6.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/91a69bd6.html","excerpt":"","text":"传送门注意：$X_k$为位置，而$k$才是真正加进去的数。 加入的序列为$1,2,3,……$也就是说，每次加入的数都是当前最大的。那么我们很快就可以推出$dp$方程：$dp[i]=max(dp[i],dp[j]+1) j&lt;i$$dp[i]$初始值为$1$ 我们发现：插入一个数的时候，只要知道$max(dp[j]+1)$，也就是$max(dp[j])+1$，就可以完成维护。所以，我们建立一棵维护$dp$值的$FHQTreap$，每次加入数时，取左子树$dp$最大值$+1$插入平衡树.输出时输出根节点$dp$值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 1000005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace FHQTreap&#123; struct node&#123; int l,r; int val;//dp值 int pri;//优先级（随机生成） int id;//下标 int sz; &#125;tree[MAXN]; #define lc(i) tree[i].l #define rc(i) tree[i].r int tot; inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; tree[x].val=max(max(tree[lc(x)].val,tree[rc(x)].val),a[tree[x].id]); &#125; inline int New(int v,int id)&#123; a[id]=v; tree[++tot].val=v,tree[tot].pri=rand(),tree[tot].sz=1,tree[tot].id=id; return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else&#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i) &#123; x=y=0; &#125; else &#123; if (tree[lc(i)].sz&gt;=k) &#123;y=i,Split(lc(i),k,x,lc(i));&#125; else &#123;x=i,Split(rc(i),k-tree[lc(i)].sz-1,rc(i),y);&#125; Update(i); &#125; &#125; int root; #undef lc #undef rc&#125;using namespace FHQTreap;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; int pos=read(); int x=0,y=0; Split(root,pos,x,y); x=Merge(x,New(tree[x].val+1,i)); root=Merge(x,y); printf(\"%d\\n\",tree[root].val); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"P2234 [HNOI2002]营业额统计 平衡树","slug":"P2234 [HNOI2002]营业额统计","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/2f829ded.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2f829ded.html","excerpt":"","text":"传送门平衡树模板题模拟整个过程，每次找$num$的前驱后继，注意特判$num$在集合中的情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MOD 1000000using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz; &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; return tot; &#125; int Merge(int x,int y)&#123; // printf(\"%d %d\\n\",x,y); if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k)&#123;x=i,Split(rc(i),k,rc(i),y);&#125; else&#123;y=i,Split(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; int kth(int i,int k)&#123;//排名为k while (true)&#123; if (k&lt;=tree[lc(i)].sz)&#123; i=lc(i); &#125; else if (k==tree[lc(i)].sz+1)&#123; return i; &#125; else&#123; k-=tree[lc(i)].sz+1; i=rc(i); &#125; &#125; &#125; //以上为FHQ Treap int root,x,y,z; void Init()&#123; tot=0; memset(tree,0,sizeof(tree)); root=0; srand(19260817); &#125; inline void Add(int num)&#123; Split(root,num,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int num)&#123; Split(root,num,x,z); Split(x,num-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125; inline int Rank(int num)&#123;//获得num排名 Split(root,num-1,x,y); int temp=tree[x].sz+1; root=Merge(x,y); return temp; &#125; #define Get_K(rt,rk) tree[kth(rt,rk)].val inline int Kth(int k)&#123;//获得数组中第k大 return Get_K(root,k); &#125; inline int Pre(int num)&#123; Split(root,num-1,x,y); int temp=Get_K(x,tree[x].sz); root=Merge(x,y); return temp; &#125; inline int Nex(int num)&#123; Split(root,num,x,y); int temp=Get_K(y,1); root=Merge(x,y); return temp; &#125;&#125;;using namespace FHQ_Treap;#define INF 0x3f3f3f3fint main()&#123; Init(); Add(INF),Add(-INF); int ans=0; int n=read(); int x=read();Add(x); ans+=x; for (register int i=2;i&lt;=n;++i)&#123; x=read(); if (Kth(Rank(x))!=x)&#123; int pre=Pre(x),nex=Nex(x); ans+=min(x-pre,nex-x); &#125; Add(x); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"},{"name":"FHQ Treap","slug":"FHQ-Treap","permalink":"https://gaisaiyuno.github.io/tags/FHQ-Treap/"}]},{"title":"P2534 [AHOI2012]铁盘整理 A star","slug":"P2534 [AHOI2012]铁盘整理","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/e90ef5da.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/e90ef5da.html","excerpt":"","text":"传送门数据范围较小，考虑$dfs$ 先离散化一波，转化为数的大小关系最终状态：对于任意的$1 \\le i \\le n$，$abs(a[i+1]-a[i])==1$ （定义$a[n+1]=n+1$)考虑一次翻转，翻转$j$大小的区间，每个块里面$abs(a[i+1]-a[i])$不会变，只有$abs(a[j+1]-a[j])$会变。所以每次操作只能改变一个$abs(a[i+1]-a[i])$考虑最终状态和现在状态$abs(a[i+1]-a[i])$的不同之处，估价函数就出来了1234567inline int h()&#123; int cnt=0; for (register int i=1;i&lt;=n;++i)&#123; cnt+=(int)(Abs(a[i]-a[i+1])!=1); &#125; return cnt;&#125; 然后迭代加深搜索一遍，就能$A$了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 55using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],b[MAXN];inline void discrete(int n)&#123; for (register int i=1;i&lt;=n;++i)&#123; b[i]=a[i]; &#125; sort(b+1,b+1+n); for (register int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(b+1,b+1+n,a[i])-b; &#125;&#125;inline void Swap(int l,int r)&#123; for (register int i=l,j=r;i&lt;=j;i++,j--)&#123; swap(a[i],a[j]); &#125;&#125;inline int Abs(int i)&#123; return i&gt;0?i:-i;&#125;int ans,n,maxdep;inline int h()&#123; int cnt=0; for (register int i=1;i&lt;=n;++i)&#123; cnt+=(int)(Abs(a[i]-a[i+1])!=1); &#125; return cnt;&#125;bool flag;void dfs(int nowdep,int last)&#123; if (flag)&#123; return ; &#125; int ans=h(); if (nowdep+ans&gt;maxdep) &#123; return ; &#125; if (ans==0)&#123; flag=true; return ; &#125; for (register int i=1;i&lt;=n;++i)&#123; if (i!=last)&#123; Swap(1,i); dfs(nowdep+1,i); Swap(1,i); &#125; &#125;&#125;int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; discrete(n); a[n+1]=n+1; for (register int dep=0;;++dep)&#123; flag=false; maxdep=dep; dfs(0,0); if (flag)&#123; printf(\"%d\\n\",dep); return 0; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"搜索","slug":"搜索","permalink":"https://gaisaiyuno.github.io/tags/搜索/"},{"name":"A star","slug":"A-star","permalink":"https://gaisaiyuno.github.io/tags/A-star/"}]},{"title":"P3919 【模板】可持久化数组（可持久化线段树/平衡树）","slug":"可持久化数组","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/933deda9.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/933deda9.html","excerpt":"","text":"传送门 用可持久化线段树实现，$rt[i]$表示每个副本线段树的根节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MAXM 30using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val;//每个节点的权值（只有叶节点有） &#125;tree[MAXN*MAXM]; int tot; void Build(int &amp;i,int L,int R)&#123; i=++tot; if (L==R)&#123; tree[i].val=a[L]; return ; &#125; int mid=(L+R)&gt;&gt;1; Build(tree[i].l,L,mid); Build(tree[i].r,mid+1,R); &#125; void Update(int &amp;i,int his,int pos,int val,int L,int R)&#123; i=++tot; tree[i].l=tree[his].l,tree[i].r=tree[his].r,tree[i].val=tree[his].val; if (L==R)&#123; tree[i].val=val; return ; &#125; int mid=(L+R)&gt;&gt;1; if (pos&lt;=mid) Update(tree[i].l,tree[his].l,pos,val,L,mid); else Update(tree[i].r,tree[his].r,pos,val,mid+1,R); &#125; int Query(int i,int pos,int L,int R)&#123; if (L==R) return tree[i].val; int mid=(L+R)&gt;&gt;1; if (pos&lt;=mid) return Query(tree[i].l,pos,L,mid); else return Query(tree[i].r,pos,mid+1,R); &#125;&#125;using namespace SegmentTree;int rt[MAXN];int main()&#123; int n=read(),q=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); Build(rt[0],1,n); for (register int i=1;i&lt;=q;++i)&#123; int v=read(),opr=read(),loc=read(); if (opr==1)&#123; int val=read(); Update(rt[i],rt[v],loc,val,1,n); &#125; else if (opr==2)&#123; printf(\"%d\\n\",Query(rt[v],loc,1,n)); rt[i]=rt[v]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"},{"name":"模板","slug":"模板","permalink":"https://gaisaiyuno.github.io/tags/模板/"}]},{"title":"HDU3625 Examining the Rooms","slug":"HDU3625","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/35437bed.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/35437bed.html","excerpt":"","text":"考虑把门$i$和门$i$中的钥匙指向的门$j$连一条有向边。打开一扇门，那么这个门处在的环内的所有门都可以被打开，所以图中不可能超过$k$个环。总共的排列数为$n!$，题目所求的是$n!$个排列中组成$\\le k$个环的数量，即第一类斯特林数。考虑到$1$号门不能炸，用总数$S_u(n,i)$减去$1$号点单独成环的方案$S_u(n-1,i-1)$ 答案就是： \\frac{\\sum^k_{i=1}(S_u(n,i)-S_u(n-1,i-1))}{n!}代码：123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define MAXN 105using namespace std;double Su[MAXN][MAXN];inline void Init()&#123; Su[1][0]=0,Su[1][1]=1; for (register int i=2;i&lt;MAXN;++i)&#123; for (register int j=1;j&lt;=i;++j)&#123; Su[i][j]=Su[i-1][j-1]+(double)(i-1)*Su[i-1][j]; &#125; &#125;&#125;int main()&#123; Init(); int t; cin&gt;&gt;t; while (t--)&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; double ans=0; for (register int i=1;i&lt;=k;++i)&#123; ans+=(double)(Su[n][i]-Su[n-1][i-1]); &#125; double fac=1; for (register int i=1;i&lt;=n;++i)&#123; fac=fac*i; &#125; printf(\"%.4lf\\n\",ans/fac); &#125;&#125; 还是挺短的。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"第一类斯特林数","slug":"第一类斯特林数","permalink":"https://gaisaiyuno.github.io/tags/第一类斯特林数/"}]},{"title":"SP2916 GSS5 - Can you answer these queries V 线段树","slug":"GSS5","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/733d8170.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/733d8170.html","excerpt":"","text":"传送门 题面给定一个序列。查询左端点在$[x_1, y_1]$之间，且右端点在$[x_2, y_2]$之间的最大子段和，数据保证$x_1\\leq x_2,y_1\\leq y_2$ ，但是不保证端点所在的区间不重合 题解线段树好题，建议先做SP1043 GSS1 - Can you answer these queries I 首先分析两线段相离的情况，发现$[y1+1,x2-1]$是必选区间 然后分析两线段相交的情况： 有三种情况 端点在$[x2,y1]$，只用求$[x2,y1]$区间子段最大值 左端点在$[x1,x2-1]$，右端点在$[x2,y2]$，按照线段相离的方法来求 左端点在$[x1,y1]$，右端点在$[x1+1,y2]$，同理 $p.s.$可能$cmath$不支持$y1$，我把$x1,y1,x2,y2$换成了$l1,r1,l2,r2$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int lmax,rmax,maxn;//从左端开始最大值，从右端开始最大值，整段最大值 int val;//这段的和 &#125;tree[MAXN&lt;&lt;2]; node empty_node()&#123; node temp; temp.l=temp.r=temp.lmax=temp.rmax=temp.maxn=temp.val=0; return temp; &#125; void Init()&#123; memset(tree,0,sizeof(tree)); &#125; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 node operator + (node A,node B)&#123; node temp; temp.lmax=max(B.lmax+A.val,A.lmax); temp.rmax=max(A.rmax+B.val,B.rmax); temp.maxn=max(max(A.maxn,B.maxn),A.rmax+B.lmax); temp.val=A.val+B.val; temp.l=A.l,temp.r=B.r; return temp; &#125; void pushup(int i)&#123; tree[i]=tree[lc]+tree[rc]; &#125; void Build(int l,int r,int i)&#123; if (l==r)&#123; tree[i].lmax=tree[i].rmax=tree[i].maxn=tree[i].val=a[l]; tree[i].l=tree[i].r=l; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); pushup(i); &#125; node TEMPQuery(int L,int R,int i)&#123; if (L&gt;R) return empty_node();//特判L&gt;R情况 if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i]; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&gt;mid) return TEMPQuery(L,R,rc); else if (R&lt;=mid) return TEMPQuery(L,R,lc); else return TEMPQuery(L,R,lc)+TEMPQuery(L,R,rc); &#125; node Query(int L,int R)&#123; return TEMPQuery(L,R,1); &#125;&#125;;using namespace SegmentTree;inline int Get_Ans(int l1,int r1,int l2,int r2)&#123;//r1&lt;=l2即区间[l1,r1],[l2,r2]相离或相切 if (r1==l2) return Query(l1,r1).rmax+Query(l2,r2).lmax-a[r1];//相切特殊情况 return Query(l1,r1).rmax+Query(r1+1,l2-1).val+Query(l2,r2).lmax;&#125;inline int Solve(int l1,int r1,int l2,int r2)&#123; if (l1==l2&amp;&amp;r1==r2)&#123; return Query(l1,r1).maxn; &#125; if (r1&lt;l2)&#123; return Get_Ans(l1,r1,l2,r2); &#125; else &#123; int ans=Query(l2,r1).maxn; ans=max(ans,Get_Ans(l1,l2,l2,r2)); ans=max(ans,Get_Ans(l1,r1,r1,r2)); return ans; &#125;&#125;int main()&#123; int Case=read(); for (register int k=1;k&lt;=Case;++k)&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Init(); Build(1,n,1); int q=read(); while (q--)&#123; int l1=read(),r1=read(),l2=read(),r2=read(); printf(\"%d\\n\",Solve(l1,r1,l2,r2)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"FHQ Treap模板","slug":"FHQ Treap","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/1ada9bb5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/1ada9bb5.html","excerpt":"","text":"大概是对着网上的模板敲了一遍吧。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;#define MAXN 500005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace FHQ_Treap&#123; struct node&#123; int l,r; int val;//每个点的权值 int pri;//优先级（随机生成） int sz; &#125;tree[MAXN]; int tot; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void Update(int x)&#123; tree[x].sz=tree[lc(x)].sz+tree[rc(x)].sz+1; &#125; inline int New(int v)&#123; tree[++tot].val=v; tree[tot].pri=rand(); tree[tot].sz=1; return tot; &#125; int Merge(int x,int y)&#123; if (!x||!y) return x+y; if (tree[x].pri&lt;tree[y].pri)&#123; rc(x)=Merge(rc(x),y),Update(x); return x; &#125; else &#123; lc(y)=Merge(x,lc(y)),Update(y); return y; &#125; &#125; void Split(int i,int k,int &amp;x,int &amp;y)&#123; if (!i)&#123;//叶节点 x=y=0; &#125; else &#123; if (tree[i].val&lt;=k)&#123;x=i,Split(rc(i),k,rc(i),y);&#125; else&#123;y=i,Split(lc(i),k,x,lc(i));&#125; Update(i); &#125; &#125; int kth(int i,int k)&#123;//排名为k while (true)&#123; if (k&lt;=tree[lc(i)].sz)&#123; i=lc(i); &#125; else if (k==tree[lc(i)].sz+1)&#123; return i; &#125; else&#123; k-=tree[lc(i)].sz+1; i=rc(i); &#125; &#125; &#125; //以上为FHQ Treap int root,x,y,z; void Init()&#123; tot=0; root=0; srand(time(NULL)); &#125; inline void Add(int num)&#123; Split(root,num,x,y); root=Merge(Merge(x,New(num)),y); &#125; inline void Del(int num)&#123; Split(root,num,x,z); Split(x,num-1,x,y); y=Merge(lc(y),rc(y)); root=Merge(Merge(x,y),z); &#125; inline int Rank(int num)&#123;//获得num排名 Split(root,num-1,x,y); int temp=tree[x].sz+1; root=Merge(x,y); return temp; &#125; #define Get_K(rt,rk) tree[kth(rt,rk)].val inline int Kth(int k)&#123;//获得数组中第k大 return Get_K(root,k); &#125; inline int Pre(int num)&#123; Split(root,num-1,x,y); int temp=Get_K(x,tree[x].sz); root=Merge(x,y); return temp; &#125; inline int Nex(int num)&#123; Split(root,num,x,y); int temp=Get_K(y,1); root=Merge(x,y); return temp; &#125;&#125;;using namespace FHQ_Treap;#define INF 0x3f3f3f3fint main()&#123; Init(); int n=read(); Add(INF),Add(-INF); &#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://gaisaiyuno.github.io/tags/模板/"},{"name":"平衡树","slug":"平衡树","permalink":"https://gaisaiyuno.github.io/tags/平衡树/"}]},{"title":"P4212 外太空旅行 随机","slug":"P4212 外太空旅行","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/7c083d74.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/7c083d74.html","excerpt":"","text":"传送门题意：求最大团，团是一个点的集合，其中任意两点都有边相连。最大团属于$NPC$问题None Player Characters虽然数据范围小，$n \\le 50$，但是直接暴搜肯定超时。考虑随机化，每次打乱点的总集合$S$从$S$中取出点$v$，若$v$与$Ans$中的所有点都有边相连，则将$v$加入$Ans$，否则跳过$v$ 实践证明随机化个$1000$次就能$AC$ 正确性显（bu）然（hui）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN 55using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int G[MAXN][MAXN];void AddEdge(int u,int v)&#123; G[u][v]=true; G[v][u]=true;&#125;int a[MAXN];int stk[MAXN],top;int main()&#123; int n=read(),u,v; int maxn=0; while (scanf(\"%d%d\",&amp;u,&amp;v)!=EOF&amp;&amp;u!=0&amp;&amp;v!=0)&#123; AddEdge(u,v); maxn=max(maxn,u),maxn=max(maxn,v); &#125; for (register int i=1;i&lt;=n;++i)&#123; a[i]=i; &#125; int ans=-0x7fffffff; srand(time(NULL)); for (register int k=0;k&lt;10000;++k)&#123; random_shuffle(a+1,a+1+n); top=0; stk[++top]=a[1]; for (register int i=2;i&lt;=n;++i)&#123;//找出v bool flag=true; for (register int j=1;j&lt;=top;++j)&#123;//判断是否有边相连 if (!G[stk[j]][a[i]])&#123; flag=false; break; &#125; &#125; if (flag==true)&#123; stk[++top]=a[i];//加入集合Ans &#125; &#125; ans=max(ans,top); &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"},{"name":"随机","slug":"随机","permalink":"https://gaisaiyuno.github.io/tags/随机/"}]},{"title":"CF981F  Round Marriage 随机","slug":"CF981F  Round Marriage","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/d7b367ce.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d7b367ce.html","excerpt":"","text":"传送门这道题其实可以用暴力水过$qwq$首先可以知道一个暴力做法如下，具体地来说可以用调整法证明其正确性，但是过不了所有的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 200005using namespace std;int A[MAXN], B[MAXN];int l;;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return x*f;&#125;inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;inline int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;inline int calc(int a, int b)&#123; int dis = a &gt; b ? a - b : b - a; return min(dis, l - dis);&#125;int num1[MAXN],num2[MAXN];int main()&#123; int n; n=read(),l=read(); for (register int i = 0; i &lt; n; ++i)&#123; A[i]=read(); &#125; for (register int i = 0; i &lt; n; ++i)&#123; B[i]=read(); &#125; sort(A, A + n); sort(B, B + n); int minmax = 0x7fffffff; for (register int i = 0; i &lt;n; ++i)&#123; int maxn = -0x7fffffff; for (register int j = 0; j &lt;n; ++j)&#123; maxn = max(maxn, calc(A[j], B[(i + j &gt;= n) ? (i + j - n) : (i + j)])); &#125; minmax = min(minmax, maxn); &#125; printf(\"%d\\n\", minmax); return 0;&#125; 然后，我们有一个比较显然的优化：如果当前最大值已经比最小的最大值要大的话，就$break$掉。 12345678910for (register int i = 0; i &lt;n; ++i)&#123; int maxn = -0x7fffffff; for (register int j = 0; j &lt;n; ++j)&#123; maxn = max(maxn, calc(A[j], B[(i + j &gt;= n) ? (i + j - n) : (i + j)])); if (maxn &gt;= minmax)&#123; break; &#125; &#125; minmax = min(minmax, maxn);&#125; 但是，显然这个程序在随机数据下表现良好，但是会被一些特殊数据卡掉。。。比如说这个程序就$T$在了第24个点 什么？你要写二分？too young too naive！如果数据不是随机的，我们就“构造”出随机的数据，比如说，用random_shuffle优化枚举顺序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#pragma GCC optimize (2)#pragma G++ optimize (2)#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MAXN 200005using namespace std;int A[MAXN], B[MAXN];int l;;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return x*f;&#125;inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;inline int min(int a, int b)&#123; return a &lt; b ? a : b;&#125;inline int calc(int a, int b)&#123; int dis = a &gt; b ? a - b : b - a; return min(dis, l - dis);&#125;int num1[MAXN],num2[MAXN];int main()&#123; int n; n=read(),l=read(); for (register int i = 0; i &lt; n; ++i)&#123; //scanf(\"%d\", &amp;A[i]); A[i]=read(),num1[i]=i; &#125; for (register int i = 0; i &lt; n; ++i)&#123; //scanf(\"%d\", &amp;B[i]); B[i]=read(),num2[i]=i; &#125; random_shuffle(num1,num1+n); random_shuffle(num2,num2+n); sort(A, A + n); sort(B, B + n); int minmax = 0x7fffffff; for (register int ii = 0; ii &lt;n; ++ii)&#123; int maxn = -0x7fffffff; for (register int jj = 0; jj &lt;n; ++jj)&#123; int i=num1[ii],j=num2[jj]; maxn = max(maxn, calc(A[j], B[(i + j &gt;= n) ? (i + j - n) : (i + j)])); if (maxn &gt;= minmax)&#123; break; &#125; &#125; minmax = min(minmax, maxn); &#125; printf(\"%d\\n\", minmax); return 0;&#125; 然后就$A$了 $hhh…$","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"},{"name":"随机","slug":"随机","permalink":"https://gaisaiyuno.github.io/tags/随机/"}]},{"title":"P4047 [JSOI2010]部落划分 最小生成树","slug":"P4047 [JSOI2010]部落划分","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/7b6c0694.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/7b6c0694.html","excerpt":"","text":"传送门 这题其实有两种做法： $1.$我一开始想到的是二分加并查集，考虑二分最近部落的距离，如果两点$i$，$j$距离小于等于$mid$那么连边，并查集维护，最后统计有多少集合。考虑如何证明单调性：如果两点$i$，$j$在$mid1$情况下能连边，那么在$mid2$情况下也能连边（$mid2&gt;mid1$），那么$mid1$情况下的集合数不可能小于$mid2$情况下的集合数这样我们可以愉快地二分答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MAXN 10005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; fa[i]=i; &#125; &#125; int Fa(int i)&#123; return fa[i]==i?i:fa[i]=Fa(fa[i]); &#125; inline void Union(int i,int j)&#123; fa[Fa(i)]=Fa(j); &#125;&#125;;using namespace BCJ;int x[MAXN],y[MAXN];inline double Dist(int i,int j)&#123; return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));&#125;int n,k;inline bool Check(double mid)&#123; Init(); for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=n;++j)&#123; if (Dist(i,j)&lt;=mid)&#123; Union(i,j); &#125; &#125; &#125; int ans=0; for (register int i=1;i&lt;=n;++i)&#123; if (fa[i]==i) ans++; &#125; return ans&gt;=k;&#125;int main()&#123; Init(); n=read(),k=read(); for (register int i=1;i&lt;=n;++i)&#123; x[i]=read(),y[i]=read(); &#125; double l=0,r=0x7fffffff; const double eps=1e-4; while (l+eps&lt;r)&#123; double mid=(l+r)/2.0; if (Check(mid)) l=mid; else r=mid; &#125; printf(\"%.2lf\\n\",l);&#125; $2.$考虑连边过程中集合数的变化，发现多连一条边，集合数就会减一。要让最后有$k$个集合，$yy$一下，发现要连$n-k+1$条边，于是我们可以用一个类似于$Kruskal$的贪心，只不过加到$n-k+1$条边就退出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; fa[i]=i; &#125; &#125; int Fa(int i)&#123; return fa[i]==i?i:fa[i]=Fa(fa[i]); &#125; inline void Union(int i,int j)&#123; fa[Fa(i)]=Fa(j); &#125;&#125;;using namespace BCJ;struct Edge&#123; int u,v; double w;&#125;G[MAXN*2];inline bool operator &lt; (const Edge &amp;A,const Edge &amp;B)&#123; return A.w&lt;B.w;&#125;int tot;inline void AddEdge(int u,int v,double w)&#123; G[++tot].u=u,G[tot].v=v,G[tot].w=w;&#125;double x[MAXN],y[MAXN];#define Pow(a) a*ainline double dis(int i,int j)&#123; return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));&#125;inline double Kruscal(int MaxE)&#123; Init(); sort(G+1,G+1+tot); int E=0; for (register int i=1;i&lt;=tot;++i)&#123; if (Fa(G[i].u)!=Fa(G[i].v))&#123; Union(G[i].u,G[i].v); E++; if (E==MaxE)&#123; return G[i].w; &#125; &#125; &#125;&#125;int main()&#123; int n=read(),k=read(); for (register int i=1;i&lt;=n;++i)&#123; x[i]=(double)read(); y[i]=(double)read(); &#125; for (register int i=1;i&lt;n;++i)&#123; for (register int j=i+1;j&lt;=n;++j)&#123; AddEdge(i,j,dis(i,j)); &#125; &#125; printf(\"%.2lf\\n\",Kruscal(n-k+1));&#125; p.s被$double$孙了甚久。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"并查集","slug":"并查集","permalink":"https://gaisaiyuno.github.io/tags/并查集/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://gaisaiyuno.github.io/tags/最小生成树/"},{"name":"二分","slug":"二分","permalink":"https://gaisaiyuno.github.io/tags/二分/"}]},{"title":"POJ - 1737 Connected Graph(计数DP)","slug":"POJ1737","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/aeb2bd6e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/aeb2bd6e.html","excerpt":"","text":"设$i$个点的连通块个数为$F(i)$，所有$i$个点的图的个数为$G(i)$从反面考虑问题，发现$i$个点连通图个数=所有$i$个点的图的个数-$i$个点非连通图的个数。考虑所有$i$个点的图的个数，每条边可选可不选，共$i \\times (i-1)/2$条边，则$G(i)=2^{i \\times (i-1)/2}$考虑$i$个点非连通图的个数，设节点$1$所在的连通块大小为$j$，那么我们选出这个连通块的方法数为$F(j) \\times C^{j-1}_{i-1}$，也就是从剩下$i-1$个节点中选出$j-1$个，与节点$1$组成连通块。剩下$i-j$个点随便乱连，有$G(i-j)$种搞法。 那么我们可以推出$dp$方程式： F(i)=G(i)-\\sum F(j) \\times C^{j-1}_{i-1} \\times G(i-j) (1 \\le j \\le i-1)代码（高精自己打） 1234567891011121314151617181920212223242526272829303132333435363738bign C[51][51];inline void Init()&#123; for (register int i=1;i&lt;=50;++i)&#123; C[i][0]=1,C[i][i]=1; for (register int j=1;j&lt;i;++j)&#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; &#125;&#125;inline bign pow2(int k)&#123; bign ans=1,p=2; while (k)&#123; if (k&amp;1) ans=ans*p; p=p*p; k&gt;&gt;=1; &#125; return ans;&#125;bign dp[51];inline bign f(int x)&#123;//x个点随便怎么连 return pow2(x*(x-1)/2);&#125;int main() &#123; Init(); dp[1]=1; for (register int i=2;i&lt;=50;++i)&#123; dp[i]=f(i); for (register int j=1;j&lt;=i-1;++j)&#123; dp[i]=dp[i]-dp[j]*C[i-1][j-1]*f(i-j); &#125; &#125; while (true)&#123; int x; scanf(\"%d\",&amp;x); if (x==0) break; cout&lt;&lt;dp[x]&lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"牛顿迭代","slug":"牛顿迭代","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/65f48148.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/65f48148.html","excerpt":"","text":"牛顿迭代法 牛顿迭代法用于求函数的零点。 问题考虑求一个函数的一个零点。如果函数是一次函数$f(x)=kx+b$，则显然有零点$(-\\frac{b}{k},0)$。 如果函数是二次函数呢？好像也不难，用求根公式即可。 现在问题来了：人类已经证明，五次以上的方程没有求根公式。如果拿到的方程极为奇怪，又该如何处理？ 牛顿迭代法提出了解决方案。 方法牛顿迭代法分三步进行： 瞎猜一个值$p$ 求出$x=p$时函数的切线，即求$f\\prime(p)$ 令$p$为切线的零点，返回步骤2。 以维基百科的图理解： 上图中蓝线是原函数，红线是切线。 上面的三个步骤可以简化为一个递推：$\\displaystyle x_{n+1}=x_{n}-\\frac {f(x_n)}{f’(x_n)}$ 用途正常向的用途，就是老老实实求零点。 但是还有一些东西可以用牛顿迭代做，例如求$\\sqrt[m]a$。显然很难求，所以令$x=\\sqrt[m]a$，令$f(x)= x^m =a $。 显然$f\\prime(x)=m*x^{m-1}$。然后就可以牛顿迭代出解了。 程序例：求$f(x)=x^2+2x+1$的一个零点。 求导得：$f\\prime(x)=2x+2$。故可以：$x=x-\\frac{f(x)}{f_2(x)}$迭代lambda次。这里lambda取100。 1234567891011121314#define f(x) (x*x+2*x+1) //原函数#define f2(x) (x*2+2) //导函数#define lambda (100) //迭代次数void Newton()&#123; double x=233; int i=0; for(i=0;i&lt;lambda;i++) x=x-f(x)/f2(x); //牛顿迭代法 printf(\"%.8lf\\n\",x);&#125; 正确性不会证 （能用就行？","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"牛顿迭代","slug":"牛顿迭代","permalink":"https://gaisaiyuno.github.io/tags/牛顿迭代/"}]},{"title":"灌水 USACO 2008 最小生成树","slug":"灌水「USACO 2008」","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/56ee40b1.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/56ee40b1.html","excerpt":"","text":"我们把自己建了水库的节点称为$A$类节点，通过其他农田饮水的称为$B$类节点。考虑最后生成的图，根据贪心，图中肯定没有环，所以这个图是一个森林，且森林中的每棵树都有且仅有一个$A$类节点，若大于$1$则造成浪费。考虑把森林变成树，我们建立超级源点$0$号节点，和图中每个节点$i$相连，边权就可以设为$w_i$，然后节点$i$，节点$j$连边权为$p_{ij}$的边即可。 最后跑一遍最小生成树，生成树中，与$0$号节点有边相连的节点是$A$类节点，其余为$B$类节点，把生成树中与$0$号节点相连的边去除，就变成了答案的森林图了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;namespace BCJ&#123; int fa[MAXN]; inline void Init()&#123; for (register int i=0;i&lt;MAXN;++i)&#123; fa[i]=i; &#125; &#125; int Fa(int i)&#123; return fa[i]==i?i:fa[i]=Fa(fa[i]); &#125; inline void Union(int i,int j)&#123; fa[Fa(i)]=Fa(j); &#125;&#125;;using namespace BCJ;struct Edge&#123; int u,v,w;&#125;;inline bool operator &lt; (const Edge &amp;A,const Edge &amp;B)&#123; return A.w&lt;B.w;&#125;Edge s[MAXN];int tot;inline void AddEdge(int u,int v,int w)&#123; s[++tot]=Edge&#123;u,v,w&#125;;&#125;inline int Kruscal()&#123; sort(s+1,s+1+tot); Init(); int ans=0; for (register int i=0;i&lt;=tot;++i)&#123; if (Fa(s[i].u)!=Fa(s[i].v))&#123; Union(s[i].u,s[i].v); ans+=s[i].w; &#125; &#125; return ans;&#125;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; int w=read(); AddEdge(0,i,w); &#125; for (register int i=1;i&lt;=n;++i)&#123; for (register int j=1;j&lt;=n;++j)&#123; int v=read(); AddEdge(i,j,v); &#125; &#125; printf(\"%d\\n\",Kruscal());&#125; 由于加的边形成一个完全图，边数为$n^2$级别，所以$Kruskal$时间复杂度为$O(|E|log|E|)=O(n^2log(n^2))$，在本题数据范围下能过。如果数据范围再大一些，就要使用$Prim$算法，时间复杂度为$O(nlogn)$，估计能过$n=1000$的点（再大内存会爆）。","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://gaisaiyuno.github.io/tags/最小生成树/"}]},{"title":"CF720D Slalom 动态规划dp 线段树","slug":"CF720D Slalom","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/3488b88e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/3488b88e.html","excerpt":"","text":"传送门 考虑$dp$，但是这个$dp$该怎么$d$呢？如果走路的时候能往右就往右，实在不行（有障碍物或往上走会产生新的方法）才向上（也就是尽可能向低处走），我们就可以做到路径不“重复”。于是$dp$就呼之欲出：$F[i][j]=F[i-1][j]$ 一般情况$F[i][j]=0$ 若这格是障碍$F[i][j]=\\sum^{j-1}_{k=low}F[i-1][k]$ 若$(i,j-1)$是某个障碍矩阵的左上角其中$low$为$i-1$列中$j$往下第一个障碍的上面一格维护一下$low$，并用前缀和优化一下转移即可得到$O(NM)$的算法 现在考虑如何优化：$dp$转移的过程可以看成是一列扫描线扫过去。于是我们建立一棵线段树，维护的是这一列$dp$的值。yy一下，发现这棵线段树需要区间查询，区间设$0$，单点修改，不难实现。继续思考：需要获得障碍的上下边界，还有快速查询$low$。我们需要开一个$set$，维护这一列扫描线和障碍物相交的部分。查询$low$就直接在$set$内lower_bound。扫描线移动的时候就加上新出现的线段，减去消失的线段，维护一下即可。 注意lower_bound(a.begin(),a.end(),x)和a.lower_bound(x)的区别。前者最坏情况指针位移a.size()那么多，直接被卡$TLE$本蒟蒻一直卡在那里123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define MOD 1000000007using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val; bool tag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(const int &amp;i)&#123; tree[i].val=(tree[lc].val+tree[rc].val)%MOD; &#125; inline void Change(const int &amp;i,const int &amp;rt)&#123; tree[i].val=0; tree[i].tag=true; &#125; inline void pushdown(const int &amp;i)&#123; if (tree[i].tag)&#123; Change(lc,i),Change(rc,i); tree[i].tag=false; &#125; &#125; void Build(int l,int r,int i)&#123; tree[i].l=l,tree[i].r=r; tree[i].tag=0,tree[i].val=0; if(l==r)&#123;return ;&#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); &#125; void Cover(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].tag=true; tree[i].val=0; return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Cover(lc,L,R); if (mid&lt;R) Cover(rc,L,R); pushup(i); &#125; void Update(int i,int index,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].val=val; return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) Update(lc,index,val); else Update(rc,index,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&gt;R) return 0; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=0; if (L&lt;=mid) ans=(ans+Query(lc,L,R))%MOD; if (mid&lt;R) ans=(ans+Query(rc,L,R))%MOD; return ans; &#125;&#125;using namespace SegmentTree;struct sgmt&#123; int x,y1,y2;//是一条竖线 y1下端点 y2上端点 bool flag;//是左边竖线还是右边竖线 //0左边 1右边&#125;;inline bool operator &lt; (const sgmt &amp;A,const sgmt &amp;B)&#123; if (A.x!=B.x)&#123;//先比较x return A.x&lt;B.x; &#125; else &#123; if (A.y1==B.y1)&#123; return A.y2&gt;B.y2; &#125; else &#123; return A.y1&gt;B.y1; &#125; &#125;&#125;#define pii pair&lt;int,int&gt; #define l first#define r second#define mp make_pairset&lt;pii&gt;now;//现在扫描到的竖线中的线段sgmt s[MAXN*2];int tot;//全部的竖线inline void Add(sgmt A)&#123;s[++tot]=A;&#125;int main()&#123; int n=read(),m=read(),k=read(); for (register int i=1;i&lt;=k;++i)&#123; int x1=read(),y1=read(),x2=read(),y2=read(); Add(sgmt&#123;x1,y1,y2,0&#125;); Add(sgmt&#123;x2+1,y1,y2,1&#125;);//类似于差分的一个东西 &#125; Build(1,m,1); Update(1,1,1); sort(s+1,s+1+tot); int p=1; for (p=1;s[p].x==1;++p)&#123;//先把竖线加入初始的set if (s[p].flag==0)&#123; now.insert(mp(s[p].y1,s[p].y2)); &#125; &#125; now.insert(mp(0,0)); for (register int i=2;i&lt;=n;++i)&#123; for (register int j=p;s[j].x==i;++j)&#123;//二分得到low 线段树区间加，维护DP int pos=s[j].y2+1; if (s[j].flag==0&amp;&amp;pos&lt;=m)&#123; //s[j].y2+1&lt;=m不加会RE int low=(*--now.lower_bound(mp(pos,0))).r; Update(1,pos,Query(1,low+1,pos));//玄学边界 &#125; &#125; //下面都是维护now集合，删去移动区间导致消失的线段，加上新的线段 //这两个顺序不能换（公交车先下后上的原理） for (register int j=p;s[j].x==i;++j)&#123;//减去消失的线段 if (s[j].flag)&#123; now.erase(mp(s[j].y1,s[j].y2)); &#125; &#125; for (register int j=p;s[j].x==i;++j,++p)&#123; if (!s[j].flag)&#123; now.insert(mp(s[j].y1,s[j].y2)); Cover(1,s[j].y1,s[j].y2);//顺便把有障碍物的区间设成0 &#125; &#125; //至于F[i][j]=F[i-1][j]不要管，因为区间从左到右移动，直接继承上一个区间的F[i][j] &#125; cout&lt;&lt;Query(1,(*(--now.end())).l+1,m)%MOD&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gaisaiyuno.github.io/tags/动态规划/"}]},{"title":"绍兴一中游记","slug":"绍兴一中游记","date":"2019-07-13T12:34:14.000Z","updated":"2019-10-09T14:01:58.471Z","comments":true,"path":"archives/9b816715.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/9b816715.html","excerpt":"","text":"本游记从7.16开始更新 典型的绍兴一中一天 早上：模拟赛 中午：买快乐水+颓 下午：听讲解，绝对听不懂 典型的讲解过程： 绿衣/红衣/蓝衣大佬上台讲课，听不懂也要鼓掌。 下午划水+写题解 晚上继续颓。 7.16试着出了一道数学题，自以为很水。。。 NOI$Day1$爆零，第一题敲了一个$Dijkstra$，应该能拿$70$分。第二题敲了一个大暴力，第三题敲的是记忆化搜索，自以为能过几个点，然鹅第二个大数据就$WA$了，开始自闭 7.17讲数论，一开始还能听懂，后面逐渐掉线，最后讲到拉格朗日插值法，心里一万只cnm奔腾而过。（提高组会考这个毒瘤？） 下午，被$ypy$大佬拉着强推数学公式，感觉越推越糊涂。 7.18打NOI比赛，$T1$敲了一个打暴力，发现时限没有爆，但是内存爆了（自闭），$T2$$T3$不可做。$ypy$巨佬说他有一个线段树建图的方法，可以拿到$72$分，$Orz$本来说下午再交，结果下午NOI网站上不了，更加自闭，然后Day2就爆0了。 下午，一道题也没A，只是写了写题解，刷了刷知乎，感觉蜃是颓废。 本来相加一个评论系统，结果加了以后网站变成德语，害怕。 7.19上午开始打模拟赛，$T1$敲了一个玄学随机化，一对拍，发现竟然过了，$T2$打的是指数级暴力，$T3$题目很迷，感觉意思理解错了。 下午发现爆零了，$T1$竟然没有被卡，拿了$100$，$T2$就是正常暴力分数——$20$，$T3$ 大家都$A$了，原来真的是意思理解错了，$I’m Angry$ 晚上准备写写题解 7.20颓废，上午开始打模拟赛，$T1$题目又看错，调了甚久，才发现意思理解错了，不过暴力也打了$60$分，$T2$神仙题，特判写挂了，只有$20$分，$T3$一眼看上去$cdq$分治，后来才发现是$DAG$的最小链覆盖，打了一个贪心，竟然一分都没骗到，不知道反例在哪里。 7.21切了几道$YNOI$，被常数恶心到了。 7.22讲图论，一开始还能听懂，后来懵逼。 7.23自由练习，在机房颓废，刷了一天$\\rm Bangumi$ （原来我还有这么多番没有看） 7.24讲$\\rm dp$，有一题我口胡是线段树，结果正解一个前缀和就搞定了。 刷了一大堆毒瘤$\\rm dp$ 7.25自由练习 刷$\\rm Bangumi$ 7.26膜你赛，$\\rm T1$是一个打表题，全部爆$0$，话说我的$462000$是怎么算出来的？ $\\rm T2$恶臭题面，看了一个小时也没有看出来样例怎么搞，后来在大佬$\\rm zhh$的提醒下终于看懂了。 话说暴力$70$分也挺不错 $\\rm T3$一眼看上去是$\\rm dp$，考完之后才发现一个$\\rm bfs$就能水$90$分，卡卡常就过了 颓废。 晚上刷了几道恶臭树链剖分。 7.27还是膜你赛，$\\rm T1$恶臭数学题，出题人说是因数分解，不超过普及组考纲。 $\\rm T2$是一个树形$\\rm dp$，还是比较巧妙，正解是换根法，有人随机选根$\\rm dp$，竟然有$80$分，orz $\\rm T3$是一个数学题+$\\rm dp$，状压一下有$50$分，正解是玄学组合数乱推，感觉$\\rm T3$像我出过的一道题的进阶版。 竟然有$rk3$，也算完美收尾。 话说这出题人把文件名设成$\\rm naiiiiiiive$，模数设成$19260817$，还时限$+1s$，怕不要上八月枪毙名单 7.28玩+颓 晚上补冰菓 天气甚热 7.29玩+颓 晚上补冰菓 天气甚热 7.30回家，在高铁上面补冰菓，补到一半，突然文件坏了，想打人。 于是又看了一遍轻音2，发现田井中律和千反田的声优竟然是同一个人，声优都是怪物。 在高铁上切毒瘤数据结构，网络那题写了四个$\\log$的做法没调出来。 二分答案+树链剖分+树套树大法好","categories":[],"tags":[{"name":"游记","slug":"游记","permalink":"https://gaisaiyuno.github.io/tags/游记/"}]},{"title":"CF691E Xor-sequences 矩阵快速幂","slug":"CF691E Xor-sequences","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/4fae5fc4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4fae5fc4.html","excerpt":"","text":"传送门可以用矩阵快速幂解决$k$很多，但是我们分析可以看出，$dp[k]=dp[k-1] * a$($dp[k]$和$a$都是矩阵)($a[i][j]$即$a[i]$ xor $a[j]$中二进制$1$的个数模$3$是否等于$0$)$dp[1]$是什么自己想一想最后求$dp[k]$的元素之和即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define MOD 1000000007#define MAXN 105using namespace std;long long n,k,ans;//快读快写inline long long read()&#123; char ch; long long f=1,x=0; ch=getchar(); while (ch&gt;'9'||ch&lt;'0')&#123; if (ch=='-')&#123; f=-1; &#125; ch=getchar(); &#125; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=x*10+ch-'0'; ch=getchar(); &#125; return f*x;&#125;inline void print(long long x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) print(x/10); putchar(x%10+'0');&#125;struct binary&#123; bool num[65]; long long len; void clear()&#123; memset(num,0,sizeof(num)); &#125; void convert(long long a)&#123; long long i=0; while (a&gt;0)&#123; num[i++]=a&amp;1; a&gt;&gt;=1; &#125; len=i; &#125; long long SumTrue()&#123; long long sum=0; for (long long j=0;j&lt;len;j++)&#123; sum+=num[j]; &#125; return sum; &#125;&#125;a[MAXN];binary operator ^ (const binary &amp;a,const binary &amp;b)&#123; binary c; long long maxlen=max(a.len,b.len); for (long long i=0;i&lt;maxlen;i++)&#123; c.num[i]=a.num[i] xor b.num[i]; &#125; c.len=maxlen; return c;&#125;struct matrix&#123; long long v[MAXN][MAXN]; void clear()&#123; memset(v,0,sizeof(v)); &#125; void YPYlovesDYF()&#123; for (long long i=0;i&lt;n;i++)&#123; for (long long j=0;j&lt;n;j++)&#123; binary c=a[i]^a[j]; v[i][j]=(c.SumTrue()%3==0); &#125; &#125; &#125;&#125;;matrix operator *(const matrix &amp;a,const matrix &amp;b)&#123; matrix ans; ans.clear(); for (long long i=0;i&lt;n;i++)&#123; for (long long j=0;j&lt;n;j++)&#123; for (long long k=0;k&lt;n;k++)&#123; ans.v[i][j]=(ans.v[i][j]+a.v[i][k]*b.v[k][j])%MOD; &#125; &#125; &#125; return ans;&#125;//矩阵快速幂matrix ksm(matrix a,long long pows)&#123; matrix ans; ans.clear(); for (long long i=0;i&lt;n;i++)&#123; ans.v[i][i]=1; &#125; while (pows&gt;0)&#123; if (pows&amp;1)&#123; ans=ans*a; &#125; a=a*a; pows&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; n=read(); k=read(); long long temp; for (long long i=0;i&lt;n;i++)&#123; temp=read(); a[i].clear(); a[i].convert(temp); &#125; matrix ans; ans.YPYlovesDYF(); ans=ksm(ans,k-1); long long ret=0; for (long long i=0;i&lt;n;i++)&#123; for (long long j=0;j&lt;n;j++)&#123; ret=(ret+ans.v[i][j])%MOD; &#125; &#125; print(ret); return 0;&#125; 发现自己太弱了,其实不用模拟二进制,用位运算来计算$1$的个数也可以 123456789int count(ll a)&#123; int ans = 0; while(a)&#123; if(a &amp; 1) ans++; a &gt;&gt;= 1; &#125; return ans;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://gaisaiyuno.github.io/tags/矩阵快速幂/"}]},{"title":"SP1043 GSS1 - Can you answer these queries I 线段树","slug":"SP1043 GSS1 - Can you answer these queries I","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/4171bd57.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/4171bd57.html","excerpt":"","text":"传送门线段树每个节点中存的值： $val[]$ ——区间所有数之和$lmax[]$ ——选的$a[i]$在区间内，且包括$a[l]$，连续$a[i]$之和的最大值$rmax[]$ ——选的$a[i]$在区间内，且包括$a[r]$，连续$a[i]$之和的最大值$maxn[]$ ——选的$a[i]$在区间内，连续$a[i]$之和的最大值（即本题答案）之所以要计算$lmax$，$rmax$，$val$，是为了合并节点时，能计算出$maxn$的值 这里介绍一种比较简洁的写法这道题中线段树的重点是节点合并，即$pushup$的过程不妨将节点合并的操作定义为+这样Query时就不用再敲一遍相同的代码，直接将查询结果相”+”即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define MAXN 50005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int lmax,rmax,maxn; //从左端开始最大值，从右端开始最大值，整段最大值 int val;//这段的和 &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 node operator + (node A,node B)&#123;//定义合并操作+ node temp; temp.lmax=max(B.lmax+A.val,A.lmax); //可以左区间全部选，加上右区间lmax,也可以直接用左区间lmax temp.rmax=max(A.rmax+B.val,B.rmax); //同理 temp.maxn=max(max(A.maxn,B.maxn),A.rmax+B.lmax); //可以直接用左右区间maxn,也可以将左右区间rmax,lmax合并 temp.val=A.val+B.val; temp.l=A.l,temp.r=B.r; return temp; &#125; void pushup(int i)&#123; tree[i]=tree[lc]+tree[rc]; &#125; void Build(int l,int r,int i)&#123;//建树 if (l==r)&#123; tree[i].lmax=tree[i].rmax=tree[i].maxn=tree[i].val=a[l]; tree[i].l=tree[i].r=l; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); pushup(i); &#125; node Query(int L,int R,int i)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i]; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&gt;mid) return Query(L,R,rc); else if (R&lt;=mid) return Query(L,R,lc); else return Query(L,R,lc)+Query(L,R,rc); //这里就不用再重复一遍节点合并的过程 &#125;&#125;;using namespace SegmentTree;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,n,1); int q=read(); while (q--)&#123; int L=read(),R=read(); node temp=Query(L,R,1); printf(\"%d\\n\",temp.maxn); &#125;&#125; 猫树：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#define MAXN (1&lt;&lt;20)+7#define MAXM 23using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int cnt[MAXN];inline void Init(int len)&#123; cnt[1]=0; for(register int i=2;i&lt;=len&lt;&lt;1;++i)&#123; cnt[i]=cnt[i&gt;&gt;1]+1; &#125;&#125;inline void write(int x)&#123; if(x&lt;0)putchar('-'),x*=-1; if(!x)putchar(48); static int sta[45],tp; for(tp=0;x;x/=10)sta[++tp]=x%10; for(;tp;putchar(sta[tp--]^48)); putchar('\\n');&#125;int a[MAXN];namespace Meow_Tree&#123; int pos[MAXN];//编号 int maxn[MAXM][MAXN],pmax[MAXM][MAXN];//区间最大值，包含端点最大值 void Build(int l,int r,int i,int d)&#123; if (l==r) &#123; pos[l]=i; return ; &#125; int mid=(l+r)&gt;&gt;1; int sum,Max; sum=pmax[d][mid]=maxn[d][mid]=a[mid],Max=max(a[mid],0); for (register int i=mid-1;i&gt;=l;--i)&#123; sum+=a[i],Max+=a[i]; pmax[d][i]=max(pmax[d][i+1],sum); maxn[d][i]=max(maxn[d][i+1],Max); Max=max(Max,0); &#125; sum=pmax[d][mid+1]=maxn[d][mid+1]=a[mid+1],Max=max(a[mid+1],0); for (register int i=mid+2;i&lt;=r;++i)&#123; sum+=a[i],Max+=a[i]; pmax[d][i]=max(pmax[d][i-1],sum); maxn[d][i]=max(maxn[d][i-1],Max); Max=max(Max,0); &#125; Build(l,mid,i&lt;&lt;1,d+1); Build(mid+1,r,i&lt;&lt;1|1,d+1); &#125; inline int Query(int l,int r)&#123; if (l==r) return a[l]; int p=cnt[pos[l]]-cnt[pos[l]^pos[r]]; return max(max(maxn[p][l],maxn[p][r]),pmax[p][l]+pmax[p][r]); &#125;&#125;using namespace Meow_Tree;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i) &#123; a[i]=read(); &#125; int len=2; while (len&lt;n) len&lt;&lt;=1;//要建完全2叉树 Init(len); Build(1,len,1,1); int m=read(); while (m--)&#123; int l=read(),r=read(); printf(\"%d\\n\",Query(l,r)); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"}]},{"title":"SP1557 GSS2 - Can you answer these queries II 线段树","slug":"SP1557 GSS2 - Can you answer these queries II","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.359Z","comments":true,"path":"archives/d345d3a1.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/d345d3a1.html","excerpt":"","text":"感觉这题自己也讲不清，还是搬运洛谷的一篇题解吧。。。 作者: duyi 在Ta的博客查看 观察这题与GSS1的最主要差别是需要去重。 这样的问题有一个比较套路化的技巧（主要看个人经验）。就是可以离线做。我们将所有询问按r从小到大排序。 我们一次从11&lt;/span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到nn&lt;/span&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;扫过整个序列。假设现在扫到ii&lt;/span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。在线段树中，第jj&lt;/span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个叶子结点我们维护a[j]...a[i]a[j]…a[i]&lt;/span&gt;a[j]...a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;序列的和SumSum&lt;/span&gt;Sum&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。 如： 叶子结点1：a[1]+a[2]+...+a[i]a[1] + a[2] + … + a[i]&lt;/span&gt;a[1]+a[2]+...+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 叶子结点2：a[2]+a[3]+...+a[i]a[2] + a[3] + … + a[i]&lt;/span&gt;a[2]+a[3]+...+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; … 叶子结点i：a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 我们顺次扫过整个序列，在更新ii&lt;/span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时，由于相同值不能重复计算，所以a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;只能更新值a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;最近一次出现的位置j+1j+1&lt;/span&gt;j+1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;到ii&lt;/span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这段区间。对于每个位置上的数上一次出现的位置，我们可以用一个pre数组记录。 更新后： 叶子结点1：a[1]+a[2]+...+a[i−1]a[1] + a[2] + … + a[i-1]&lt;/span&gt;a[1]+a[2]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 叶子结点2：a[2]+a[3]+...+a[i−1]a[2] + a[3] + … + a[i-1]&lt;/span&gt;a[2]+a[3]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; … 叶子结点j：a[j]+a[j+1]+...+a[i−1]a[j] + a[j+1] + … + a[i-1]&lt;/span&gt;a[j]+a[j+1]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 叶子结点j+1：a[j+1]+a[j+2]+...+a[i−1]+a[i]a[j+1] + a[j+2] + … + a[i-1] + a[i]&lt;/span&gt;a[j+1]+a[j+2]+...+a[i−1]+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; … 叶子结点i-1：a[i−1]+a[i]a[i-1] + a[i]&lt;/span&gt;a[i−1]+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 叶子结点i：a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 考虑下一次更新。如果不考虑pre[i+1]pre[i+1]&lt;/span&gt;pre[i+1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（为说理方便，不妨设pre[i+1]=0pre[i+1]=0&lt;/span&gt;pre[i+1]=0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）我们会对线段树上所有节点都加上a[i+1]a[i+1]&lt;/span&gt;a[i+1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，于是： 此时叶子结点1变为：a[1]+a[2]+...+a[i−1]a[1] + a[2] + … + a[i-1]&lt;/span&gt;a[1]+a[2]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] 叶子结点2变为：a[2]+a[3]+...+a[i−1]a[2] + a[3] + … + a[i-1]&lt;/span&gt;a[2]+a[3]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] … 叶子结点j：a[j]+a[j+1]+...+a[i−1]a[j] + a[j+1] + … + a[i-1]&lt;/span&gt;a[j]+a[j+1]+...+a[i−1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] 叶子结点j+1：a[j+1]+a[j+2]+...+a[i−1]+a[i]a[j+1] + a[j+2] + … + a[i-1] + a[i]&lt;/span&gt;a[j+1]+a[j+2]+...+a[i−1]+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] … 叶子结点i-1：a[i−1]+a[i]a[i-1] + a[i]&lt;/span&gt;a[i−1]+a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] 叶子结点i：a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;+a[i+1] 我们发现，我们的操作实际上是对序列进行了自动去重。我们之所以能实现这样的去重，实质上是两步操作的结果： 第ii&lt;/span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;次更新时只更新pre[i]pre[i]&lt;/span&gt;pre[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;后面的节点。使得pre[i]pre[i]&lt;/span&gt;pre[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;及其前面的节点所对应的子序列都不包含a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。 在第i+1i+1&lt;/span&gt;i+1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;次更新时对不管是pre[i]pre[i]&lt;/span&gt;pre[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前的还是pre[i]pre[i]&lt;/span&gt;pre[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;后的节点，都统一加上a[i+1]a[i+1]&lt;/span&gt;a[i+1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。这样，对于pre[i]pre[i]&lt;/span&gt;pre[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;前的节点，就自动跳过了a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，在子序列中只保留了一次a[i]a[i]&lt;/span&gt;a[i]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的值，巧妙的实现了去重。 如此一来，当我们更新到位置kk&lt;/span&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;时，每个叶子节点都维护着一个以自己开头，以a[k]（或a[k-1]，这是去重的结果）结尾的不含重复数字的子序列。所谓的子序列，就是再原序列里不一定连续的一段数。而我们维护的这些子序列不连续，当且仅当中间有重复数字被去除。 这样，当扫描到的k等于当前询问的r时，我们就可以去线段树里找答案了。然而，以r结尾的子序列并不一定是最优的，因此我们对于线段树里的每个节点还要维护一个Max。表示在扫描整个序列的过程中，在该节点所管辖的范围内所出现过的最大的Sum值。 现在，每个叶子节点都对应了一段子序列的和。我们要高效地求出所有这些和中最大的一个，于是问题就转化为了用线段树求区间最大值。由于在扫描整个序列的过程中，我们需要不断地对线段树进行更新，为了高效地维护Sum和Max，我们引入懒标记LazySum和LazyMax。 当我们用 a[i] 更新当前整个区间时： Sum += a[i] Max = max(Sum, Max) LazySum += a[i] LazyMax = max(LazySum, LazyMax) 当我们下放懒标记时 son.Max = max(son.Max,son.sum+fa.LazyMax) son.Sum += fa.LazySum son.LazyMax = max(son.LazyMax,son.LazySum+fa.LazyMax) son.LazySum += fa.LazySum 那么对于区间[l,r][l,r]&lt;/span&gt;[l,r]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，当我们更新到rr&lt;/span&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;以后，查询线段树[l,r][l,r]&lt;/span&gt;[l,r]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这段区间的Max即可。 参考代码：（我的代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define MAXN 100005#define INF 0x7fffffffusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int sum,maxn;//maxn:sum历史最大值 int sumtag,maxtag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].sum=max(tree[lc].sum,tree[rc].sum); tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; inline void Change(int s,int i)&#123; tree[s].maxn=max(tree[s].maxn,tree[s].sum+tree[i].maxtag); tree[s].sum+=tree[i].sumtag; tree[s].maxtag=max(tree[s].maxtag,tree[s].sumtag+tree[i].maxtag); tree[s].sumtag+=tree[i].sumtag; &#125; inline void pushdown(int i)&#123; Change(lc,i),Change(rc,i); tree[i].maxtag=tree[i].sumtag=0; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].sum+=val; tree[i].maxn=max(tree[i].sum,tree[i].maxn); tree[i].sumtag+=val; tree[i].maxtag=max(tree[i].maxtag,tree[i].sumtag); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].maxn; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1,ans=-INF; if (L&lt;=mid) ans=max(ans,Query(lc,L,R)); if (mid&lt;R) ans=max(ans,Query(rc,L,R)); return ans; &#125;&#125;using namespace SegmentTree;int pre[MAXN*2],last[MAXN*2];//求出a[i]前使a[j]=a[i]最大的j，类似于链表int a[MAXN];#define NUM 100005struct Qry&#123; int l,r; int id;&#125;Q[MAXN];bool operator &lt; (const Qry &amp;A,const Qry &amp;B)&#123; return A.r&lt;B.r;&#125;int ans[MAXN];int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); pre[i]=last[a[i]+NUM]; last[a[i]+NUM]=i; &#125; int q=read(); for (register int i=1;i&lt;=q;++i)&#123; Q[i].l=read(),Q[i].r=read(); Q[i].id=i; &#125; Build(1,1,n); sort(Q+1,Q+1+q); register int pos=1; for (register int i=1;i&lt;=n;++i)&#123; Update(1,pre[i]+1,i,a[i]); for (;pos&lt;=q;++pos)&#123; if (Q[pos].r&gt;i)&#123; break; &#125; ans[Q[pos].id]=Query(1,Q[pos].l,Q[pos].r); &#125; &#125; for (register int i=1;i&lt;=q;++i)&#123; printf(\"%d\\n\",ans[i]); &#125;&#125; 不知道为什么格式乱了","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"GSS","slug":"GSS","permalink":"https://gaisaiyuno.github.io/tags/GSS/"},{"name":"离线","slug":"离线","permalink":"https://gaisaiyuno.github.io/tags/离线/"}]},{"title":"CF25E Test 字符串哈希","slug":"CF25E Test","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/c161ca58.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/c161ca58.html","excerpt":"","text":"传送门 做法：字符串哈希 不过似乎$\\rm kmp$也能做分类讨论两字符串$A B$合并的情况：1.$B$为$A$的子串 - 直接枚举$B$在$A$中的位置，哈希判断即可2.$A$为$B$的子串 - 这里由于偷懒，就没写，在暴力枚举时枚举多一些情况3.$A B$有相同长度的前缀和后缀 - 枚举前缀后缀长度，哈希判断4.$A B$没有相同的前缀和后缀 - 直接将字符串相加可以看出，字符串减少的长度$1=2&gt;3&gt;4$于是优先判断$1$、$2$ 然后才是$3$、$4$最后暴力枚举，记录答案 还有一个神坑：$s1,s2$合并，长度可能超过$100000$，所以数组要开$200005$ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define Base 131#define MAXN 200005#define LL long long#define ll long long#define mem(a) memset(a,0,sizeof(a))#define memmax(a) memset(a,0x3f,sizeof(a))#define ull unsigned long longusing namespace std;ull p[MAXN];;ull h1[MAXN],h2[MAXN];inline void Init_Hash(string A,ull *h)&#123;//哈希预处理 h[0]=(A[0]-'a'); for (register int i=1;i&lt;(int)A.size();++i)&#123; h[i]=h[i-1]*Base+(ull)(A[i]-'a'); &#125;&#125;inline ull Hash(int l,int r,ull *h)&#123; //利用unsigned long long 自然溢出来哈希 if (l==0) return h[r];//这个特判很重要 return h[r]-h[l-1]*p[r-l+1];&#125;inline string connect(string A,string B)&#123; //将字符串合并的函数 Init_Hash(A,h1),Init_Hash(B,h2); if (B.size()&lt;=A.size())&#123; //B为A的字串,一定更优 ull HashB=Hash(0,B.size()-1,h2); for (register int i=0;i&lt;(int)A.size()-(int)B.size()+1;++i)&#123; if (Hash(i,i+(int)B.size()-1,h1)==HashB)&#123; return A; &#125; &#125; &#125; int Size=min(A.size(),B.size()); for (register int i=Size-1;i&gt;=1;--i)&#123;//枚举相同字串长度 if (Hash((int)A.size()-i,(int)A.size()-1,h1)==Hash(0,i-1,h2))&#123; string ans=A; for (register int j=i;j&lt;(int)B.size();++j)&#123; ans+=B[j]; &#125; return ans; &#125; &#125; return A+B;//AB没有相同的前缀和后缀&#125;inline void Init_P()&#123;//预处理Base^n p[0]=1; for (register int i=1;i&lt;MAXN;++i)&#123; p[i]=p[i-1]*Base; &#125;&#125;int main()&#123; Init_P(); string s1,s2,s3; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; int ans=0x7fffffff; ans=min(ans,(int)connect(s1,connect(s2,s3)).size()); ans=min(ans,(int)connect(s1,connect(s3,s2)).size()); ans=min(ans,(int)connect(s2,connect(s1,s3)).size()); ans=min(ans,(int)connect(s2,connect(s3,s1)).size()); ans=min(ans,(int)connect(s3,connect(s1,s2)).size()); ans=min(ans,(int)connect(s3,connect(s2,s1)).size()); ans=min(ans,(int)connect(connect(s2,s3),s1).size()); ans=min(ans,(int)connect(connect(s3,s2),s1).size()); ans=min(ans,(int)connect(connect(s1,s3),s2).size()); ans=min(ans,(int)connect(connect(s3,s1),s2).size()); ans=min(ans,(int)connect(connect(s1,s2),s3).size()); ans=min(ans,(int)connect(connect(s2,s1),s3).size()); //暴力枚举12种情况（太暴力了） printf(\"%d\\n\",ans);&#125; 然后你就可以成功地水一道黑题了","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"https://gaisaiyuno.github.io/tags/字符串哈希/"}]},{"title":"CF482B Interesting Array 线段树","slug":"CF482B Interesting Array","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/6cbf9bb0.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/6cbf9bb0.html","excerpt":"","text":"题面构建一个序列$a$,满足$m$条限制. 限制形如$$: $a[l]$&amp;$a[l+1]$&amp;…&amp;$a[r-1]$&amp;$a[r]=q$;(此处&amp;为位运算的$\\rm and$操作). 题解我们发现： 如果$q$的第$i$位为$1$，那么$a[l],a[l+1]…a[r]$的第$i$位都为$1$。 如果$q$的第$i$位为$0$，那么$a[l],a[l+1]…a[r]$的第$i$位至少有一个为$0$。 考虑将将所有二进制状态压缩在一个$int$里，用线段树维护。将$a[1]$到$a[n]$先设为$0$。先满足第一个条件（$a[l],a[l+1]…a[r]$的第$i$位都为$1$），用按位或运算将$a[l],a[l+1]…a[r]$的第$i$位设成$1$。最后扫一遍，看满不满足第二个条件，做判断。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int ans[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int val,tag; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].val=tree[lc].val&amp;tree[rc].val; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; tree[lc].tag|=tree[i].tag; tree[rc].tag|=tree[i].tag; tree[lc].val|=tree[i].tag; tree[rc].val|=tree[i].tag; tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].val=tree[i].tag=0; if (l==r) return ; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].val|=val; tree[i].tag|=val; return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&gt;mid) return Query(rc,L,R); else if (mid&gt;=R) return Query(lc,L,R); else return Query(lc,L,R)&amp;Query(rc,L,R); &#125; void Out(int i)&#123;//记录结果 if (tree[i].l==tree[i].r)&#123; ans[tree[i].l]=tree[i].val; return ; &#125; pushdown(i); Out(lc); Out(rc); &#125;&#125;using namespace SegmentTree;int ql[MAXN],qr[MAXN],qp[MAXN];int main()&#123; int n=read(),m=read(); Build(1,1,n); for (register int i=1;i&lt;=m;++i)&#123; ql[i]=read(),qr[i]=read(),qp[i]=read(); Update(1,ql[i],qr[i],qp[i]);//第i位设成1 &#125; Out(1); for (register int i=1;i&lt;=m;++i)&#123; if (Query(1,ql[i],qr[i])!=qp[i])&#123;//扫一遍，判断满不满足 puts(\"NO\"); return 0; &#125; &#125; puts(\"YES\"); for (register int i=1;i&lt;=n;++i)&#123; printf(\"%d \",ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"CF464E The Classic Problem 主席树","slug":"CF464E The Classic Problem","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/28c938b4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/28c938b4.html","excerpt":"","text":"传送门一眼看上去：这不就是最短路的模板吗？两眼：边权太大了，怎么开的下？考虑还是用$\\rm Dijkstra$解决，每个点开一棵线段树，存储二进制的状态 我们要实现的功能:1.给二进制数加上$2^k$，这可以看成把$k$位后所有连续的$1$变成0，再把所有连续$1$后的那一个$0$变成$1$2.比较两个二进制数的大小，先比较高位，再比较低位。 但是用普通线段树实现，空间为$O(nm)$会爆掉。考虑使用主席树，每次只要新开$\\log n$的节点，空间复杂度为$O(n \\log n)$ 代码细节比较多，比较烦人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define MAXN 500005#define MOD 1000000007#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int pow2[MAXN];inline void Init()&#123; pow2[0]=1; for (register int i=1;i&lt;MAXN;++i)&#123; pow2[i]=(pow2[i-1]&lt;&lt;1)%MOD; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int v; &#125;tree[MAXN*30]; #define lc(i) tree[i].l #define rc(i) tree[i].r inline void pushup(int i,int len)&#123; //维护区间[l,r]代表的二进制数MOD1e7的值 tree[i].v=(tree[lc(i)].v+tree[rc(i)].v*pow2[len]%MOD)%MOD; &#125; int tot; #define Lson lc(x),lc(y),L,mid #define Rson rc(x),rc(y),mid+1,R int Update(int x,int &amp;y,int L,int R,int index)&#123; y=++tot; lc(y)=lc(x),rc(y)=rc(x); if (L==R)&#123; tree[y].v=tree[x].v^1; return tree[x].v;//有进位：1，没进位：0 &#125; int mid=(L+R)&gt;&gt;1,ans; if (index&lt;=mid)&#123; ans=Update(Lson,index); if (ans!=0) ans=Update(Rson,index);//如果进位到右边，还要继续修改右子树 &#125; else &#123;//右边的不可能进位 ans=Update(Rson,index); &#125; pushup(y,mid-L+1); return ans; &#125; bool Compare(int x,int y,int L,int R)&#123; //比较可持久化线段树x,y对应二进制数的大小 if (L==R) &#123; return tree[x].v&gt;tree[y].v; &#125; int mid=(L+R)&gt;&gt;1; if (tree[rc(x)].v==tree[rc(y)].v)&#123;//优先比较右边 return Compare(Lson); &#125; else &#123; return Compare(Rson); &#125; &#125;&#125;using namespace SegmentTree; int maxn;struct Node&#123; int u,rt;&#125;;bool operator &lt; (Node A,Node B)&#123; return Compare(A.rt,B.rt,0,maxn);&#125; struct Edge&#123; int to,len;&#125;;vector&lt;Edge&gt;G[MAXN];inline void AddEdge(int u,int v,int w)&#123; Edge temp; temp.to=v,temp.len=w; G[u].push_back(temp);&#125;int vis[MAXN],dis[MAXN],rt[MAXN],pre[MAXN],dep[MAXN];int s,t;void Out(int u,int dep)&#123;//输出路径 if (u==s)&#123;printf(\"%I64d\\n%I64d \",dep,s);return ;&#125; Out(pre[u],dep+1); printf(\"%I64d \",u);&#125;#undef intint main()&#123;#define int long long Init(); int n=read(),m=read(); for (register int i=1;i&lt;=m;++i)&#123; int u=read(),v=read(),w=read(); AddEdge(u,v,w); AddEdge(v,u,w); maxn=max(maxn,w); &#125; maxn+=log2(m)+1;//最多进log2(m)次位 s=read(),t=read(); priority_queue&lt;Node&gt;Q; Q.push(Node&#123;s,0&#125;); while (Q.size())&#123; int u=Q.top().u,R=Q.top().rt; Q.pop(); if (vis[u]) continue; vis[u]=true; for (register int i=0;i&lt;G[u].size();++i)&#123; int v=G[u][i].to,w=G[u][i].len,_rt=0; Update(R,_rt,0,maxn,w); if (!rt[v]||Compare(rt[v],_rt,0,maxn))&#123; rt[v]=_rt,pre[v]=u; dep[v]=dep[u]+1; Q.push(Node&#123;v,rt[v]&#125;); &#125; &#125; &#125; if (!vis[t])&#123; printf(\"-1\\n\"); &#125; else &#123; printf(\"%I64d\\n\",tree[rt[t]].v); Out(t,1); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"图论","slug":"图论","permalink":"https://gaisaiyuno.github.io/tags/图论/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://gaisaiyuno.github.io/tags/Dijkstra/"}]},{"title":"CF280D k-Maximum Subsequence Sum 线段树","slug":"CF280D k-Maximum Subsequence Sum（线段树）","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/6ce8a7e1.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/6ce8a7e1.html","excerpt":"","text":"传送门 题面大意：长度为$n$的数列，支持两种操作：$1.$修改某个位置的值$2.$询问区间$[l,r]$里选出至多$k$个不相交的子段和的最大值。 一共有$m$个操作 解法：暴力$dp$+滚动数组（在本地卡进$2s$）模拟赛的时候有人用这个方法$A$了$dp[i][j][p]$表示进行到$a[i]$，用了$j$个区间，$a[i]$选不选大力转移即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace bf&#123; int dp[2][25][2]; inline int query(int l,int r,int k)&#123; memset(dp,0,sizeof(dp)); for (register int i=l;i&lt;=r;++i)&#123; for (register int j=1;j&lt;=k;++j)&#123; dp[i&amp;1][j][0]=max(dp[!(i&amp;1)][j][1],dp[!(i&amp;1)][j][0]); dp[i&amp;1][j][1]=max(dp[!(i&amp;1)][j-1][0],dp[!(i&amp;1)][j][1])+a[i]; dp[i&amp;1][j][1]=max(dp[i&amp;1][j][1],dp[!(i&amp;1)][j-1][0]+a[i]); &#125; &#125; int ans=-0x7fffffff; for (register int i=0;i&lt;=k;++i)&#123; ans=max(ans,max(dp[r&amp;1][i][1],dp[r&amp;1][i][0])); &#125; return ans; &#125;&#125;using namespace bf;int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; int q=read(); while (q--)&#123; int opr=read(); if (opr==0)&#123; int i=read(),val=read(); a[i]=val; &#125; else &#123; int l=read(),r=read(),k=read(); printf(\"%d\\n\",query(l,r,k)); &#125; &#125;&#125; 正解毒瘤线段树，维护$18$个值：$sum$ 区间和$l,r$ 区间左右边界$maxs$ 最大子段和$mins$ 最小子段和$maxsl$ 最大子段和左边界$maxsr$最大子段和右边界$minsl$最小子段和左边界$minsr$最小子段和右边界$maxl,minl$最大，最小前缀和$maxlp,minlp$最大，最小前缀和右端点（显然左端点确定）$maxr,minr$最大，最小后缀和$maxrp,minrp$最大，最小后缀和左端点$flag$翻转标记 每次取最大子段和，$ans+=$最大子段和，然后把最大子段和的区间每个数$*-1$，如果最大子段和$&lt;=0$或者操作次数$&gt;k$退出 你肯定会有疑问：这样怎么保证取出来不超过$k$段？ 设原数列最大子段和为$\\sum_{p=i}^{j} a_p$：$a_1 a_2 a_3 … a_i a_{i+1} a_{i+2} … a_{j-1} a_{j} …. a{n}$取出最大子段和，区间$*-1$$a_1 a_2 a_3 … -a_i -a_{i+1} -a_{i+2} … -a_{j-1} -a_{j} …. a{n}$假设操作一次后最大子段和变为$\\sum_{p=i’}^{j’} a_p$，其中$i’&lt;j$且$j&lt;j’$$a_1 a_2 a_3 … a_{i’} a_{i’+1} a_{i’+2} … a_{j’-1} a_{j’} …. a{n}$两次结果相加，中间部分抵消：$a_i + a_{i+1} + a_{i+2} … + a_{j-1} + a_{j} +a_{i’} + a_{i’+1} + a_{i’+2} +… a_{j’-1} + a_{j’}$$=a_i+…+a_{i’-1}+a_{j+1}+…+a_{j’}$结果变为两段，即$k=2$其他情况自己脑补一下，就会发现其实每次操作后段数最多$+1$ 贪心的正确性可以用费用流证明，这里贴一篇博客 p.s.不要忘记恢复修改过的线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];bool DBG=true;namespace SegmentTree&#123; struct node&#123; int sum;//区间和 int l,r;//区间左右边界 int maxs;//最大子段和 int mins;//最小子段和 int maxsl;//最大子段和左边界 int maxsr;//最大子段和右边界 int minsl;//最小子段和左边界 int minsr;//最小子段和右边界 int maxl,minl;//最大，最小前缀和 int maxlp,minlp;//最大，最小前缀和右端点（显然左端点确定） int maxr,minr;//最大，最小后缀和 int maxrp,minrp;//最大，最小后缀和左端点 bool flag;//翻转标记 &#125;tree[MAXN&lt;&lt;2]; inline void sw(int &amp;a,int &amp;b)&#123;int temp=a;a=b;b=temp;&#125; inline void re(int &amp;a)&#123;a=-a;&#125; inline void Rev(int i)&#123;//翻转tree[i] re(tree[i].sum); sw(tree[i].maxs,tree[i].mins); re(tree[i].maxs),re(tree[i].mins); sw(tree[i].maxsl,tree[i].minsl); sw(tree[i].maxsr,tree[i].minsr); sw(tree[i].maxl,tree[i].minl); re(tree[i].maxl),re(tree[i].minl); sw(tree[i].maxlp,tree[i].minlp); sw(tree[i].maxr,tree[i].minr); re(tree[i].maxr),re(tree[i].minr); sw(tree[i].maxrp,tree[i].minrp); tree[i].flag^=1; &#125; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 #define nd tree[i] inline void pushdown(int i)&#123; if (tree[i].flag) Rev(lc),Rev(rc),tree[i].flag=0; &#125; node operator + (const node &amp;A,const node &amp;B)&#123; //这里不能写错，要不然调一年 node C; C.l=A.l,C.r=B.r; C.sum=A.sum+B.sum; C.flag=false; //维护maxs,mins,maxsl,minsl if (max(A.maxs,B.maxs)&gt;A.maxr+B.maxl)&#123; if (A.maxs&gt;B.maxs)&#123; C.maxs=A.maxs; C.maxsl=A.maxsl; C.maxsr=A.maxsr; &#125; else &#123; C.maxs=B.maxs; C.maxsl=B.maxsl; C.maxsr=B.maxsr; &#125; &#125; else &#123; C.maxs=A.maxr+B.maxl; C.maxsl=A.maxrp; C.maxsr=B.maxlp; &#125; if (min(A.mins,B.mins)&lt;A.minr+B.minl)&#123; if (A.mins&lt;B.mins)&#123; C.mins=A.mins; C.minsl=A.minsl; C.minsr=A.minsr; &#125; else &#123; C.mins=B.mins; C.minsl=B.minsl; C.minsr=B.minsr; &#125; &#125; else &#123; C.mins=A.minr+B.minl; C.minsl=A.minrp; C.minsr=B.minlp; &#125; //维护maxl,minl,维护其端点 if (A.sum+B.maxl&gt;A.maxl)&#123; C.maxl=A.sum+B.maxl; C.maxlp=B.maxlp; &#125; else &#123; C.maxl=A.maxl; C.maxlp=A.maxlp; &#125; if (A.sum+B.minl&lt;A.minl)&#123; C.minl=A.sum+B.minl; C.minlp=B.minlp; &#125; else &#123; C.minl=A.minl; C.minlp=A.minlp; &#125; //维护maxr,minr,维护其端点 if (A.maxr+B.sum&gt;B.maxr)&#123; C.maxr=A.maxr+B.sum; C.maxrp=A.maxrp; &#125; else &#123; C.maxr=B.maxr; C.maxrp=B.maxrp; &#125; if (A.minr+B.sum&lt;B.minr)&#123; C.minr=A.minr+B.sum; C.minrp=A.minrp; &#125; else &#123; C.minr=B.minr; C.minrp=B.minrp; &#125; return C;//快乐地return &#125; inline void pushup(int i)&#123; bool temp=tree[i].flag; tree[i]=tree[lc]+tree[rc]; tree[i].flag=temp; &#125; inline void Set(int i,int val)&#123; nd.sum=nd.maxs=nd.mins=nd.maxl=nd.minl=nd.maxr=nd.minr=val; &#125; void Build(int l,int r,int i)&#123; tree[i].flag=0; if (l==r)&#123; tree[i].l=l,tree[i].r=l; Set(i,a[l]); nd.maxsl=nd.maxsr=nd.minsl=nd.minsr=nd.maxlp=nd.minlp=nd.maxrp=nd.minrp=l; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(l,mid,lc); Build(mid+1,r,rc); pushup(i); &#125; node Query(int L,int R,int i)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i]; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (mid&gt;=R) return Query(L,R,lc); else if (mid&lt;L) return Query(L,R,rc); else return Query(L,R,lc)+Query(L,R,rc); &#125; void Update(int L,int R,int i)&#123;//区间*-1 if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; Rev(i); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (mid&gt;=R) Update(L,R,lc); else if (mid&lt;L) Update(L,R,rc); else Update(L,R,lc),Update(L,R,rc); pushup(i); &#125; void Update_pos(int index,int i,int val)&#123;//单点修改 if (tree[i].l==tree[i].r)&#123; Set(i,tree[i].flag?-val:val); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) Update_pos(index,lc,val); else Update_pos(index,rc,val); pushup(i); &#125;&#125;using namespace SegmentTree;int L[MAXN],R[MAXN];int main()&#123; int n=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,n,1); int q=read(); while (q--)&#123; int opr=read(); if (opr==1)&#123; int l=read(),r=read(),k=read(); int tot=0,ans=0; for (register int i=1;i&lt;=k;++i)&#123;//贪心 node Q=Query(l,r,1); if (Q.maxs&lt;=0) break; ans+=Q.maxs; L[++tot]=Q.maxsl,R[tot]=Q.maxsr; Update(L[tot],R[tot],1); &#125; for (register int i=1;i&lt;=tot;++i)&#123;//恢复线段树 Update(L[i],R[i],1); &#125; printf(\"%d\\n\",ans); &#125; else &#123; int i=read(),val=read(); Update_pos(i,1,val); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"贪心","slug":"贪心","permalink":"https://gaisaiyuno.github.io/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"暴力","slug":"暴力","permalink":"https://gaisaiyuno.github.io/tags/暴力/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://gaisaiyuno.github.io/tags/毒瘤/"},{"name":"费用流","slug":"费用流","permalink":"https://gaisaiyuno.github.io/tags/费用流/"}]},{"title":"CF405D Toy Sum 随机化","slug":"CF405D-Toy-Sum","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/82e66741.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/82e66741.html","excerpt":"","text":"传送门 模拟赛的$\\rm T1$，感觉还是非常可做的。 考虑随机化（大雾），每次把没有用过的数组成的序列$S$打乱，从$S$依次取出数，加入答案集合，我们可以根据加进来的数得出最后一个数的大小，如果这个数还没有用过，那么将这个数加入答案集合，就得出了答案，直接退出。 目前这种做法还没有被卡掉，大概是数据水吧。。。 时间复杂度$O(玄学)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAXN 1000005#define ll long longusing namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;inline void print(ll x)&#123; if (x&gt;=10ll) print(x/10ll); putchar(x%10ll+48ll);&#125;ll num[MAXN],vis[MAXN],vis2[MAXN],tot;int main()&#123; ll S=1000000,n=(long long)read(); ll sum=0; for (register int i=1;i&lt;=n;++i)&#123; ll x=(long long)read(); vis2[x]=true; sum+=x-1; &#125; for (register int i=1;i&lt;=S;++i)&#123; if (!vis2[i]) num[++tot]=i; &#125; if (S&gt;=sum)&#123;//特判 if (!vis2[S-sum])&#123; printf(\"%lld\\n%lld\\n\",1ll,S-sum); return 0; &#125; &#125; for (register int t=1;t&lt;=2000000;++t)&#123; random_shuffle(num+1,num+1+tot); memcpy(vis,vis2,sizeof(vis)); ll res=0; for (register int i=1;i&lt;tot;++i)&#123; res+=(S-num[i]); vis[num[i]]=true; if (res&gt;=sum)&#123; break; &#125; if (sum-res&gt;S)&#123; continue; &#125; if (!vis[S-sum+res])&#123;//没有用过 print((long long)i+1ll),putchar('\\n'); for (register int j=1;j&lt;=i;++j)&#123; print(num[j]),putchar(' '); &#125; print(S-sum+res),putchar('\\n'); return 0; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"随机化","slug":"随机化","permalink":"https://gaisaiyuno.github.io/tags/随机化/"}]},{"title":"CF438D The Child and Sequence 线段树","slug":"CF438D The Child and Sequence","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/139c564f.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/139c564f.html","excerpt":"","text":"传送门 线段树的神奇操作考虑维护区间和，区间最大值。取模的时候，若当前区间的最大值小于$\\rm Mod$你就会发现这个区间的所有数都不会变，直接$\\rm return$ ，不用继续维护。 记得开$\\rm long$ $\\rm long$，我被$\\rm long$ $\\rm long$孙了很久 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define int long long#define MAXN 100005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN];namespace SegmentTree&#123; struct node&#123; int l,r; int val,maxn; &#125;tree[MAXN&lt;&lt;2]; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 void pushup(int i)&#123; tree[i].val=tree[lc].val+tree[rc].val; tree[i].maxn=max(tree[lc].maxn,tree[rc].maxn); &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; if (l==r)&#123; tree[i].val=tree[i].maxn=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int index,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].val=tree[i].maxn=val; return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) Update(lc,index,val); else Update(rc,index,val); pushup(i); &#125; void Mod(int i,int L,int R,int M)&#123; if (tree[i].maxn&lt;M) return ;//取模以后结果肯定不变 if (tree[i].l==tree[i].r)&#123; tree[i].val=tree[i].maxn=(tree[i].val%M); return ; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Mod(lc,L,R,M); if (mid&lt;R) Mod(rc,L,R,M); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return tree[i].val; &#125; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; int ans=0; if (L&lt;=mid) ans+=Query(lc,L,R); if (mid&lt;R) ans+=Query(rc,L,R); return ans; &#125;&#125;using namespace SegmentTree;#undef intint main()&#123;#define int long long int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,1,n); while (m--)&#123; int opr=read(); if (opr==1)&#123; int l=read(),r=read(); printf(\"%lld\\n\",Query(1,l,r)); &#125; else if (opr==2)&#123; int l=read(),r=read(),x=read(); Mod(1,l,r,x); &#125; else &#123; int k=read(),x=read(); Update(1,k,x); &#125; &#125;&#125; ```","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"P4986 逃离","slug":"P4986","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/250f58e0.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/250f58e0.html","excerpt":"","text":"前置芝士：牛顿迭代FFT 首先，我们将运动轨迹画出来：发现$hdxrie$只能沿半径走，$Althen$只能沿竖直或横向走。不妨将$Althen$的路径平移到两条垂直的线段上，总长不变。设移动时间为$t$，由勾股定理，我们有$(A(x) \\times t)^2=(B(x) \\times t)^2+(C(x) \\times t)^2$即$A(x)^2=B(x)^2+C(x)^2$发现$Len_a \\le 10^5$，所以不能用朴素算法来求$A(x)^2$，考虑时间复杂度为$O(n \\log n)$的快速傅里叶变换，我们可以很快地求出$A(x)^2$，$B(x)^2$和$C(x)^2$最后，我们把$B(x)^2,C(x)^2$移项到左边，得到一个函数$A(x)^2-B(x)^2-C(x)^2=0$我们可以用牛顿迭代求$A(x)^2-B(x)^2-C(x)^2=0$的所有解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#define MAXN 300005#define MoHa 19260817int tim=30;const double eps=1e-10,PI=acos(-1.0);using namespace std;inline int iread()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&lt;='9'&amp;&amp;ch&gt;='0')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48); ch=getchar(); &#125; return x*f;&#125;typedef vector&lt;int&gt; poly;namespace Poly&#123; struct complex&#123; double x,y; &#125;; complex operator + (const complex &amp;a,const complex &amp;b)&#123; return (complex)&#123;a.x+b.x,a.y+b.y&#125;; &#125; complex operator - (const complex &amp;a,const complex &amp;b)&#123; return (complex)&#123;a.x-b.x,a.y-b.y&#125;; &#125; complex operator * (const complex &amp;a,const complex &amp;b)&#123; return (complex)&#123;a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x&#125;; &#125; complex cA[MAXN],cB[MAXN]; int r[MAXN],pow2,n,m; inline void FFT(complex *A,int val,int len)&#123; for (int i=0;i&lt;len;++i)&#123; if (i&lt;r[i]) swap(A[i],A[r[i]]); &#125; for (int i=1;i&lt;len;i&lt;&lt;=1)&#123; complex Wn=(complex)&#123;cos(PI/i),val*sin(PI/i)&#125;; for (int j=0;j&lt;len;j+=(i&lt;&lt;1))&#123; complex t=(complex)&#123;1,0&#125;; for (int k=0;k&lt;i;++k,t=t*Wn)&#123; complex x=A[j+k],y=t*A[i+j+k]; A[j+k]=x+y; A[i+j+k]=x-y; &#125; &#125; &#125; if (val==-1) for (int i=0;i&lt;len;++i) A[i].x/=len; &#125; inline void init_fft(poly a)&#123; for (int i=0;i&lt;a.size();++i)&#123; cA[i].x=cB[i].x=(double)a[i]; cA[i].y=cB[i].y=0; &#125; &#125; inline poly mul(poly a)&#123; init_fft(a); int n=a.size()-1,m=a.size()-1; a.resize(m+2); int L=0; for (m+=n,n=1;n&lt;=m;n&lt;&lt;=1) L++; for (int i=0;i&lt;n;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)); FFT(cA,1,n),FFT(cB,1,n); for (int i=0;i&lt;=n;++i) cA[i]=cA[i]*cB[i]; FFT(cA,-1,n); for (int i=0;i&lt;a.size();++i) a[i]=(int)(cA[i].x+0.1); return a; &#125;&#125;using namespace Poly;poly SA,SB,SC,C1;inline void read(poly &amp;A,int len)&#123; for (int i=0;i&lt;=len;++i) A.push_back(iread());&#125;inline double F(poly &amp;R,double x)&#123; double ans=0; for (int i=R.size()-1;i&gt;=0;--i) ans=ans*x+(double)R[i]; return ans;&#125;inline void qd(poly &amp;F)&#123; C1.resize(F.size()-1); for (int i=0;i&lt;C1.size();++i)&#123; C1[i]=F[i+1]*(i+1); &#125;&#125;double L,R;inline double Newton(double x)&#123; qd(SC); double c; while (true)&#123; --tim; c=F(SC,x); if (fabs(c)&lt;eps) return x; x=x-c/F(C1,x); x=max(x,L),x=min(x,R); if (!tim) return 0; &#125;&#125;int main()&#123; int la,lb,lc; scanf(\"%d%d%d%lf%lf\",&amp;la,&amp;lb,&amp;lc,&amp;L,&amp;R); read(SA,la),read(SB,lb),read(SC,lc); SA=mul(SA),SB=mul(SB),SC=mul(SC); SC.resize(max(max(SA.size(),SB.size()),SC.size())); for (int i=0;i&lt;SC.size();++i)&#123; SC[i]-=SA[i]+SB[i]; &#125; double ans=Newton((L+R)/2.00); if (!tim) printf(\"Inconsistent!\\n\"); else printf(\"%.8lf\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"FFT","slug":"FFT","permalink":"https://gaisaiyuno.github.io/tags/FFT/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"牛顿迭代","slug":"牛顿迭代","permalink":"https://gaisaiyuno.github.io/tags/牛顿迭代/"}]},{"title":"CF316 E3. Summer Homework","slug":"CF316E3","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/5f98d0f3.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/5f98d0f3.html","excerpt":"","text":"设$F$为斐波那契数列，不妨设$F_{-1}=1$整个数列也就是$F_{-1}=1,F_{0}=0,F_{1}=1,F_{2}=1,F_{3}=2,F_{4}=3,F_{5}=5,F_{6}=8,….$ 定义数列$S(0)=F_1a_1+F_2a_2+F_3a_3+…+F_na_n$，定义数列$S(1)=F_2a_1+F_3a_2+F_4a_3+…+F_{n+1}a_n$即： S(m)=\\sum_{i=1}^{i \\le n} F_{i+m}a_i发现：$S(m+1)+S(m+2)=\\sum_{i=1}^{i \\le n} F_{i+m+1}a_i + \\sum_{i=1}^{i \\le n} F_{i+m+2}a_i=\\sum_{i=1}^{i \\le n} F_{i+m+3}a_i$$=S(m+3)$ 所以，$S$数列的递推关系的类似于斐波那契数列的递推关系。 现在，我们想只用$S(0)$和$S(1)$推出任意$S(m)$不妨设$S(0)=A$，$S(1)=B$，发现 S(0)=A \\times F_{-1}+B \\times F_0S(1)=A \\times F_0 + B \\times F_1S(2)=A \\times F_1 + B \\times F_2S(3)=A \\times F_2 + B \\times F_3S(4)=A \\times F_3 + B \\times F_4....最后我们发现：$S(m)=F_{m-1} \\times A+F_{m} \\times B = F_{m-1} \\times S(0)+F_{m} \\times S(1)$，且$S(0)，S(1)$是特殊情况需要加特判 考虑如何修改$S(0)$和$S(1)$，假设加上的数为c，发现： S'(0)=F_1(a_1+c)+F_2(a_2+c)+F_3(a_3+c)+...+F_n(a_n+c)=F_1a_1+F_2a_2+F_3a_3+...+F_na_n+c \\times (F_1+F_2+F_3+...+F_n)=S(0)+c \\times (F_1+F_2+F_3+...+F_n)所以，我们只要预处理$F$数组前缀和即可，修改$S(1)$也是同理。 考虑如何维护信息：设当前要合并的两个区间分别为$[l_1,r_1][l_2,r_2]$发现$S(0)=\\sum_{i=l_1}^{i \\le r_2} F_{i}a_i$$=\\sum_{i=l_1}^{i \\le r_1}F_ia_i + \\sum_{i=l_2+1}^{i \\le r_2}F_ia_i$$=S_l(0)+S_r(l_1-r_1+1)$维护$S(1)$也是同理。 记得要开$\\rm long$ $\\rm long$并且疯狂取模。 具体要看代码（可能和思路在下标上有所不同） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;#define MOD 1000000000#define MAXN 200005#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],f[MAXN],pref[MAXN],pref2[MAXN];inline void Init()&#123;//预处理F数组和前缀和 f[1]=1,f[2]=2; for (register int i=3;i&lt;MAXN;++i)&#123; f[i]=(f[i-1]+f[i-2])%MOD; &#125; for (register int i=1;i&lt;MAXN;++i)&#123; pref2[i]=(pref2[i-1]+f[i])%MOD; &#125; f[1]=1,f[2]=1; for (register int i=3;i&lt;MAXN;++i)&#123; f[i]=(f[i-1]+f[i-2])%MOD; &#125; for (register int i=1;i&lt;MAXN;++i)&#123; pref[i]=(pref[i-1]+f[i])%MOD; &#125;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int s0,s1; int tag; inline int len()&#123;return r-l+1;&#125; &#125;tree[MAXN&lt;&lt;2]; inline int Get_S(int x,int n)&#123;//求S(m) if (n==1) return tree[x].s0; if (n==2) return tree[x].s1; return (tree[x].s0*f[n-2]%MOD+tree[x].s1*f[n-1]%MOD)%MOD; &#125; #define lc i&lt;&lt;1 #define rc i&lt;&lt;1|1 inline void pushup(int i)&#123; tree[i].s0=(tree[lc].s0+Get_S(rc,tree[lc].len()+1))%MOD; tree[i].s1=(tree[lc].s1+Get_S(rc,tree[lc].len()+2))%MOD; &#125; inline void Change(int i,int c)&#123; int l=tree[i].len(); tree[i].s0=(tree[i].s0+pref[l]*c%MOD)%MOD; tree[i].s1=(tree[i].s1+pref2[l]*c%MOD)%MOD; &#125; inline void pushdown(int i)&#123; if (tree[i].tag)&#123; Change(lc,tree[i].tag); Change(rc,tree[i].tag); tree[lc].tag=(tree[lc].tag+tree[i].tag)%MOD; tree[rc].tag=(tree[rc].tag+tree[i].tag)%MOD; tree[i].tag=0; &#125; &#125; void Build(int i,int l,int r)&#123; tree[i].l=l,tree[i].r=r; tree[i].tag=0; if (l==r)&#123; tree[i].s0=tree[i].s1=a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; Build(lc,l,mid); Build(rc,mid+1,r); pushup(i); &#125; void Update(int i,int L,int R,int val)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].tag=(tree[i].tag+val)%MOD; Change(i,val); return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (L&lt;=mid) Update(lc,L,R,val); if (mid&lt;R) Update(rc,L,R,val); pushup(i); &#125; void Update_Pos(int i,int index,int val)&#123; if (tree[i].l==tree[i].r)&#123; tree[i].s1=tree[i].s0=val; return ; &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if (index&lt;=mid) Update_Pos(lc,index,val); else Update_Pos(rc,index,val); pushup(i); &#125; int Query(int i,int L,int R)&#123; if (L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; return Get_S(i,tree[i].l-L+1); &#125; pushdown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; int ans=0; if (L&lt;=mid) ans=(ans+Query(lc,L,R))%MOD; if (mid&lt;R) ans=(ans+Query(rc,L,R))%MOD; return ans; &#125;&#125;using namespace SegmentTree;#undef intint main()&#123;#define int long long Init(); int n=read(),m=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; Build(1,1,n); for (register int i=1;i&lt;=m;++i)&#123; int opr=read(); if (opr==1)&#123; int pos=read(),x=read(); Update_Pos(1,pos,x); &#125; else if (opr==2)&#123; int l=read(),r=read(); printf(\"%I64d\\n\",Query(1,l,r)); &#125; else if (opr==3)&#123; int l=read(),r=read(),val=read(); Update(1,l,r,val); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"CF145E Lucky Queries 线段树","slug":"CF145E Lucky Queries","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/2af40d72.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/2af40d72.html","excerpt":"","text":"传送门 题解一看数据范围就知道是线段树不过怎样区间翻转是一个问题这里的思想非常巧妙记录最长不上升子序列的长度在区间翻转的时候,交换最长不上升子序列的长度和最长不下降子序列的长度即可.还有合并区间时需要用到一点$\\rm dp$的思想代码有点丑神犇勿喷$code$: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAXN 1000005#define ll intusing namespace std;struct node&#123; int sheng,jiang,seven,four; bool lazy;&#125;tree[MAXN*4];int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int n,m;void swap(int &amp;a,int &amp;b)&#123; int t=a; a=b; b=t;&#125;char str[MAXN];void push_up(int i)&#123; tree[i].seven=tree[i&lt;&lt;1].seven+tree[i&lt;&lt;1|1].seven; tree[i].four=tree[i&lt;&lt;1].four+tree[i&lt;&lt;1|1].four; int max1=max(tree[i&lt;&lt;1].sheng+tree[i&lt;&lt;1|1].seven,tree[i&lt;&lt;1].four+tree[i&lt;&lt;1|1].sheng); tree[i].sheng=max(max1,tree[i&lt;&lt;1].four+tree[i&lt;&lt;1|1].seven); //可能前面不下降,后面全7 //可能前面全4,后面不下降 //可能前面全4,后面全7 int max2=max(tree[i&lt;&lt;1].jiang+tree[i&lt;&lt;1|1].four,tree[i&lt;&lt;1].seven+tree[i&lt;&lt;1|1].jiang); tree[i].jiang=max(max2,tree[i&lt;&lt;1].seven+tree[i&lt;&lt;1|1].four); //同理&#125;void buildtree(int l,int r,int i)&#123; if (l==r)&#123; tree[i].sheng=1; tree[i].jiang=1; tree[i].seven=(str[l]=='7'); tree[i].four=!tree[i].seven; return ; &#125; int mid=(l+r)&gt;&gt;1; buildtree(l,mid,i&lt;&lt;1); buildtree(mid+1,r,i&lt;&lt;1|1); push_up(i);&#125;void rev(int i)&#123; tree[i].lazy=!tree[i].lazy; swap(tree[i].four,tree[i].seven); swap(tree[i].jiang,tree[i].sheng); //区间翻转需要swap一下&#125;void update(int l,int r,int L,int R,int i)&#123; if (r&lt;L||l&gt;R)&#123; return ; &#125; if (r&lt;=R&amp;&amp;l&gt;=L)&#123; rev(i); return ; &#125; if (tree[i].lazy)&#123; tree[i].lazy=false; rev(i&lt;&lt;1); rev(i&lt;&lt;1|1); &#125; int mid=(l+r)&gt;&gt;1; if (mid&gt;=r)&#123; update(l,mid,L,R,i&lt;&lt;1); &#125; else if (l&gt;mid)&#123; update(mid+1,r,L,R,i&lt;&lt;1|1); &#125; else &#123; update(l,mid,L,R,i&lt;&lt;1); update(mid+1,r,L,R,i&lt;&lt;1|1); &#125; push_up(i);&#125;int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;m,str+1); buildtree(1,n,1); int ans; for (int t=0;t&lt;m;t++)&#123; char ch[100]; scanf(\"%s\",ch); if (ch[0]=='c')&#123; printf(\"%d\\n\",tree[1].sheng); &#125; else &#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); update(1,n,l,r,1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"}]},{"title":"数论学习笔记","slug":"数论学习笔记","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.360Z","comments":true,"path":"archives/7850e5e5.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/7850e5e5.html","excerpt":"","text":"组合数都是一些定义吧。。。性质$1.$，从$n$个东西中选$k$个选和选$n-k$个不选是一样的。性质$2.$，从$n+1$个东西中选$k$个，可以在其中$n$个东西中选$k$个，剩下一个不选，也可以在其中$n$个东西中选$k-1$个，剩下一个选。性质$2.$在预处理组合数时经常用到，如： 123456for (register int i=0;i&lt;MAXN;++i)&#123; C[i][0]=1,C[i][i]=1; for (register int j=1;j&lt;i;++j)&#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; &#125;&#125; 还有一个神奇的性质，我们把$(x+a)^n$拆开，变成$(x+a)(x+a)….$发现$x$的系数为$k$时，相当于在$n$个$x$中选$k$个，剩下$n-k$个选$a$所以系数为$C_n^k$，所以，$(x+a)^n=\\sum^n_{k=0}C^k_nx^ka^{n-k}$根据这个性质，我们把$x=1$，$a=1$代入，发现$\\sum^n_{i=0}C^i_n=(1+1)^n=2^n$。把$x=1$，$a=-1$代入，发现$\\sum^n_{i=0}(-1)^iC^i_n=(1+(-1))^n=0$ 剩下的性质，自己脑补一些场景，也可以证明出来。 卡特兰数 所有奇卡特兰数，下标都满足$n=2^k-1$（不知道有啥用，手动狗头） 前$6$点基本上都是老生常谈了，长方形填充还是挺巧妙的。 考虑一个可行的方案，必有如图的一个长方形，它的一个顶点在阶梯上，另一个在阶梯的最下面的角上（标成红色），要不然整个长方形不可能填充完。 发现它上方和右方的小阶梯可以构成子状态，$yy$一下，发现$F(n)=\\sum^{n-1}_{i=0}{(F(i)+F(n-i-1))}$ 这不就是卡特兰数吗？ GCD&amp;LCM大家都知道$gcd(x,y)$=$gcd(y,x\\mod y)$，我们可以用如下的算法求$gcd$。 1int gcd(int x,int y)&#123;return x%y==0?y:gcd(y,x%y);&#125; 我们发现一个数对一个小于它的数取模后至少缩小一半，所以算法复杂度为$log(n)$，实际可能还更小。 拓展欧几里得算法求$ax+by=c$的正整数解。首先根据裴蜀定理，我们知道：$gcd(a,b)|c$，否则方程无解。设$d=\\frac{c}{gcd(a,b)}$，则知道$ax+by=gcd(a,b)$的解，我们把解出的$x,y$都乘个$d$就能得出原方程的解$x’,y’$。 考虑把问题简单化，只求$ax+by=gcd(a,b)$的正整数解。考虑如下的方程：$ax_1+by_1=gcd(a,b)$$bx_2+(a\\mod b)y_2=gcd(b,a\\mod b)$ 我们知道$gcd(a,b)=gcd(b,a\\mod b)$所以$ax_1+by_1=bx_2+(a\\mod b)y_2$又知道$a\\mod b=a-\\lfloor a/b \\rfloor \\times b$我们把上面的柿子代入：发现$ax_1+by_1=bx_2+(a-\\lfloor a/b \\rfloor \\times b)y_2$化一下：$ax_1+by_1=ay_2+b(x_2-\\lfloor a/b \\rfloor \\times y_2)$对比两边系数，我们开心地发现$x_1=y_2$，$y_1=x_2-\\lfloor a/b \\rfloor \\times y_2$，于是我们可以根据$x_2,y_2$算出$x_1,y_1$ 具体实现的时候，递归求解即可。 模板： 1234567891011int gcd(int a,int b,int &amp;d,int &amp;x,int&amp;y)&#123; if(!b)&#123; d=a,x=1,y=0; return x; &#125; else&#123; gcd(b,a%b,d,y,x); y-=x*(a/b); &#125; return x;&#125; BSGS （北上广深算法）已知$a,b,p$，求$a^x=b(\\mod p)$的正整数解。 考虑折半法，我们设$B=\\sqrt{P}$，将$x$化为$B \\times i-j$的形式，其中$i&lt;B,j&lt;B$将$x$代入原柿子，发现$a^x=a^{B \\times i-j}=a^{B \\times i} / a^j$把那个$a^j$搞到右边，发现$a^{B \\times i}=b \\times a^j$其中，左右两边只有$i,j$两个变量，取值只有$B$种可能。考虑把$b \\times a^j$预处理出来，丢进一个$map$或哈希表里面。后面一个一个枚举$a^{B \\times i}$，查询$map$或哈希表里面有没有。 思维比较简单，但是代码比较长。时间复杂度$O(\\sqrt {n})$ 模板题：P2485 [SDOI2011]计算器 题解：对于询问$1.$，快速幂即可。对于询问$2.$，逆元即可，注意判断不存在的情况。（当然$extgcd$也是可做的）对于询问$3.$，需要运用$BSGS$算法，具体实现时需要注意$B \\times i-j$可能为负，需要$+p$再取模，并且$j=0$，$b \\times a^j=b$也是合法的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int p;inline int ksm(int b,int k)&#123; int ans=1; while (k)&#123; if (k&amp;1) ans=(ans*b)%p; b=(b*b)%p; k&gt;&gt;=1; &#125; return ans;&#125;inline void Solve1(int T)&#123;//快速幂 while (T--)&#123; int y=read(),z=read();p=read(); y%=p; printf(\"%lld\\n\",ksm(y,z)); &#125;&#125;inline void Solve2(int T)&#123;//逆元 while (T--)&#123; int y=read(),z=read();p=read(); y%=p,z%=p; if (y==0&amp;&amp;z!=0)&#123; printf(\"Orz, I cannot find x!\\n\"); continue; &#125; printf(\"%lld\\n\",ksm(y,p-2)*z%p); &#125;&#125;map&lt;int,int&gt;M;inline void BSGS(int a,int b)&#123; if (a==0&amp;&amp;b!=0)&#123; printf(\"Orz, I cannot find x!\\n\"); return ; &#125; int B=(int)sqrt(p); M.clear(); int now=b%p; M[now]=0; for (register int i=1;i&lt;=B;++i)&#123; now=(now*a)%p; M[now]=i; &#125; now=1; int S=ksm(a,B); for (register int j=1;j&lt;=B;++j)&#123; //判断a^&#123;B \\times i&#125;是否在表中 now=(now*S)%p; if (M.count(now))&#123; int ans=j*B-M[now];//M[now]=i printf(\"%lld\\n\",(ans%p+p)%p); return ; &#125; &#125; printf(\"Orz, I cannot find x!\\n\");&#125;inline void Solve3(int T)&#123;//BSGS while (T--)&#123; int y=read(),z=read();p=read(); BSGS(y%p,z); &#125;&#125;#undef intint main()&#123;#define int long long int T=read(),K=read(); if (K==1) Solve1(T); else if (K==2) Solve2(T); else Solve3(T);&#125; EXCRT 扩展中国剩余定理在中国剩余定理的基础上，膜数$p_1,p_2,p_3…,p_n$可能不是质数：假设现在我们已经求出前$k-1$个方程的解了，设为是$x$：设$M=lcm(p_{1},p_{2},….p_{k-1})$，那么我们发现前$k-1$个方程的通解可以表示成$x+M \\times alb$(这些解都可以成立)，其中$alb$是整数。我们要求$t$，使得$x+M \\times t=a_k (\\mod p_k)$，也就是$M \\times t =a_k-x(\\mod p_k)$可以用$extgcd$求解$t$，解完$t$后，就发现前$k$个式子的一个解为$x+t \\times M$ 整体思路也就是把式子合并合并再合并。 话说这个东西和$CRT$关系好像不是很大。 高斯消元可以求解类似于 a_{11} \\times x + a_{12} \\times y + a_{13} \\times z ....... = b_1a_{21} \\times x + a_{22} \\times y + a_{23} \\times z ....... = b_2a_{31} \\times x + a_{32} \\times y + a_{33} \\times z ....... = b_3................................................................................的方程。 假设我们有三个式子，假设$alb$为现在未知数个数，现在$alb$为$3$： 1 \\times x + 2 \\times y + 3 \\times z = 4 ... (1)2 \\times x + 3 \\times y + 4 \\times z = 5 ... (2)3 \\times x + 4 \\times y + 7 \\times z = 6 ... (3)我们把$(1)$中的$x$设为主元，和$(2)(3)$式相减。 (2)-(1) \\times 2 : -1 \\times y + -2 \\times z = -3 ... (4)(3)-(1) \\times 3 : -2 \\times y + -2 \\times z = -6 ... (5)发现$alb=2$，继续执行一遍类似的操作，把$(4)$中的$y$设为主元，和$(5)$式相减。 (5)-(4) \\times 2 : 2 \\times z = 0我们就成功地解出了$z$，把$z$往上带，可以求出$x$，$y$，就可以解出方程。不仅对于$alb=3$的情况，$alb$更大，也可以用类似的方法求出未知数。时间复杂度$O(alb^2)$高斯消元的操作可以转换为矩阵操作，其实就是把一个普通矩阵转换为单位矩阵。 逆矩阵单位矩阵$e$：只有主对角线为$1$的矩阵容易发现单位矩阵乘任意矩阵，任意矩阵乘单位矩阵都为其本身于是定义一个$n\\times n$的矩阵$A$的逆矩阵为$A^{-1}$满足$A \\times A^{-1}=e$;若$B \\times A=C$,则$B=C*A^{-1}$矩阵初等变换：交换两行/列，将一行/列的若干倍加到另一行/列上去（这些操作都可以通过左乘初等变换矩阵实现）那么可以把$A$搞成$e$的变换矩阵就是$A^{-1}$了过程就是高斯消元，开始在原矩阵的旁边维护一个$e$对原矩阵的操作，都对这个矩阵也做一次这样当$A$变成$e$了，原来的这个$e$就变成$A^{-1}$了 我们可以把操作矩阵定义为$C_1,C_2,…C_k$，发现$A \\times C_1 \\times C_2 \\times C_3 … \\times C_k=e$，由于矩阵支持结合律，我们可以在这个式子两边同时乘以$A^{-1}$，发现$A \\times A^{-1} \\times C_1 \\times C_2 \\times C_3 … \\times C_k=e \\times A^{-1}$由于上面的两条性质$A \\times A^{-1}=e$和$A \\times e = A$，我们可以将式子化为$e \\times C_1 \\times C_2 \\times C_3 … \\times C_k = A^{-1}$ 所以原来的$e$就变为$A^{-1}$了，是不是很巧妙？ 拉格朗日插值法全然わからない！，似乎是一个构造函数的神奇方法，留个坑待填。 一道小水题 P4986","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"}]},{"title":"P1627 [CQOI2009]中位数 前缀和","slug":"P1627 [CQOI2009]中位数","date":"2019-07-13T12:34:14.000Z","updated":"2019-08-31T04:12:32.357Z","comments":true,"path":"archives/233c63b9.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/233c63b9.html","excerpt":"","text":"传送门大概就是运用判断中位数的套路吧。把大于$b$的数设为$1$，等于的设为$0$，小于的设为$-1$。若一个数列经过这样处理后和为$0$，说明$d$为该数列的中位数。从中位数的位置分别向左向右求前缀和，放进一个桶里面。最后乘法原理统计答案。 本蒟蒻还被边界孙了甚久。123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int l[MAXN],r[MAXN],p[MAXN];int bl[MAXN&lt;&lt;1],br[MAXN&lt;&lt;1];inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;int main()&#123; int n=read(),b=read(); int pos=0; for (register int i=1;i&lt;=n;++i)&#123; p[i]=read();if (p[i]==b) pos=i; p[i]=(p[i]&gt;=b)?(p[i]&gt;b?1:0):-1; &#125; for (register int i=pos-1;i&gt;=0;--i)&#123; l[i]=l[i+1]+p[i]; bl[l[i]+MAXN]++; &#125; int ans=0; for (register int i=pos+1;i&lt;=n;++i)&#123; r[i]=r[i-1]+p[i]; ans+=bl[-r[i]+MAXN]; &#125; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"数学","slug":"数学","permalink":"https://gaisaiyuno.github.io/tags/数学/"},{"name":"前缀和","slug":"前缀和","permalink":"https://gaisaiyuno.github.io/tags/前缀和/"}]},{"title":"CF525E Anya and Cubes 双向搜索","slug":"CF525E Anya and Cubes","date":"2019-07-13T11:58:14.000Z","updated":"2019-08-31T04:12:32.356Z","comments":true,"path":"archives/73ef83bb.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/73ef83bb.html","excerpt":"","text":"题目给你$n$个数,$n≤26$，初始序列为$a_i$,$1≤a_i≤10^9$ 你有$k$个$!$ ,每个$!$可以使序列中的一个数变成$a_i!$（$k$不一定要用完）例如$5!=120$ 求:选出任意个数使他们和的等于$S$的方案数$(0≤S≤10^{16})$ 题解首先$20!&gt;10^{16}$，于是当$a_i&gt;20$的时候，不能让$a_i$变成$a_i!$这就少了很多情况。接下来，定义$Map[k][Sum]$为使用$k$个阶乘符号，和为$Sum$的方法数。双向搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#include &lt;hash_map&gt;#define MAXN 30#define int long longusing namespace std;inline int read() &#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x*10)+(ch-'0'); ch=getchar(); &#125; return x*f;&#125;int a[MAXN],fac[MAXN],n,k,S;unordered_map&lt;int,int&gt;Map[MAXN];inline void Init()&#123; fac[1]=1; for (register int i=2;i&lt;=20;++i)&#123; fac[i]=fac[i-1]*i; &#125;&#125;//三种状态：不选，选，阶乘void dfs1(int l,int r,int Sum,int usek)&#123; if (l&gt;r)&#123; Map[usek][Sum]++; return ; &#125; dfs1(l+1,r,Sum,usek); dfs1(l+1,r,Sum+a[l],usek); if (a[l]&lt;=20) dfs1(l+1,r,Sum+fac[a[l]],usek+1);&#125;int ans;void dfs2(int l,int r,int Sum,int usek)&#123; if (l&gt;r)&#123; for (register int i=0;i&lt;=k-usek;++i)&#123;//还能用多少k ans+=Map[i][S-Sum]; &#125; return ; &#125; dfs2(l+1,r,Sum,usek); dfs2(l+1,r,Sum+a[l],usek); if (a[l]&lt;=20) dfs2(l+1,r,Sum+fac[a[l]],usek+1);&#125; #undef intint main()&#123;#define int long long Init(); n=read(),k=read(),S=read(); for (register int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; dfs1(1,n/2,0,0); dfs2(n/2+1,n,0,0); printf(\"%lld\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"搜索","slug":"搜索","permalink":"https://gaisaiyuno.github.io/tags/搜索/"},{"name":"双向搜索","slug":"双向搜索","permalink":"https://gaisaiyuno.github.io/tags/双向搜索/"}]},{"title":"P2839 [国家集训队]middle（可持久化线段树+二分）","slug":"P2839 [国家集训队]middle（可持久化线段树+二分）","date":"2019-07-13T11:46:14.000Z","updated":"2019-08-31T04:12:32.358Z","comments":true,"path":"archives/1c5d594e.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/1c5d594e.html","excerpt":"","text":"题目传送门一个长度为$n$的序列$a$，设其排过序之后为$b$，其中位数定义为$b[n/2]$，其中$a,b$从$0$开始标号,除法取下整。给你一个长度为$n$的序列$s$。回答$Q$个这样的询问：$s$的左端点在$[a,b]$之间,右端点在$[c,d]$之间的子序列中，最大的中位数。其中$a&lt;b&lt;c&lt;d$。位置也从$0$开始标号。我会使用一些方式强制你在线。 题解寻找中位数有一个通常的套路：考虑二分中位数，设$x$是现在二分的数，$mid$是序列的中位数：将大于$x$的数设为$1$，小于$x$的数设为$-1$。将整个$1/-1$序列求和若$Sum&gt;0$，说明$1$的数量比$-1$多，也就是大于$x$的数比小于$x$的数多说明$x&lt;=mid$反之$x&gt;mid$ 回到本题，$[b+1,c-1]$为必选区间，$[a,b]$选后缀，$[c,d]$选前缀。要使中位数尽可能大，我们要使$Sum$尽量大。因为$[b+1,c-1]$固定且$[a,b]$后缀$[c,d]$前缀互不影响，所以在$[a,b]$区间我们选择最大后缀，在$[c,d]$区间我们选择最大前缀。 至此，我们已经有具体思路了：线段树维护区间最大前缀，最大后缀，区间和，每次二分，用线段树判断可不可行。 但是，若使用普通线段树，每次查询都要重置区间为$1/-1$，所以查询时间复杂度为$O(nlogn)$不$TLE$才奇怪。 考虑使用可持久化线段树，把每次二分后的$1/-1$序列预处理下来，每次查询就是查一个历史版本这样每次查询时间复杂度为$O(log^2n)$，预处理复杂度为$O(nlogn)$，总复杂度为$O(nlogn+qlog^2n)$可以$AC$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;#define MAXN 20005using namespace std;inline int read()&#123; int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'); ch=getchar(); &#125; return x*f;&#125;namespace SegmentTree&#123; struct node&#123; int l,r; int lmax,rmax,sum; &#125;tree[MAXN*20]; int tot; #define lc tree[i].l #define rc tree[i].r node operator + (node A,node B)&#123; node C; C.sum=A.sum+B.sum; C.lmax=max(A.lmax,A.sum+B.lmax); C.rmax=max(B.rmax,A.rmax+B.sum); return C; &#125; void pushup(int i)&#123; tree[i].sum=tree[lc].sum+tree[rc].sum; tree[i].lmax=max(tree[lc].lmax,tree[lc].sum+tree[rc].lmax); tree[i].rmax=max(tree[rc].rmax,tree[lc].rmax+tree[rc].sum); &#125; inline void Value(int i,int val)&#123; tree[i].sum=tree[i].lmax=tree[i].rmax=val; &#125; void build(int &amp;i,int L,int R)&#123;//一开始都是1 if (!i) i=++tot; Value(i,R-L+1); if (L==R)&#123; return ; &#125; int mid=(L+R)&gt;&gt;1; build(lc,L,mid); build(rc,mid+1,R); pushup(i); &#125; void update(int &amp;i,int L,int R,int index)&#123;//修改成-1 tree[++tot]=tree[i],i=tot;//新建节点 if (L==R) &#123; Value(i,-1); return ; &#125; int mid=(L+R)&gt;&gt;1; if (index&lt;=mid) update(lc,L,mid,index); else update(rc,mid+1,R,index); pushup(i); &#125; node query(int i,int L,int R,int ql,int qr)&#123; if (ql&lt;=L&amp;&amp;R&lt;=qr)&#123; return tree[i]; &#125; int mid=(L+R)&gt;&gt;1; if (ql&gt;mid) return query(rc,mid+1,R,ql,qr); else if (qr&lt;=mid) return query(lc,L,mid,ql,qr); else return query(lc,L,mid,ql,qr)+query(rc,mid+1,R,ql,qr); &#125;&#125;using namespace SegmentTree;int rt[MAXN];int a[MAXN],b[MAXN],c[MAXN];//b:id a:原数组inline bool cmp(int A,int B)&#123; return a[A]&lt;a[B];&#125;inline void discrete(int n)&#123;//离散化 for (register int i=1;i&lt;=n;++i) b[i]=i; sort(b+1,b+1+n,cmp);&#125;int n;#define VAR rt[mid],1,ninline int Check(int mid,int A,int B,int C,int D)&#123;//[A,B] [B+1,C-1] [C,D] int sum=0; if (B+1&lt;=C-1) sum+=query(VAR,B+1,C-1).sum;//这个特判容易漏掉 sum+=query(VAR,A,B).rmax; sum+=query(VAR,C,D).lmax; return sum;&#125;int p[4];int main()&#123; n=read(); for (register int i=1;i&lt;=n;++i) a[i]=read(); discrete(n); build(rt[1],1,n); for (register int i=2;i&lt;=n;++i)&#123;//预处理历史版本 rt[i]=rt[i-1]; update(rt[i],1,n,b[i-1]); &#125; int last=0; int q=read(); while (q--)&#123; for (register int i=0;i&lt;4;++i)&#123; p[i]=(read()+last)%n+1; &#125; sort(p,p+4); int A=p[0],B=p[1],C=p[2],D=p[3]; int l=1,r=n; int ans=0; while (l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if (Check(mid,A,B,C,D)&gt;=0) &#123; ans=a[b[mid]]; l=mid+1; &#125; else &#123; r=mid-1; &#125; &#125; last=ans; printf(\"%d\\n\",ans); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://gaisaiyuno.github.io/tags/题解/"},{"name":"线段树","slug":"线段树","permalink":"https://gaisaiyuno.github.io/tags/线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://gaisaiyuno.github.io/tags/主席树/"},{"name":"可持久化","slug":"可持久化","permalink":"https://gaisaiyuno.github.io/tags/可持久化/"},{"name":"作业","slug":"作业","permalink":"https://gaisaiyuno.github.io/tags/作业/"}]},{"title":"vscode配置","slug":"vscode","date":"2019-07-12T07:24:36.000Z","updated":"2019-08-31T04:10:58.781Z","comments":true,"path":"archives/849a3ae4.html","link":"","permalink":"https://gaisaiyuno.github.io/archives/849a3ae4.html","excerpt":"","text":"从学校电脑上拷回来的，应该电脑上装了g++或dev c++都可以使用，对于OIer非常方便lauch.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123;​ // 使用 IntelliSense 了解相关属性。 ​ // 悬停以查看现有属性的描述。​ // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387​ &quot;version&quot;: &quot;0.2.0&quot;,​ &quot;configurations&quot;: [​ &#123;​ &quot;name&quot;: &quot;(Windows) Launch&quot;,​ &quot;type&quot;: &quot;cppvsdbg&quot;,​ &quot;request&quot;: &quot;launch&quot;,​ &quot;program&quot;: &quot;cmd&quot;,​ &quot;args&quot;: [​ &quot;/c&quot;,​ &quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;,​ &quot;&amp;echo.&quot;,​ &quot;&amp;pause&quot;​ ],​ &quot;stopAtEntry&quot;: false,​ &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,​ &quot;environment&quot;: [],​ &quot;externalConsole&quot;: true​ &#125;,​ &#123;​ &quot;name&quot;: &quot;(Windows)(g++) Build&amp;Launch&quot;,​ &quot;type&quot;: &quot;cppvsdbg&quot;,​ &quot;request&quot;: &quot;launch&quot;,​ &quot;program&quot;: &quot;cmd&quot;,​ &quot;args&quot;: [​ &quot;/c&quot;,​ &quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;,​ &quot;&amp;echo.&quot;,​ &quot;&amp;pause&quot;​ ],​ &quot;stopAtEntry&quot;: false,​ &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,​ &quot;environment&quot;: [],​ &quot;externalConsole&quot;: true,​ &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;​ &#125;,​ &#123;​ &quot;name&quot;: &quot;(gdb)(g++) Launch&quot;,​ &quot;type&quot;: &quot;cppdbg&quot;,​ &quot;request&quot;: &quot;launch&quot;,​ &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,​ &quot;args&quot;: [],​ &quot;stopAtEntry&quot;: false,​ &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,​ &quot;environment&quot;: [],​ &quot;externalConsole&quot;: true,​ &quot;MIMode&quot;: &quot;gdb&quot;,​ &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;,​ &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;,​ &quot;setupCommands&quot;: [​ &#123;​ &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,​ &quot;text&quot;: &quot;-enable-pretty-printing&quot;,​ &quot;ignoreFailures&quot;: true​ &#125;​ ]​ &#125;,​ &#123;​ &quot;name&quot;: &quot;(Windows)(g++) Build&amp;Launch (O2)&quot;,​ &quot;type&quot;: &quot;cppvsdbg&quot;,​ &quot;request&quot;: &quot;launch&quot;,​ &quot;program&quot;: &quot;cmd&quot;,​ &quot;args&quot;: [​ &quot;/c&quot;,​ &quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;,​ &quot;&amp;echo.&quot;,​ &quot;&amp;pause&quot;​ ],​ &quot;stopAtEntry&quot;: false,​ &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,​ &quot;environment&quot;: [],​ &quot;externalConsole&quot;: true,​ &quot;preLaunchTask&quot;: &quot;g++.exe build active file with O2&quot;​ &#125;,​ ],&#125; tasks.json123456789101112131415161718192021&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++.exe build active file&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-Wall&quot;, &quot;-g&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.cpp&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], // &quot;options&quot;: &#123; // &quot;cwd&quot;: &quot;C:\\\\Program Files (x86)\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot; // &#125; //如果电脑上没有g++，但是装了dev c++，去掉这行注释 &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;","categories":[],"tags":[{"name":"实用","slug":"实用","permalink":"https://gaisaiyuno.github.io/tags/实用/"}]}]}