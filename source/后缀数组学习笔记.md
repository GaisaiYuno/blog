---
title: 后缀数组学习笔记
abbrlink: e4343e5e
date: 2020-01-26 22:38:28
tags:
  - 字符串
  - 后缀数组
---

博客咕了好久啊……

### 定义

字符串的下标从$1$开始。

$len(s)$，代表字符串$s$的长度。

$s[l,r]$，代表截取字符串$s$的第$l$到第$r$位作为新的字符串。

$s_1+s_2$，代表两字符串的拼接。

## 实现

我们来看一看怎么对$s[1,n],s[2,n],s[3,n]...s[n,n]$这$n$个字符串进行字典序排序，$sa[i]$代表的就是$s[i,n]$在这些字符串里面的排名。

我这人脑回路比较清奇，可能讲解的方法跟别人不一样。

首先，我们来看看百度百科上怎么定义字典序的：

给定两个偏序集$A$和$B$，$(a,b)$和$(a′,b′)$属于笛卡尔积$A×B$，则字典序定义为
$(a,b) \le (a′,b′)$ 当且仅当$a<a′$或（$a=a′$且$b≤b′$）
结果是偏序。如果$A$和$B$是全序, 那么结果也是全序。

（浓浓的shy气息）

我们来简要理解一下，可以这么看，如果一个字符串只包含单个字符，我们定义$""<"a"<"b"<"c"< ... <"z"$，还有，我们认为$s_1+s_2 \le s_3 + s_4$（$len(s_1) = len(s_3)$且$len(s_2) = len(s_4)$）当且仅当$s_1 < s_3$或者$s_1 = s_3$且$s_2 \le s_4$。

后缀排序的本质就是模拟上述拼接的过程。

假设$len(s)=n$，且使$2^m>n$最小的$m$是$k$，假设我们给$s$接上$2^k$个空字符（字典序最小），然后问题转化为对$s[1,2^k],s[2,2^k+1],s[3,2^k+2] ... s[n,n+2^k-1]$排序。

你可能会异或，为什么非要是$2^k$，看了下面这张图就会明白：![](https://cdn.jsdelivr.net/gh/GaisaiYuno/imghost/20160205125603928.png)

我们先对$s[1,2^0],s[2,2^0+1],s[3,2^0+2] ... s[n,n+2^0-1]$排序。（就是单个字符）

根据定义，$s[k,k+2^i-1]=s[k,k+2^{i-1}-1]+s[k+2^{i-1},k+2^i-1]$。

而$s[k,k+2^{i-1}-1],s[k+2^{i-1},k+2^i-1]$都在上一轮排序里面处理过了，那么就转化为对$(s[k,k+2^{i-1}-1],s[k+2^{i-1},k+2^i-1])$这些二元组排序。

可以敲出代码（$O(n \log ^2n)$）：

```cpp
#include <bits/stdc++.h>
#define MAXN 1000005
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=(x<<3)+(x<<1)+(ch^'0');
        ch=getchar();
    }
    return x*f;
}
char s[MAXN];
int a[MAXN],sa[MAXN];
pair<int,int>arr[MAXN],temp[MAXN];
int main(){
	scanf("%s",s+1);
	int n=strlen(s+1);
	for (int i=1;i<=n;++i) a[i]=(int)(s[i]);
	for (int gap=1;gap<=n;gap<<=1){
		for (int i=1;i<=n;++i){
			temp[i]=arr[i]=make_pair(a[i],i+gap<=n?a[i+gap]:0);//（超过n，安排上空字符，排名为0）
		}
		sort(arr+1,arr+1+n);
		int sz=unique(arr+1,arr+1+n)-arr-1;
		for (int i=1;i<=n;++i) a[i]=lower_bound(arr+1,arr+1+sz,temp[i])-arr;
		if (sz==n) break;//如果已经全部相同的话，可以退出循环
	}
	for (int i=1;i<=n;++i) sa[a[i]]=i;
	for (int i=1;i<=n;++i) printf("%d ",sa[i]);
}
```

下面是优化部分：

可以想到，二元组的两个元素取值范围都是$[1,n]$，那么我们可以开$n$个桶，分别排序。

似乎能快一点（$O(n \log ^2 n)$）。

```cpp
#include <bits/stdc++.h>
#define MAXN 1000005
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=(x<<3)+(x<<1)+(ch^'0');
        ch=getchar();
    }
    return x*f;
}
char s[MAXN];
int a[MAXN],sa[MAXN];
pair<int,int>temp[MAXN];
static vector<int>V[MAXN];
void Insert(pair<int,int>p){
	V[p.first].emplace_back(p.second);
}
int sum[MAXN];
int main(){
	scanf("%s",s+1);
	int n=strlen(s+1);
	for (int i=1;i<=n;++i){
		a[i]=(int)(s[i])+1;
	}
	for (int gap=1;gap<=n;gap<<=1){
		for (int i=1;i<=max(128,n);++i){
			V[i].clear();
		}
		for (int i=1;i<=n;++i){
			temp[i]=make_pair(a[i],i+gap<=n?a[i+gap]:0);
			Insert(temp[i]);
		}
		bool flag=true;
		for (int i=1;i<=max(128,n);++i){
			sum[i]=V[i].size();
			sort(V[i].begin(),V[i].end());
			V[i].erase(unique(V[i].begin(),V[i].end()),V[i].end());
			if (sum[i]!=V[i].size()) flag=false;
			sum[i]=V[i].size();
		}
		for (int i=1;i<=max(128,n);++i) sum[i]+=sum[i-1];
		for (int i=1;i<=n;++i){
			a[i]=sum[temp[i].first-1]+lower_bound(V[temp[i].first].begin(),V[temp[i].first].end(),temp[i].second)-V[temp[i].first].begin()+1;
		}
		if (flag) break;
	}
	for (int i=1;i<=n;++i) sa[a[i]]=i;
	for (int i=1;i<=n;++i) printf("%d ",sa[i]);
}
```

下面我们看看怎么优化到$O(n \log n)$。

### 继续定义

$a[]$ 



```cpp
#include <bits/stdc++.h>
#define MAXN 1000005
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
static int a[MAXN],b[MAXN],sa[MAXN],sum[MAXN],c[MAXN];
int n,m;
char s[MAXN];
void Sort(){
	for (int i=1;i<=n;++i) c[i]=a[b[i]];//c[i]是一个优化，似乎能快一点
	for (int i=1;i<=m;++i) sum[i]=0;
	for (int i=1;i<=n;++i) sum[a[i]]++;
	for (int i=1;i<=m;++i) sum[i]+=sum[i-1];
	for (int i=n;i>=1;--i) sa[sum[c[i]]--]=b[i];
}
void SuffixSort(){
	for (int i=1;i<=n;++i) a[i]=s[i],b[i]=i;
	Sort();
	for (int gap=1;gap<=n;gap<<=1){
		int pos=0;
		for (int i=n-gap+1;i<=n;++i) b[++pos]=i;//保证有gap个 
		for (int i=1;i<=n;++i) if (sa[i]>gap) b[++pos]=sa[i]-gap;//保证有n-gap个 
		Sort(),swap(a,b);
		a[sa[1]]=pos=1;
		for (int i=2;i<=n;++i) a[sa[i]]=(b[sa[i]]==b[sa[i-1]]&&b[sa[i]+gap]==b[sa[i-1]+gap])?pos:++pos;
		if (pos==n) break;
		m=pos;
	}
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	m=127;
	SuffixSort();
	for (int i=1;i<=n;++i) printf("%d ",sa[i]);
	puts("");
}
```